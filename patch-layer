Bug da risolvere:
1) Non renderizza!!
* 2) Se rendo invisibile il baselayer e rimuovo i layer invisibili Blender crash!!
3) Bordino nero sulla pennellata in un layer trasparente.

Todo
* 1) Se il layer è invisibile si disattiva opacità e blend mode.
* 2) Controllare nella funzione select layer quando l'indice esce fuori dal range per il caso previous e next.
3) Cursore inerenti al tools (es.contagoccie)
* 4) Per la funzione PAINT_OT_sample_color visualizzare riquadro come in mypaint.
	4.1) Controllare nella modalità paint il colore preso in considerazione.
5) Il baselayer non si può cancellare solo se è da solo.Layers v0.1 beta2 new features and fixed bug for Phase 1. Completed: 15\04\2012:
	 1. FIX: Fixed many memory problems.
	 2. FIX: Increased the range of parameters of the function "sdrawbox" in "glutil.c". When you 
			 have a zomm very excessive, the dashed border of the layer changed direction.
	 3. FIX: Almost solved the problem of the black border, when you paint on a layer.
	 4. UPD: The layers are handled by the bottom to the top, as in GIMP e PS.
	 5. UPD: Improved UI.
	 6. UPD: Layer names are handled by the API of Blender
	 7. UPD: The BaseLayer if it is not a layer, it can not be moved.
	 8. UPD: Added control to manage operations on layers only when it is in the "Painting mode".
	 9. ADD: Added Menu for the management of the layers.
	10. ADD: Added the ability to create layers above or below a selected layer.
	11. ADD: For some operations have been associated keyboard shortcuts.
	12. ADD: Added the Menu "Select".
	13. ADD: Added the dotted border around the layer. With the ability to change color at the 
			 dotted line in the Theme Manager. In addition there is also the possibility to 
			 disable it.
	14. ADD: Now you see a cursor in the Image Space more inherent, which is disabled if you can
			 not draw.
	15. ADD: When you invoke the Color Sample in paint mode, you see a box at the bottom left with 
			 the selected color.
	16. ADD: Added the ability to clear a layer, even if the layer is loaded a photo.
	17. ADD: The Color Picker in the Image Editor, in Vertex Paint and Texture Paint change to 
			 reflect your choices nell'User Preferences.
	18. ADD: You can add an image as a layer.
	19. ADD: Added the Menu "Order".
	20. ADD: Added the Menu "Merge".
	21. ADD: Ability to lock a layer.


Layers v0.1 beta1 new features and fixed bug 02\03\2012:
    1. FIX: Fixed many bugs from the patch of KWK.
    2. UPD: Improved UI.
    3. ADD: With the creation of a new image now you can choose the background color: Transparent, 
            White, RGB.
    4. ADD: Ability to duplicate a layer.
    5. ADD: Blend Modes: Normal, Multiply, Screen, Overlay, Soft Light, Hard Light, Color Dodge, 
            Linear Dodge, Color Burn, Linear Burn, Average, Add, Subtract, Difference, Lighten, 
            Darken, Negation, Exclusion, Linear Light, Vivid Light, Pin Light, Hard Light.

GIT:

    ...

TODO:

    - ALTA  :
        ...

    - MEDIA :
        ...

Video 02\03\2012:
1) https://vimeo.com/37814580

Builds 02\03\2012:
32: ...
64: ...

Patch 02\03\2012:
- ...Layers v0.1 beta2 new features and fixed bug for Phase 1. Completed: 15\04\2012:
	 1. FIX: Risolti molti problemi di memoria.
	 2. FIX: Aumentato il range dei parametri della funzione "sdrawbox" in "glutil.c". Quando si ha 
			 un zomm molto eccessivo il bordo tratteggiato del layer cambiava direzione.
	 3. FIX: Quasi risolto il problema del bordo nero, quando si dipinge su un layer.
	 4. UPD: I layer vengono gestiti dal basso verso l'alto, come in GIMP e PS.
	 5. UPD: Migliorata la UI.
	 6. UPD: Per controllare se il nome del layer è unico, si usano le API di Blender.
	 7. UPD: Il BaseLayer se non è un layer non può essere spostato.
	 8. UPD: Aggiunto controllo per gestire le operazioni sui layer solo quando si è nella modalità 
			 "Painting mode".
	 9. ADD: Aggiunto Menu per la gestione dei layer.
	10. ADD: Aggiunta la possibilità di creare layer sopra o sotto un layer selezionato.
	11. ADD: Per alcune operazioni sono stati associate le scorciatoie da tastiera.
	12. ADD: Aggiunto il menù Select.
	13. ADD: Aggiunto il bordo tratteggiato intorno al layer. Con la possibilità di cambiare colore 
			 al tratteggio nel Theme Manager. Inoltre c'è anche la possibilità di disattivarlo.
	14. ADD: Ora si visualizza nello Space Image un cursore più inerente per pittare, il quale viene
			 disattivato nel caso in cui non è possibile disegnare.
	15. ADD: Quando si richiama il Sample Color nella modalità per disegnare si visualizzare un 
			 riquadro in basso a sinistra con il colore selezionato.
	16. ADD: Aggiunto la possibilità di pulire un layer anche se nel layer è caricata una foto.
	17. ADD: Ora il Color Picker nell'Image Editor, nel Vertex Paint e nel Texture Paint cambiano in
			 base alla modalità scelta nell'User Preferences.
	18. ADD: Si può aggiungere un'immagine come layer.
	19. ADD: Aggiunto il menù "Ordina".
	20. ADD: Aggiunto il menù "Unisci".
	21. ADD: Possibilità di bloccare un layer.


Layers v0.1 beta1 new features and fixed bug 02\03\2012:
    1. FIX: Risolti molti bug dalla patch di KWK.
    2. UPD: Migliorata la UI.
    3. ADD: Creando una nuova immagine ora si può scegliere il colore di background: Trasparente, 
            Bianco, RGB.
    4. ADD: Possibilità di duplicare un layer.
    5. ADD: Blend Modes: Normal, Multiply, Screen, Overlay, Soft Light, Hard Light, Color Dodge, 
            Linear Dodge, Color Burn, Linear Burn, Average, Add, Subtract, Difference, Lighten, 
            Darken, Negation, Exclusion, Linear Light, Vivid Light, Pin Light, Hard Light.


GIT:

    ...


TODO:

    - ALTA  :
        ...

    - MEDIA :
		- Finire gestione layer
		- Undo e redo layer
        - Lock layer
		* Invertire l'ordine dei layer, come in photoshop e gimp 
		- Menu layer con operazioni sui layer (esposizione, saturazione, tinta, contrasto, temperatura di colore e tinta, nitidezza, trasforma)
		- Salvataggio e lettura
		- Importazione ed esportazione per gimp, ps, openraster(mypaint)
		- - http://en.wikipedia.org/wiki/OpenRaster ; http://gitorious.org/openraster
		- Operazioni sull'immagine (esposizione, saturazione, tinta, contrasto, temperatura di colore e tinta, nitidezza, trasforma)
		- Brush


Video 02\03\2012:
1) https://vimeo.com/37814580


Builds 02\03\2012:
32: ...
64: ...


Patch 02\03\2012:
- ...

Hello everyone!
Regarding my last work on the layer manager, I have drawn up a roadmap and started raising funds for
the development of the Image Layer.
The project is divided for a total of 6 phases, where each stage has its budget.
Each phase addresses a particular aspect, such as: layer management, operations, etc..
List of stages:
Phase 1:
    Stage    : Management
    Target   : Management and operations common to organize Layer.

Phase 2:
    Stage    : Transform
    Target   : Simple operation to change the selected layer.

Phase 3:
    Stage    : Color
    Target   : Operation for the color management.

Phase 4:
    Stage    : Import & Export
    Target   : Import and export in the formats most commonly used layer.

Phase 5:
    Stage    : Tools
    Target   : Paint Tools, Selection Tools, Generic Tools

Phase 6:
    Stage    : Brush
    Target   : Improvement Brush

To further explore each stage, you can check out my blog: http://ruesp83.wordpress.com
Additionally, I created the pages where you can report bugs and suggest new features related to 
image layer.
This project can be developed and improved only with help from everyone! So I can spend more time 
developing the Image Layer for Blender.

At the moment 120,67€ has already be funded! But to make sure that this project will get a boost 
more money is needed. Total needed funds for the project is 3000€ , but the project will be started 
when 500€ has been collected.

Your donation will be used to continue to improve this project.
Thank everyone in advance for your contribution!

Best regards,
Fabio Russo (ruesp83)Phase 1:
    Stage    : Management
    Target   : Gestione e comuni operazioni per organizzare i Layer
    Deadline : 15/04/2012
    Amount   : 500€
    Info     : 
        1) Operazioni per la gestione dei layer.
            Menu Layer
            *    |-> Add
            *        |-> New Layer
            *        |-> ------------------
            *        |-> Above active layer
            *        |-> Below active layer
            *    |-> Duplicate Layer
            *    |-> Pulisci Layer
            *    |-> Remove Layer
            *        |-> Livello
            *        |-> Livelli Nascosti
            *    |-> Unisci
            *        |-> Unisci Livelli
            *        |-> Unisci Visibili
            *        |-> Unico Livello
            *    |-> ------------------
            *    |-> Seleziona
            *        |-> Seleziona il livello precedente
            *        |-> Seleziona il livello successivo
            *        |-> Seleziona il livello in cima
            *        |-> Seleziona il livello in fondo
            *    |-> Ordina //icon='SORTALPHA'
            *        |-> Porta in primo piano
            *        |-> Porta Avanti
            *        |-> Porta Dietro
            *        |-> Porta Sotto
            *        |-> Inverti Ordine livelli
        * 2) Inserire immagine come layer.
        3) Undo & Redo Layer.
        * 4) Lock Layer.
        5) Lettura e salvataggio file .Blend.
        * 6) Bordo Tratteggiato Layer.
        ** 7) Miglioramento e aggiunta di qualche altro Blend Mode.


Phase 2:
    Stage    : Transform
    Target   : Semplici operazione per modificare il layer selezionato.
    Deadline : Defined after phase 1
    Amount   : 800€
    Info     : 
        1) Operazioni per la modifica dei layer.
            Menu Layer
                |-> Ordina ...
                |-> Trasforma
                    |-> Rifletti Orizzontalmente
                    |-> Rifletti Verticalmente
                    |-> ------------------
                    |-> Ruota di 90° in senso orario
                    |-> Ruota di 90° in senso antiorario
                    |-> Ruota di 180°
                    |-> Rotazione Arbitraria
                    |-> ------------------
                    |-> Spostamento
                |-> Scala
                    |-> Dimensioni Margini del livello
                    |-> Livello a dimensione immagine
                    |-> Scala livello
        2) Iniziare integrazione dei layer con Blender.
		3) Salvataggio di un'immagine in un unico layer.


Phase 3:
    Stage    : Color
    Target   : Operazione per la gestione del colore.
    Deadline : Defined after phase 2
    Amount   : 1200€
    Info     : 
        1) Esposizione, saturazione, tinta, contrasto, temperatura di colore e tinta, nitidezza.
        2) Aggiungere GrayScale per il Color Space.
        3) Integrazione dei layer con Blender.
		4) Integration of OpenColorIO and improvement of the Blender color management pipeline https://github.com/thmxv/blender-ocio


Phase 4:
    Stage    : Import & Export
    Target   : Permettere d'importare ed esportare i layer nei formati più comunemente utilizzati.
    Deadline : Defined after phase 3
    Amount   : 2000€
    Info     : Esportazione e importazione in ora, xcf, ...


Phase 5: 
    Stage    : Tools
    Target   : Paint Tools, Selection Tools, Generic Tools
    Deadline : Defined after phase 4
    Amount   : 2500€
    Info     : 
        1) Paint Tools: Color Picker, Text Tool, Bucket Fill, Forme.
        2) Selection Tools: Rectangle, Ellipse, Free, Poligonale.
        3) Generic Tools: Griglia, Strumento Mano, ...


Phase 6: 
    Stage    : Brush
    Target   : Miglioramento Brush 
    Deadline : Defined after phase 5
    Amount   : 3000€
    Info     :
        1) Importare miglioramenti di Jason Wilkins svolti GSOC 2011 nel trunk onion per i Pennelli.
        2) Aggiungere Blend Mode per i Pennelli.
        3) Da definire ancora!!
Index: release/scripts/startup/bl_ui/space_image.py
===================================================================
--- release/scripts/startup/bl_ui/space_image.py	(revisione 44017)
+++ release/scripts/startup/bl_ui/space_image.py	(copia locale)
@@ -647,6 +647,44 @@
             sub.row().prop(uvedit, "draw_stretch_type", expand=True)
 
 
+class IMAGE_PT_image_layers(Panel, ImagePaintPanel):
+    bl_label = "Image Layers"
+
+    @classmethod
+    def poll(cls, context):
+        sima = context.space_data
+        return sima.show_paint
+
+    def draw(self, context):
+        layout = self.layout
+        sima = context.space_data
+        ima = sima.image
+        layers = ima.image_layers
+
+        if ima:
+            row = layout.row()
+            row.template_list(ima, "image_layers", ima.image_layers, "active_image_layer_index", rows=4, maxrows=4)
+
+            col = row.column(align=True)
+            col.operator("image.image_layer_add", text="", icon='ZOOMIN')
+            if layers.active_image_layer:
+                col.operator("image.image_layer_remove", text="", icon='ZOOMOUT')
+                col.operator("image.image_layer_move", text="", icon='TRIA_UP').type = 'UP'
+                col.operator("image.image_layer_move", text="", icon='TRIA_DOWN').type = 'DOWN'
+                #split = layout.split()
+                split = layout.split(percentage=0.35)
+                col = split.column()
+                col.label(text="Name")
+                col.label(text="Opacity:")
+                #col.label(text="Invisible:")
+                col.label(text="Blend Type:")
+                col = split.column()
+                col.prop(layers.active_image_layer, "name", text="")
+                col.prop(layers.active_image_layer, "opacity", text="")
+                #col.prop(layers.active_image_layer, "invisible", text="")
+                col.prop(layers.active_image_layer, "blend_type", text="")
+
+
 class IMAGE_PT_paint(Panel, ImagePaintPanel):
     bl_space_type = 'IMAGE_EDITOR'
     bl_region_type = 'UI'
Index: source/blender/blenkernel/BKE_image.h
===================================================================
--- source/blender/blenkernel/BKE_image.h	(revisione 44017)
+++ source/blender/blenkernel/BKE_image.h	(copia locale)
@@ -38,6 +38,7 @@
 #endif
 
 struct Image;
+struct ImageLayer;
 struct ImBuf;
 struct Tex;
 struct anim;
@@ -77,6 +78,33 @@
 void	tag_image_time(struct Image *ima);
 void	free_old_images(void);
 
+/* Removes all image layers from the image "ima" */
+void image_free_image_layers(struct Image *ima);
+ 
+/* Frees an image layer and associated memory */
+void free_image_layer(struct ImageLayer *layer);
+ 
+/* Removes the currently selected image layer */
+int image_remove_current_image_layer(struct Image *ima);
+ 
+/* Adds another image layer and selects it */
+struct ImageLayer *image_add_image_layer(struct Image *ima, const char *name, int depth, float color[4]);
+
+/* Adds the base layer of images that points Image->ibufs.first */
+int image_add_image_layer_base(struct Image *ima);
+ 
+/* Returns the index of the currently selected image layer */
+short imalayer_get_current_num(struct Image *ima);
+ 
+/* Selects the image layer with the number specified in "value" */
+void imalayer_set_current_num(struct Image *ima, short value);
+ 
+/* Returns the image layer that is currently selected */
+struct ImageLayer *imalayer_get_current(struct Image *ima);
+ 
+/* Fills the current selected image layer with the color given */
+void imalayer_fill_color(struct Image *ima, float color[4]);
+
 /* ********************************** NEW IMAGE API *********************** */
 
 /* ImageUser is in Texture, in Nodes, Background Image, Image Window, .... */
Index: source/blender/blenkernel/intern/image.c
===================================================================
--- source/blender/blenkernel/intern/image.c	(revisione 44017)
+++ source/blender/blenkernel/intern/image.c	(copia locale)
@@ -218,6 +218,7 @@
 			ima->renders[a]= NULL;
 		}
 	}
+	image_free_image_layers(ima);
 }
 
 /* only image block itself */
@@ -240,14 +241,39 @@
 	return ima;
 }
 
+static ImageLayer *layer_alloc(Image *ima, const char *name)
+{
+	ImageLayer *im_l;
+	
+	im_l = (ImageLayer*) MEM_callocN(sizeof(ImageLayer), "image_layer");
+	if(im_l) {
+		im_l->next = im_l->prev = NULL;
+		im_l->opacity = 1.0f;
+		im_l->mode = IMA_LAYER_BLEND;
+		im_l->flag = IMA_LAYER_CURRENT;
+		im_l->type = IMA_LAYER_ALPHA;
+	}
+	return im_l;
+}
+
 /* get the ibuf from an image cache, local use here only */
 static ImBuf *image_get_ibuf(Image *ima, int index, int frame)
 {
+	/* unsigned int totsize= 0; */
+
 	/* this function is intended to be thread safe. with IMA_NO_INDEX this
 	 * should be OK, but when iterating over the list this is more tricky
 	 * */
-	if(index==IMA_NO_INDEX)
+	if(index==IMA_NO_INDEX) {
+		/* TODO: (kwk) This is an ugly hack to return always the active layer's ibuf */
+		ImageLayer *layer= imalayer_get_current(ima);
+		
+		if (layer && layer->ibufs.first)
+			return layer->ibufs.first;
+		
+		/* Only return "normal" image ibuf if no layer ibuf was found. */
 		return ima->ibufs.first;
+	}
 	else {
 		ImBuf *ibuf;
 
@@ -296,6 +322,8 @@
 		/* now we don't want copies? */
 		if(link && ibuf->index==link->index)
 			image_remove_ibuf(ima, link);
+
+		image_add_image_layer_base(ima);
 	}
 }
 
@@ -688,6 +716,270 @@
 	}
 }
 
+void image_free_image_layers(struct Image *ima)
+{
+	ImageLayer *img_lay, *next;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima == NULL)
+		return;
+ 
+	ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+	for (img_lay=ima->imlayers.first; img_lay; img_lay=img_lay->next)
+	{
+		next = img_lay->next;
+		BLI_remlink(&ima->imlayers, img_lay);
+		free_image_layer(img_lay);
+		img_lay = next;
+	}
+	
+	BLI_freelistN(&ima->imlayers);
+ 
+	BKE_image_release_ibuf(ima, lock);
+}
+ 
+void free_image_layer(ImageLayer *layer)
+{
+	ImBuf *ibuf, *next;
+ 
+	if (!layer)
+		return;
+ 
+	ibuf= (layer->ibufs).first;
+	while(ibuf) {
+		next= ibuf->next;
+		BLI_remlink(&layer->ibufs, ibuf);
+ 
+		if((layer->flag & IMA_LAYER_BASE)==0) {
+			if (ibuf->userdata) {
+				MEM_freeN(ibuf->userdata);
+				ibuf->userdata = NULL;
+			}
+ 
+			IMB_freeImBuf(ibuf);
+		}
+		ibuf= next;
+	}
+	/*BLI_freelistN(&layer->ibufs);*/
+ 
+	MEM_freeN(layer);
+}
+ 
+ImageLayer *imalayer_get_current(Image *ima)
+{
+	ImageLayer *layer;
+	if(ima == NULL)
+		return 0;
+ 
+	for(layer=ima->imlayers.first; layer; layer=layer->next){
+		if(layer->flag & IMA_LAYER_CURRENT)
+			return layer;
+	}
+ 
+	return 0;
+}
+ 
+short imalayer_get_current_num(Image *ima)
+{
+	ImageLayer *layer;
+	short i;
+ 
+	if(ima == NULL)
+		return 0;
+ 
+	/*for(layer=ima->imlayers.first, i=0; layer; layer=layer->next, i++)
+		if(layer->flag & IMA_LAYER_CURRENT)
+			return i;*/
+ 
+	return ima->Ind_Layers;
+}
+ 
+void imalayer_set_current_num(Image *ima, short index)
+{
+	ImageLayer *layer;
+	short i;
+ 
+	if(ima == NULL)
+		return;
+	for(layer=ima->imlayers.first, i=0; layer; layer=layer->next, i++) {
+		if(i == index)
+		{
+			layer->flag |= IMA_LAYER_CURRENT;
+			ima->Ind_Layers = i;
+		}
+		else
+			layer->flag &= ~IMA_LAYER_CURRENT;
+	}
+	
+}
+ 
+void imalayer_fill_color(struct Image *ima, float color[4])
+{
+	ImageLayer *layer= NULL;
+	ImBuf *ibuf= NULL;
+	unsigned char *rect= NULL;
+	float *rect_float= NULL;
+	void *lock;
+ 
+	if (ima==NULL)
+		return;
+ 
+	ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 
+ 
+	layer= imalayer_get_current(ima);
+ 
+	if ((ibuf = ima->imlayers.first)) {
+		if (ibuf->flags & IB_rectfloat) {
+			rect_float= (float*)ibuf->rect_float;
+		}
+		else {
+			rect= (unsigned char*)ibuf->rect;
+		}
+ 
+		//BKE_image_buf_fill_color(rect, rect_float, ibuf->x, ibuf->y, color);
+	}
+ 
+	BKE_image_release_ibuf(ima, lock);
+}
+ 
+int image_remove_current_image_layer(Image *ima)
+{
+	ImageLayer *layer= NULL;
+ 
+	if(ima==NULL)
+		return FALSE;
+ 
+	layer= imalayer_get_current(ima);
+	BLI_remlink(&ima->imlayers, layer);
+	free_image_layer(layer);
+
+	/* Ensure the first element in list gets selected (if any) */
+	if(ima->imlayers.first)
+		((ImageLayer *) ima->imlayers.first)->flag |= IMA_LAYER_CURRENT;
+ 
+	return TRUE;
+}
+ 
+/* Works in most of the cases but since no unique name is nessecary, this is acceptable as a start. */
+static void imalayer_unique_name(const ListBase *imlayers, ImageLayer *newlayer)
+{
+	char *new_name = 0;
+	int new_len = 0;
+	int suffix;
+	ImageLayer *i;
+	char *name = newlayer->name;
+ 
+	/* When list is empty, there's no need to check name */
+	if (!imlayers->first)
+		return;
+ 
+	/* Iterate over every list element and check */
+	for(i=imlayers->first; i; i=i->next) {
+ 
+		/* If names differ, go to next element */
+		if(strcmp(name, i->name))
+			continue;
+ 
+		if(!new_name) {
+				int len = strlen(name);
+ 
+				if(len >= 4 && sscanf(name + len - 4, ".%03d", &suffix) == 1) {
+					new_len = len;
+				}
+				else {
+					suffix = 0;
+					new_len = len + 4;
+					if(new_len > 31)
+						new_len = 31;
+				}
+ 
+				new_name = MEM_mallocN(new_len + 1, "new_name");
+				strcpy(new_name, name);
+				name = new_name;
+		}
+		sprintf(new_name + new_len - 4, ".%03d", ++suffix);
+	}
+ 
+	if(new_name) {
+		strcpy(newlayer->name, new_name);
+		MEM_freeN(new_name);
+	}
+}
+ 
+ImageLayer *image_add_image_layer(Image *ima, const char *name, int depth, float color[4])
+{
+	ImageLayer *layer, *im_l = NULL;
+	ImBuf *ibuf, *imaibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return FALSE;
+ 	
+	
+	/* Deselect other layers */
+	for(layer = ima->imlayers.first; layer; layer=layer->next)
+		layer->flag &= ~IMA_LAYER_CURRENT;
+
+	im_l = layer_alloc(ima, name);
+
+	if (im_l)
+	{
+		ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 
+		strcpy(im_l->name, name);
+		imalayer_unique_name(&ima->imlayers, im_l);
+ 
+		imaibuf = (ImBuf*)ima->ibufs.first;
+		ibuf = add_ibuf_size(imaibuf->x, imaibuf->y, im_l->name, depth, imaibuf->flags, 0, color);
+		BLI_addtail(&im_l->ibufs, ibuf);
+		BLI_addtail(&ima->imlayers, im_l);
+		ima->Ind_Layers = BLI_countlist(&ima->imlayers)-1;
+		if (color[3] == 1.0f)
+			im_l->type = IMA_LAYER_RGB;
+
+		BKE_image_release_ibuf(ima, lock);
+	}
+ 
+	return im_l;
+}
+ 
+/* TODO: (kwk) Base image layer needs proper locking... */
+int image_add_image_layer_base(Image *ima)
+{
+	ImageLayer *layer, *im_l = NULL;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return FALSE;
+ 
+	/* Deselect other layers */
+	//for(layer = ima->imlayers.first; layer; layer=layer->id.next)
+	//	layer->flag &= ~IMA_LAYER_CURRENT;
+ 
+	im_l = layer_alloc(ima, "BaseLayer");
+	
+	if (im_l)
+	{	
+		//ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+		strcpy(im_l->name, "BaseLayer");
+		imalayer_unique_name(&ima->imlayers, im_l);
+ 		im_l->flag = IMA_LAYER_CURRENT | IMA_LAYER_BASE; /* BASE causes no free on deletion of layer */
+		ima->Ind_Layers = 0;
+		/* Get ImBuf from ima */
+		ibuf = (ImBuf*)ima->ibufs.first;
+		BLI_addtail(&im_l->ibufs, ibuf);
+		BLI_addtail(&ima->imlayers, im_l);
+ 
+		BKE_image_release_ibuf(ima, lock);
+	}
+	return TRUE;
+}
+
+/* TODO: (kwk) This function must also calculate  */
+
 static uintptr_t image_mem_size(Image *ima)
 {
 	ImBuf *ibuf, *ibufm;
Index: source/blender/editors/space_image/image_draw.c
===================================================================
--- source/blender/editors/space_image/image_draw.c	(revisione 44017)
+++ source/blender/editors/space_image/image_draw.c	(copia locale)
@@ -490,6 +490,30 @@
 	MEM_freeN(rectf);
 }
 
+static void draw_opacity_buffer(ARegion *ar, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy, float opacity)
+{
+	int x, y;
+	//int color_manage = scene->r.color_mgt_flag & R_COLOR_MANAGEMENT;
+
+	/* set zoom */
+	glPixelZoom(zoomx, zoomy);
+
+	/* find window pixel coordinates of origin */
+	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
+	
+	glColor4f(1.0f, 1.0f, 1.0f, opacity);
+	//glColor4ub(255,255,255,opacity);
+	//image_verify_buffer_float(ima, ibuf, color_manage);
+	//glPixelTransferf(GL_POST_COLOR_MATRIX_ALPHA_SCALE, opacity);
+	//if(ibuf->rect)
+		//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
+		//glaDrawPixelsTexScaled(x, y, ibuf->x, ibuf->y, GL_RGBA, ibuf->rect, 1.0f, 1.0f);
+	
+	/* reset zoom */
+	glPixelZoom(1.0f, 1.0f);
+}
+
+
 static void draw_image_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
 {
 	int x, y;
@@ -500,7 +524,7 @@
 
 	/* find window pixel coordinates of origin */
 	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
-
+	
 	/* this part is generic image display */
 	if(sima->flag & SI_SHOW_ALPHA) {
 		if(ibuf->rect)
@@ -523,21 +547,23 @@
 
 			glEnable(GL_BLEND);
 			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
 		}
 
 		/* we don't draw floats buffers directly but
 		 * convert them, and optionally apply curves */
 		image_verify_buffer_float(ima, ibuf, color_manage);
-
+		
 		if(ibuf->rect)
-			glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
+			glaDrawPixelsTexScaled(x, y, ibuf->x, ibuf->y, GL_RGBA, ibuf->rect, 1.0f, 1.0f);
 		/*else
 			glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_FLOAT, ibuf->rect_float);*/
 		
 		if(sima->flag & SI_USE_ALPHA)
 			glDisable(GL_BLEND);
 	}
-
+	
 	/* reset zoom */
 	glPixelZoom(1.0f, 1.0f);
 }
@@ -791,7 +817,7 @@
 
 	show_viewer= (ima && ima->source == IMA_SRC_VIEWER);
 	show_render= (show_viewer && ima->type == IMA_TYPE_R_RESULT);
-
+	
 	/* draw the image or grid */
 	if(ibuf==NULL)
 		draw_image_grid(ar, zoomx, zoomy);
@@ -799,6 +825,72 @@
 		draw_image_buffer_repeated(sima, ar, scene, ima, ibuf, zoomx, zoomy);
 	else if(ima && (ima->tpageflag & IMA_TILES))
 		draw_image_buffer_tiled(sima, ar, scene, ima, ibuf, 0.0f, 0.0, zoomx, zoomy);
+	else if (ima && !show_render)
+		//((ima->type & IMA_TYPE_R_RESULT) == 0) && 
+		//((ima->type & IMA_TYPE_COMPOSITE) == 0) && (sima->flag & SI_DRAWTOOL))
+	{
+		ImageLayer *layer;
+ 
+		
+		/*glDisable(GL_DEPTH_TEST);*/
+
+		/*if (ima->imlayers.first==0) {
+			image_add_image_layer_base(ima);
+		}*/
+
+		ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+
+		for(layer=ima->imlayers.first; layer; layer=layer->next) {
+			if ((layer->flag & IMA_LAYER_INVISIBLE) == 0) {
+				ibuf= (ImBuf*)((ImageLayer*)layer->ibufs.first);
+				if (ibuf)
+				{
+					glEnable(GL_BLEND);
+					glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					//glPixelTransferf(GL_POST_COLOR_MATRIX_ALPHA_SCALE, layer->opacity);
+					if ((layer->flag & IMA_LAYER_BASE) == 0)
+					{
+						//glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+						if (layer->type == IMA_LAYER_RGB)
+						{
+							//RGB
+							glBlendFunc(GL_SRC_COLOR, GL_ONE_MINUS_SRC_ALPHA);
+						}
+						else if (layer->type == IMA_LAYER_ALPHA)
+						{
+							//Alpha
+							glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+							
+							//glPixelTransferf(GL_POST_COLOR_MATRIX_ALPHA_SCALE, layer->opacity);
+							//glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+							
+						}
+					}
+					//glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					//glColor4ub(255,255,255, layer->opacity);
+					//glPixelTransferf(GL_POST_COLOR_MATRIX_ALPHA_SCALE, layer->opacity);
+					draw_image_buffer(sima, ar, scene, ima, ibuf, 0.0f, 0.0f, zoomx, zoomy);
+					//glEnable(GL_BLEND);
+					//glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					//glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+					//draw_opacity_buffer(ar, ibuf, 0.0f, 0.0f, zoomx, zoomy, layer->opacity);
+					//glDisable(GL_BLEND);
+					if ((layer->flag & IMA_LAYER_BASE) == 0)
+						glDisable(GL_BLEND);
+					/*glEnable(GL_BLEND);
+					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+					glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					glPixelTransferf(GL_POST_COLOR_MATRIX_ALPHA_SCALE, layer->opacity);
+					glDisable(GL_BLEND);*/
+				}
+			}
+		}
+		
+		/*glEnable(GL_DEPTH_TEST);*/
+
+		BKE_image_release_ibuf(ima, lock);		
+		/*draw_image_buffer(sima, ar, scene, ima, ibuf, 0.0f, 0.0f, zoomx, zoomy);*/
+	}
 	else
 		draw_image_buffer(sima, ar, scene, ima, ibuf, 0.0f, 0.0f, zoomx, zoomy);
 
Index: source/blender/editors/space_image/image_intern.h
===================================================================
--- source/blender/editors/space_image/image_intern.h	(revisione 44017)
+++ source/blender/editors/space_image/image_intern.h	(copia locale)
@@ -95,5 +95,11 @@
 void IMAGE_OT_properties(struct wmOperatorType *ot);
 void IMAGE_OT_scopes(struct wmOperatorType *ot);
 
+/* image layers */
+void IMAGE_OT_image_layer_move(struct wmOperatorType *ot);
+//void IMAGE_OT_image_layer_fill_color(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_remove(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add(struct wmOperatorType *ot);
+
 #endif /* ED_IMAGE_INTERN_H */
 
Index: source/blender/editors/space_image/image_ops.c
===================================================================
--- source/blender/editors/space_image/image_ops.c	(revisione 44017)
+++ source/blender/editors/space_image/image_ops.c	(copia locale)
@@ -1608,6 +1608,187 @@
 	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
 }
 
+/********************** new image layer operators *********************/
+
+int image_layer_poll(bContext *C)
+{
+	return NULL != CTX_data_edit_image(C);
+}
+ 
+static int image_layer_add_exec(bContext *C, wmOperator *op)
+{	
+	char name[22];
+	float color[4];
+	int alpha;
+	Scene *scene;
+	Image *im = CTX_data_edit_image(C);
+	ImageLayer *iml;
+	
+	scene= (Scene*)CTX_data_scene(C);
+
+	RNA_string_get(op->ptr, "name", name);
+	//width= RNA_int_get(op->ptr, "width");
+	//height= RNA_int_get(op->ptr, "height");
+	//floatbuf= RNA_boolean_get(op->ptr, "float");
+	RNA_float_get_array(op->ptr, "color", color);
+	alpha= RNA_boolean_get(op->ptr, "alpha");
+
+	if (scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
+		linearrgb_to_srgb_v3_v3(color, color);
+
+	if(!alpha)
+	{
+		color[3] = 1.0f;
+	}
+	iml = image_add_image_layer(im, name, alpha ? 32 : 24, color);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	/* hook into UI */
+	//Delete
+	//uiIDContextProperty(C, &ptr, &prop);
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, im);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_add(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "Add Image Layer";
+	ot->idname= "IMAGE_OT_image_layer_add";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_add_exec;
+	//ot->poll = image_layer_poll;
+	ot->invoke= image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "ImageLayer", 21, "Name", "Image datablock name.");
+	//RNA_def_int(ot->srna, "width", 1024, 1, INT_MAX, "Width", "Image width.", 1, 16384);
+	//RNA_def_int(ot->srna, "height", 1024, 1, INT_MAX, "Height", "Image height.", 1, 16384);
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+	//RNA_def_boolean(ot->srna, "uv_test_grid", 0, "UV Test Grid", "Fill the image with a grid for UV map testing.");
+	//RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth.");
+}
+ 
+static int image_layer_remove_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	image_remove_current_image_layer(ima);
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_remove(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name= "Remove Image Layer";
+	ot->idname= "IMAGE_OT_image_layer_remove";
+	ot->description="Remove the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_remove_exec;
+	//ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
+ 
+ 
+static int image_layer_move_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer, *tmp;
+	int type, layerID;
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	layer= imalayer_get_current(ima);
+ 
+	if (!layer)
+		return OPERATOR_CANCELLED;
+ 
+	type= RNA_enum_get(op->ptr, "type");
+	layerID= imalayer_get_current_num(ima);
+ 
+	if (type == -1) 
+	{ /* Move direction: Up */
+		if (layerID > 0)
+		{
+			tmp= layer->prev;
+			BLI_remlink(&ima->imlayers, layer);
+			layer->next = layer->prev = NULL;
+			if (tmp) {
+				BLI_insertlinkbefore(&ima->imlayers, tmp, layer);
+			}
+			else {
+				BLI_addhead(&ima->imlayers, layer);
+			}
+			imalayer_set_current_num(ima, layerID-1);
+		}
+	}
+	else 
+	{ /* Move direction: Down */
+		if (layerID < (BLI_countlist(&ima->imlayers)-1))
+		{
+			tmp= layer->next;
+			BLI_remlink(&ima->imlayers, layer);
+			layer->next = layer->prev = NULL;
+			if (tmp) {
+				BLI_insertlinkafter(&ima->imlayers, tmp, layer);
+			}
+			else {
+				BLI_addtail(&ima->imlayers, layer);
+			}	
+			imalayer_set_current_num(ima, layerID+1);
+		}
+	}
+ 
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_move(wmOperatorType *ot)
+{
+	static EnumPropertyItem slot_move[] = {
+		{-1, "UP", 0, "Up", ""},
+		{1, "DOWN", 0, "Down", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Move Imahe Layer";
+	ot->idname= "IMAGE_OT_image_layer_move";
+	ot->description="Move image layers up and down";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_move_exec;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "type", slot_move, 0, "Type", "");
+}
+
 /********************* pack operator *********************/
 
 static int image_pack_test(bContext *C, wmOperator *op)
Index: source/blender/editors/space_image/space_image.c
===================================================================
--- source/blender/editors/space_image/space_image.c	(revisione 44017)
+++ source/blender/editors/space_image/space_image.c	(copia locale)
@@ -492,6 +492,11 @@
 
 	WM_operatortype_append(IMAGE_OT_properties);
 	WM_operatortype_append(IMAGE_OT_scopes);
+
+	WM_operatortype_append(IMAGE_OT_image_layer_move);
+	//WM_operatortype_append(IMAGE_OT_image_layer_fill_color);
+	WM_operatortype_append(IMAGE_OT_image_layer_remove);
+	WM_operatortype_append(IMAGE_OT_image_layer_add);
 }
 
 static void image_keymap(struct wmKeyConfig *keyconf)
Index: source/blender/makesdna/DNA_image_types.h
===================================================================
--- source/blender/makesdna/DNA_image_types.h	(revisione 44017)
+++ source/blender/makesdna/DNA_image_types.h	(copia locale)
@@ -34,6 +34,10 @@
 
 #include "DNA_ID.h"
 
+#ifndef MAX_LIMA
+#define MAX_LIMA	18
+#endif
+
 struct PackedFile;
 struct Scene;
 struct anim;
@@ -66,6 +70,21 @@
 #define IMA_ANIM_REFRESHED	2
 /* #define IMA_DO_PREMUL	4 */
 
+#define IMA_LAYER_MAX_LEN	240
+
+typedef struct ImageLayer {
+	struct ImageLayer *next, *prev;
+
+	char name[240];
+	short type;
+	short pad;
+	float opacity;
+	short mode;
+	short flag;
+	int pad1;
+	ListBase ibufs;
+}ImageLayer;
+
 typedef struct Image {
 	ID id;
 	
@@ -106,6 +125,9 @@
 	
 	/* display aspect - for UV editing images resized for faster openGL display */
 	float aspx, aspy;
+	int Ind_Layers;
+	int pad1;
+	ListBase imlayers;
 } Image;
 
 
@@ -133,6 +155,36 @@
 
 /* ima->type and ima->source moved to BKE_image.h, for API */
 
+/* **************** IMAGE ********************* */
+/* ImageLayer.type */
+#define IMA_LAYER_RGB		0
+#define IMA_LAYER_ALPHA		1
+#define IMA_LAYER_GRAY		2
+
+/* ImageLayer.mode */
+#define IMA_LAYER_BLEND				0
+#define IMA_LAYER_MUL				1
+#define IMA_LAYER_ADD				2
+#define IMA_LAYER_SUB				3
+#define IMA_LAYER_DIV				4
+#define IMA_LAYER_DARK				5
+#define IMA_LAYER_DIFF				6
+#define IMA_LAYER_LIGHT				7
+#define IMA_LAYER_SCREEN			8
+#define IMA_LAYER_OVERLAY			9
+#define IMA_LAYER_BLEND_HUE			10
+#define IMA_LAYER_BLEND_SAT			11
+#define IMA_LAYER_BLEND_VAL			12
+#define IMA_LAYER_BLEND_COLOR		13
+#define IMA_LAYER_NUM_BLENDTYPES	14
+#define IMA_LAYER_SOFT_LIGHT		15 
+#define IMA_LAYER_LIN_LIGHT			16
+
+/* ImageLayer.flag */
+#define IMA_LAYER_BASE		1
+#define IMA_LAYER_CURRENT	2
+#define IMA_LAYER_INVISIBLE	4
+
 /* render */
 #define IMA_MAX_RENDER_TEXT		512
 #define IMA_MAX_RENDER_SLOT		8
Index: source/blender/makesrna/intern/rna_image.c
===================================================================
--- source/blender/makesrna/intern/rna_image.c	(revisione 44017)
+++ source/blender/makesrna/intern/rna_image.c	(copia locale)
@@ -285,6 +285,53 @@
 	return planes;
 }
 
+static PointerRNA rna_Image_active_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= imalayer_get_current(ima);
+ 
+	return rna_pointer_inherit_refine(ptr, &RNA_ImageLayer, layer);
+}
+
+static void rna_Image_active_image_layer_set(PointerRNA *ptr, PointerRNA value)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= (ImageLayer*)value.data;
+	const int index= BLI_findindex(&ima->imlayers, layer);
+	if (index != -1) ima->Ind_Layers= index;
+}
+
+static void rna_Image_layers_begin(CollectionPropertyIterator *iter, PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	rna_iterator_listbase_begin(iter, &ima->imlayers, NULL);
+}
+
+static int rna_Image_active_image_layer_index_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_current_num(ima);
+}
+ 
+static void rna_Image_active_image_layer_index_set(PointerRNA *ptr, int value)
+{
+	Image *ima= (Image*)ptr->data;
+	imalayer_set_current_num(ima, value);
+}
+ 
+static void rna_Image_active_image_layer_index_range(PointerRNA *ptr, int *min, int *max)
+{
+	Image *im= (Image*)ptr->data;
+	void *lock;
+	ImBuf *ibuf= BKE_image_acquire_ibuf(im, NULL, &lock);
+
+	*min= 0;
+	*max= BLI_countlist(&im->imlayers)-1;
+	*max= MAX2(0, *max);
+
+	BKE_image_release_ibuf(im, lock);
+}
+
 static int rna_Image_pixels_get_length(PointerRNA *ptr, int length[RNA_MAX_ARRAY_DIMENSION])
 {
 	Image *ima= ptr->id.data;
@@ -410,6 +457,114 @@
 	RNA_def_property_ui_text(prop, "Pass", "Pass in multilayer image");
 }
 
+static void rna_def_image_layer_common(StructRNA *srna)
+{
+	PropertyRNA *prop;
+ 
+	static EnumPropertyItem prop_blend_type_items[] = {
+		{IMA_LAYER_BLEND, "MIX", 0, "Mix", ""},
+		{IMA_LAYER_ADD, "ADD", 0, "Add", ""},
+		{IMA_LAYER_SUB, "SUBTRACT", 0, "Subtract", ""},
+		{IMA_LAYER_MUL, "MULTIPLY", 0, "Multiply", ""},
+		{IMA_LAYER_SCREEN, "SCREEN", 0, "Screen", ""},
+		{IMA_LAYER_OVERLAY, "OVERLAY", 0, "Overlay", ""},
+		{IMA_LAYER_DIFF, "DIFFERENCE", 0, "Difference", ""},
+		{IMA_LAYER_DIV, "DIVIDE", 0, "Divide", ""},
+		{IMA_LAYER_DARK, "DARKEN", 0, "Darken", ""},
+		{IMA_LAYER_LIGHT, "LIGHTEN", 0, "Lighten", ""},
+		{IMA_LAYER_BLEND_HUE, "HUE", 0, "Hue", ""},
+		{IMA_LAYER_BLEND_SAT, "SATURATION", 0, "Saturation", ""},
+		{IMA_LAYER_BLEND_VAL, "VALUE", 0, "Value", ""},
+		{IMA_LAYER_BLEND_COLOR, "COLOR", 0, "Color", ""},
+		{IMA_LAYER_SOFT_LIGHT, "SOFT_LIGHT", 0, "Soft Light", ""}, 
+		{IMA_LAYER_LIN_LIGHT    , "LINEAR_LIGHT", 0, "Linear Light", ""}, 
+		{0, NULL, 0, NULL, NULL}};
+	
+	prop= RNA_def_property(srna, "name", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_default(prop, "ImageLayer");
+	RNA_def_property_string_maxlength(prop, IMA_LAYER_MAX_LEN);
+	RNA_def_property_update(prop, NC_OBJECT|ND_MODIFIER|NA_RENAME, NULL);
+	RNA_def_property_ui_text(prop, "Name", "The name of the image layer.");
+	RNA_def_struct_name_property(srna, prop);
+
+ 	prop= RNA_def_property(srna, "visible", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_ui_text(prop, "", "Hides the layer in the UV/Image Editor");
+	RNA_def_property_boolean_sdna(prop, NULL, "flag", IMA_LAYER_INVISIBLE);
+	RNA_def_property_boolean_funcs(prop, "rna_Image_active_image_layer_index_get", "rna_Image_active_image_layer_index_set");
+	//RNA_def_property_ui_text(prop, "Invisible", "Hides the layer in the UV/Image Editor");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+	//RNA_def_property_update(prop, NC_OBJECT|ND_MODIFIER|NA_RENAME, NULL);
+
+	prop= RNA_def_property(srna, "opacity", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "opacity");
+	RNA_def_property_float_default(prop, 1.0f);
+	RNA_def_property_range(prop, 0.0, 1.0);
+	RNA_def_property_ui_text(prop, "Opacity", "The opacity of the image layer when blended.");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "blend_type", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "mode");
+	RNA_def_property_enum_items(prop, prop_blend_type_items);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
+static void rna_def_image_layer(BlenderRNA *brna)
+{
+	StructRNA *srna;
+		
+	srna= RNA_def_struct(brna, "ImageLayer", NULL);
+	RNA_def_struct_ui_text(srna, "Image Layer", "Image layer");
+	RNA_def_struct_ui_icon(srna, ICON_TEXTURE_DATA);
+
+	rna_def_image_layer_common(srna);
+}
+
+static void rna_def_image_layers(BlenderRNA *brna, PropertyRNA *cprop)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	FunctionRNA *func;
+	PropertyRNA *parm;
+
+	RNA_def_property_srna(cprop, "ImageLayers");
+	srna= RNA_def_struct(brna, "ImageLayers", NULL);
+	RNA_def_struct_sdna(srna, "Image");
+	RNA_def_struct_ui_text(srna, "Image Layers", "Image layer");
+	RNA_def_struct_ui_icon(srna, ICON_TEXTURE_DATA);
+
+
+	prop= RNA_def_property(srna, "active_image_layer", PROP_POINTER, PROP_NONE);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_pointer_funcs(prop, "rna_Image_active_image_layer_get", 
+								   "rna_Image_active_image_layer_set", NULL, NULL);
+	RNA_def_property_flag(prop, PROP_EDITABLE|PROP_NEVER_NULL);
+	RNA_def_property_ui_text(prop, "Active Image Layer", "Active image layer");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+ 
+	prop= RNA_def_property(srna, "active_image_layer_index", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Ind_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_active_image_layer_index_get", "rna_Image_active_image_layer_index_set", 
+							   "rna_Image_active_image_layer_index_range");
+	RNA_def_property_ui_text(prop, "Active Image Layer Index", "Index of active image layer slot");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+
+	/*func= RNA_def_function(srna, "new", "rna_RenderLayer_new");
+	RNA_def_function_ui_description(func, "Add a render layer to scene");
+	RNA_def_function_flag(func, FUNC_USE_SELF_ID);
+	parm= RNA_def_string(func, "name", "RenderLayer", 0, "", "New name for the marker (not unique)");
+	RNA_def_property_flag(parm, PROP_REQUIRED);
+	parm= RNA_def_pointer(func, "result", "SceneRenderLayer", "", "Newly created render layer");
+	RNA_def_function_return(func, parm);
+
+	func= RNA_def_function(srna, "remove", "rna_RenderLayer_remove");
+	RNA_def_function_ui_description(func, "Remove a render layer");
+	RNA_def_function_flag(func, FUNC_USE_MAIN|FUNC_USE_REPORTS|FUNC_USE_SELF_ID);
+	parm= RNA_def_pointer(func, "layer", "SceneRenderLayer", "", "Timeline marker to remove");
+	RNA_def_property_flag(parm, PROP_REQUIRED|PROP_NEVER_NULL);*/
+}
+
 static void rna_def_image(BlenderRNA *brna)
 {
 	StructRNA *srna;
@@ -476,6 +631,26 @@
 	RNA_def_property_ui_text(prop, "Field Order", "Order of video fields (select which lines are displayed first)");
 	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
 	
+	/* Image Layers */
+ 
+	prop= RNA_def_property(srna, "image_layers", PROP_COLLECTION, PROP_NONE);
+	RNA_def_property_collection_sdna(prop, NULL, "imlayers", NULL);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	//RNA_def_property_collection_funcs(prop, "rna_Image_layers_begin", "rna_iterator_listbase_next", "rna_iterator_listbase_end", "rna_iterator_listbase_get", 0, 0, 0, 0);
+	RNA_def_property_ui_text(prop, "Image Layers", "");
+	rna_def_image_layers(brna, prop);
+ 
+	/*prop= RNA_def_property(srna, "active_image_layer", PROP_POINTER, PROP_NONE);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_pointer_funcs(prop, "rna_Image_active_image_layer_get", NULL, NULL, NULL);
+	RNA_def_property_ui_text(prop, "Active Image Layer", "Active image layer");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+ 
+	prop= RNA_def_property(srna, "active_image_layer_index", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_funcs(prop, "rna_Image_active_image_layer_index_get", "rna_Image_active_image_layer_index_set", "rna_Image_active_image_layer_index_range");
+	RNA_def_property_ui_text(prop, "Active Image Layer Index", "Index of active image layer slot");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);*/
+
 	/* booleans */
 	prop= RNA_def_property(srna, "use_fields", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "flag", IMA_FIELDS);
@@ -624,6 +799,7 @@
 
 void RNA_def_image(BlenderRNA *brna)
 {
+	rna_def_image_layer(brna);
 	rna_def_image(brna);
 	rna_def_imageuser(brna);
 }
Index: release/scripts/startup/bl_ui/space_image.py
===================================================================
--- release/scripts/startup/bl_ui/space_image.py	(revisione 44608)
+++ release/scripts/startup/bl_ui/space_image.py	(copia locale)
@@ -647,6 +647,56 @@
             sub.row().prop(uvedit, "draw_stretch_type", expand=True)
 
 
+class IMAGE_PT_image_layers(Panel, ImagePaintPanel):
+    bl_label = "Image Layers"
+
+    @classmethod
+    def poll(cls, context):
+        sima = context.space_data
+        return sima.show_paint
+
+    def draw(self, context):
+        layout = self.layout
+        sima = context.space_data
+        ima = sima.image
+        layers = ima.image_layers
+
+        if ima:
+            row = layout.row()
+            row.template_list(ima, "image_layers", ima.image_layers, "active_image_layer_index", rows=5, maxrows=5)
+
+            col = row.column(align=True)
+            col.operator("image.image_layer_add", text="", icon='NEW')
+            
+            if layers.active_image_layer:
+                col.operator("image.image_layer_duplicate", text="", icon='GHOST')
+                sub = col.column()
+                
+                if ((layers.count_image_layers == 1) and 
+                    (layers.active_image_layer.type == 'BASE')):
+                    sub.enabled = False
+                else:
+                    sub.enabled = True
+                sub.operator("image.image_layer_remove", text="", icon='CANCEL')
+                sub.operator("image.image_layer_move", text="", icon='TRIA_UP').type = 'UP'
+                sub.operator("image.image_layer_move", text="", icon='TRIA_DOWN').type = 'DOWN'
+                split = layout.split(percentage=0.35)
+                col = split.column()
+                col.label(text="Name")
+                col.label(text="Opacity:")
+                col.label(text="Blend Type:")
+                col = split.column()
+                col.prop(layers.active_image_layer, "name", text="")
+                sub = col.column()
+                if ((layers.active_image_layer.background != 'ALPHA') and 
+                    (layers.active_image_layer.type == 'BASE')):
+                    sub.enabled = False
+                else:
+                    sub.enabled = True
+                sub.prop(layers.active_image_layer, "opacity", text="")
+                sub.prop(layers.active_image_layer, "blend_type", text="")
+
+
 class IMAGE_PT_paint(Panel, ImagePaintPanel):
     bl_space_type = 'IMAGE_EDITOR'
     bl_region_type = 'UI'
Index: source/blender/blenkernel/BKE_image.h
===================================================================
--- source/blender/blenkernel/BKE_image.h	(revisione 44608)
+++ source/blender/blenkernel/BKE_image.h	(copia locale)
@@ -130,6 +130,7 @@
 
 /* returns existing Image when filename/type is same (frame optional) */
 struct Image *BKE_add_image_file(const char *name);
+struct ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4]);
 
 /* adds image, adds ibuf, generates color or pattern */
 struct Image *BKE_add_image_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4]);
Index: source/blender/blenkernel/BKE_layer.h
===================================================================
--- source/blender/blenkernel/BKE_layer.h	(revisione 0)
+++ source/blender/blenkernel/BKE_layer.h	(copia locale)
@@ -0,0 +1,90 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): ruesp83.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+ #ifndef __BKE_LAYER_H__
+#define __BKE_LAYER_H__
+
+/** \file BKE_layer.h
+ *  \ingroup bke
+ *  \since March 2012
+ *  \author ruesp83
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct Image;
+struct ImageLayer;
+struct ImBuf;
+
+/* call from library */
+
+/* Removes all image layers from the image "ima" */
+void image_free_image_layers(struct Image *ima);
+ 
+/* Frees an image layer and associated memory */
+void free_image_layer(struct ImageLayer *layer);
+ 
+/* Removes the currently selected image layer */
+int image_remove_current_image_layer(struct Image *ima);
+
+/* Removes the currently selected image layer */
+struct ImageLayer *image_duplicate_current_image_layer(struct Image *ima);
+
+/* Adds another image layer and selects it */
+struct ImageLayer *image_add_image_layer(struct Image *ima, const char *name, int depth, float color[4]);
+
+/* Adds the base layer of images that points Image->ibufs.first */
+void image_add_image_layer_base(struct Image *ima);
+ 
+/* Returns the index of the currently selected image layer */
+short imalayer_get_current_act(struct Image *ima);
+
+short imalayer_get_count(struct Image *ima);
+ 
+/* Selects the image layer with the number specified in "value" */
+void imalayer_set_current_act(struct Image *ima, short value);
+ 
+/* Returns the image layer that is currently selected */
+struct ImageLayer *imalayer_get_current(struct Image *ima);
+ 
+/* Fills the current selected image layer with the color given */
+void imalayer_fill_color(struct Image *ima, float color[4]);
+
+void imalayer_unique_name(const struct ListBase *imlayers, struct ImageLayer *newlayer);
+
+struct ImBuf *imalayer_blend(struct ImBuf *base, struct ImBuf *layer, float opacity, short mode);
+
+unsigned int IML_blend_color(unsigned int src1, unsigned int src2, int opacity, short mode);
+void IML_blend_color_float(float *dst, float *src1, float *src2, float opacity, short mode);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
Index: source/blender/blenkernel/CMakeLists.txt
===================================================================
--- source/blender/blenkernel/CMakeLists.txt	(revisione 44608)
+++ source/blender/blenkernel/CMakeLists.txt	(copia locale)
@@ -103,6 +103,7 @@
 	intern/key.c
 	intern/lamp.c
 	intern/lattice.c
+	intern/layer.c
 	intern/library.c
 	intern/material.c
 	intern/mball.c
@@ -190,6 +191,7 @@
 	BKE_key.h
 	BKE_lamp.h
 	BKE_lattice.h
+	BKE_layer.h
 	BKE_library.h
 	BKE_main.h
 	BKE_material.h
Index: source/blender/blenkernel/intern/image.c
===================================================================
--- source/blender/blenkernel/intern/image.c	(revisione 44608)
+++ source/blender/blenkernel/intern/image.c	(copia locale)
@@ -73,6 +73,7 @@
 #include "BKE_global.h"
 #include "BKE_icons.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
 #include "BKE_packedFile.h"
@@ -202,6 +203,7 @@
 {
 	int a;
 
+	image_free_image_layers(ima);
 	image_free_buffers(ima);
 	if (ima->packedfile) {
 		freePackedFile(ima->packedfile);
@@ -218,6 +220,7 @@
 			ima->renders[a]= NULL;
 		}
 	}
+	
 }
 
 /* only image block itself */
@@ -243,11 +246,21 @@
 /* get the ibuf from an image cache, local use here only */
 static ImBuf *image_get_ibuf(Image *ima, int index, int frame)
 {
+	/* unsigned int totsize= 0; */
+
 	/* this function is intended to be thread safe. with IMA_NO_INDEX this
 	 * should be OK, but when iterating over the list this is more tricky
 	 * */
-	if(index==IMA_NO_INDEX)
+	if(index==IMA_NO_INDEX) {
+		/* TODO: (kwk) This is an ugly hack to return always the active layer's ibuf */
+		ImageLayer *layer= imalayer_get_current(ima);
+		
+		if (layer && layer->ibufs.first)
+			return layer->ibufs.first;
+		
+		/* Only return "normal" image ibuf if no layer ibuf was found. */
 		return ima->ibufs.first;
+	}
 	else {
 		ImBuf *ibuf;
 
@@ -296,6 +309,8 @@
 		/* now we don't want copies? */
 		if(link && ibuf->index==link->index)
 			image_remove_ibuf(ima, link);
+
+		image_add_image_layer_base(ima);
 	}
 }
 
@@ -560,7 +575,7 @@
 	return ima;
 }
 
-static ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4])
+ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4])
 {
 	ImBuf *ibuf;
 	unsigned char *rect= NULL;
@@ -609,7 +624,7 @@
 		
 		ibuf= add_ibuf_size(width, height, ima->name, depth, floatbuf, uvtestgrid, color);
 		image_assign_ibuf(ima, ibuf, IMA_NO_INDEX, 0);
-		
+
 		ima->ok= IMA_OK_LOADED;
 	}
 
Index: source/blender/blenkernel/intern/layer.c
===================================================================
--- source/blender/blenkernel/intern/layer.c	(revisione 0)
+++ source/blender/blenkernel/intern/layer.c	(copia locale)
@@ -0,0 +1,756 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * Contributor(s): Blender Foundation, 2006, full recode
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/blenkernel/intern/layer.c
+ *  \ingroup bke
+ */
+ 
+#include <stdio.h>
+#include <string.h>
+
+#include "MEM_guardedalloc.h"
+#include "IMB_imbuf_types.h"
+#include "IMB_imbuf.h"
+
+#include "DNA_userdef_types.h"
+
+#include "BLI_blenlib.h"
+#include "BLI_utildefines.h"
+#include "BLI_math_base.h"
+
+//#include "BKE_icons.h"
+#include "BKE_image.h"
+#include "BKE_layer.h"
+
+ 
+ static ImageLayer *layer_alloc(Image *ima, const char *name)
+{
+	ImageLayer *im_l;
+	
+	im_l = (ImageLayer*) MEM_callocN(sizeof(ImageLayer), "image_layer");
+	if(im_l) {
+		strcpy(im_l->name, name);
+		imalayer_unique_name(&ima->imlayers, im_l);
+		im_l->next = im_l->prev = NULL;
+		im_l->opacity = 1.0f;
+		im_l->mode = IMA_LAYER_NORMAL;
+		im_l->type = IMA_LAYER_LAYER;
+		im_l->visible = IMA_LAYER_VISIBLE;
+		im_l->background = IMA_LAYER_BG_ALPHA;
+		im_l->select = IMA_LAYER_CURRENT;
+	}
+	return im_l;
+}
+
+void image_free_image_layers(struct Image *ima)
+{
+	ImageLayer *img_lay, *next;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima->imlayers.first == NULL)
+		return;
+
+	ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+	while((img_lay=ima->imlayers.first)) {
+		BLI_remlink(&ima->imlayers, img_lay);
+		free_image_layer(img_lay);
+	}
+
+	ima->Count_Layers = 0;
+	BKE_image_release_ibuf(ima, lock);
+}
+ 
+void free_image_layer(ImageLayer *layer)
+{
+	ImBuf *ibuf, *next;
+ 
+	if (!layer)
+		return;
+
+	while((ibuf = layer->ibufs.first)) {
+		BLI_remlink(&layer->ibufs, ibuf);
+ 
+		if (ibuf->userdata) {
+			MEM_freeN(ibuf->userdata);
+			ibuf->userdata = NULL;
+		}
+ 
+		IMB_freeImBuf(ibuf);
+	}
+
+	MEM_freeN(layer);
+}
+ 
+ImageLayer *imalayer_get_current(Image *ima)
+{
+	ImageLayer *layer;
+	if(ima == NULL)
+		return 0;
+ 
+	for(layer=ima->imlayers.first; layer; layer=layer->next){
+		if(layer->select & IMA_LAYER_CURRENT)
+			return layer;
+	}
+ 
+	return NULL;
+}
+
+short imalayer_get_count(Image *ima)
+{
+	if(ima == NULL)
+		return 0;
+ 
+	return ima->Count_Layers;
+}
+short imalayer_get_current_act(Image *ima)
+{
+	if(ima == NULL)
+		return 0;
+ 
+	return ima->Act_Layers;
+}
+ 
+void imalayer_set_current_act(Image *ima, short index)
+{
+	ImageLayer *layer;
+	short i;
+ 
+	if(ima == NULL)
+		return;
+	for(layer=ima->imlayers.first, i=0; layer; layer=layer->next, i++) {
+		if(i == index) {
+			layer->select = IMA_LAYER_CURRENT;
+			ima->Act_Layers = i;
+		}
+		else
+			layer->select = !IMA_LAYER_CURRENT;
+	}
+	
+}
+ 
+void imalayer_fill_color(struct Image *ima, float color[4])
+{
+	ImageLayer *layer= NULL;
+	ImBuf *ibuf= NULL;
+	unsigned char *rect= NULL;
+	float *rect_float= NULL;
+	void *lock;
+ 
+	if (ima==NULL)
+		return;
+ 
+	ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 
+ 
+	layer= imalayer_get_current(ima);
+ 
+	if ((ibuf = ima->imlayers.first)) {
+		if (ibuf->flags & IB_rectfloat) {
+			rect_float= (float*)ibuf->rect_float;
+		}
+		else {
+			rect= (unsigned char*)ibuf->rect;
+		}
+ 
+		//BKE_image_buf_fill_color(rect, rect_float, ibuf->x, ibuf->y, color);
+	}
+ 
+	BKE_image_release_ibuf(ima, lock);
+}
+
+ImageLayer *image_duplicate_current_image_layer(Image *ima)
+{
+	char *new_name = 0;
+	int len = 0, new_len = 0;
+	ImageLayer *layer = NULL, *im_l = NULL;
+	ImBuf *ibuf, *new_ibuf;
+	void *lock;
+	int suffix;
+ 
+	if(ima==NULL)
+		return NULL;
+ 
+	layer= imalayer_get_current(ima);
+
+	len = strlen(layer->name);
+ 
+	if(len >= 4 && sscanf(layer->name + len - 8, "copy.%03d", &suffix) == 1) {
+		new_len = len;
+	}
+	else {
+		suffix = 0;
+		new_len = len + 9;
+		if(new_len > 31)
+			new_len = 31;
+	}
+ 
+	new_name = MEM_mallocN(new_len + 1, "new_name");
+	strcpy(new_name, layer->name);
+	sprintf(new_name + new_len - 9, " copy.%03d", ++suffix);
+
+	im_l = layer_alloc(ima, new_name);
+	MEM_freeN(new_name);
+	if (im_l) {
+		ibuf= (ImBuf*)((ImageLayer*)layer->ibufs.first);
+		if (ibuf) {
+			new_ibuf = IMB_dupImBuf(ibuf);
+			BLI_addtail(&im_l->ibufs, new_ibuf);
+
+			im_l->next = im_l->prev = NULL;
+			if (layer) {
+				BLI_insertlinkafter(&ima->imlayers, layer, im_l);
+			}
+			else {
+				BLI_addtail(&ima->imlayers, layer);
+			}
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima)+1);
+		}
+		ima->Count_Layers += 1;
+	}
+	
+	return im_l;
+}
+ 
+int image_remove_current_image_layer(Image *ima)
+{
+	ImageLayer *layer= NULL;
+	 
+	if(ima==NULL)
+		return FALSE;
+ 
+	layer = imalayer_get_current(ima);
+
+	if (layer) {
+		if (layer->type & IMA_LAYER_BASE) {
+			ImageLayer *next= NULL;
+
+			next = layer->next;
+			ima->imlayers.first = next;
+			//ima->imlayers.last = next;
+			//printf("last=%d\n", ima->imlayers.last);
+			next->prev = NULL;
+		}
+		else 
+			BLI_remlink(&ima->imlayers, layer);
+		free_image_layer(layer);
+	}
+	/* Ensure the first element in list gets selected (if any) */
+	if(ima->imlayers.first)
+		if (layer->type & IMA_LAYER_BASE)
+			imalayer_set_current_act(ima, 0);
+		else
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima)-1);
+	ima->Count_Layers -= 1;
+	return TRUE;
+}
+
+static char blend_normal(const char B, const char L, float O)
+{	
+	return (char)(O * (L) + (1.0f - O) * B);
+}
+
+static char blend_lighten(const char B, const char L, float O)
+{	
+	return (char)(O * ((L > B) ? L : B) + (1.0f - O) * B);
+}
+
+static char blend_darken(const char B, const char L, float O)
+{	
+	return (char)(O * ((L > B) ? B : L) + (1.0f - O) * B);
+}
+
+static char blend_multiply(const char B, const char L, float O)
+{	
+	return (char)(O * ((B * L) / 255) + (1.0f - O) * B);
+}
+
+static char blend_average(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L) / 2) + (1.0f - O) * B);
+}
+
+static char blend_add(const char B, const char L, float O)
+{	
+	return (char)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static char blend_subtract(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static char blend_difference(const char B, const char L, float O)
+{	
+	return (char)(O * (abs(B - L)) + (1.0f - O) * B);
+}
+
+static char blend_negation(const char B, const char L, float O)
+{	
+	return (char)(O * (255 - abs(255 - B - L)) + (1.0f - O) * B);
+}
+
+static char blend_screen(const char B, const char L, float O)
+{	
+	return (char)(O * (255 - (((255 - B) * (255 - L)) >> 8)) + (1.0f - O) * B);
+}
+
+static char blend_exclusion(const char B, const char L, float O)
+{	
+	return (char)(O * (B + L - 2 * B * L / 255) + (1.0f - O) * B);
+}
+
+static char blend_overlay(const char B, const char L, float O)
+{	
+	return (char)(O * ((L < 128) ? (2 * B * L / 255) : (255 - 2 * (255 - B) * (255 - L) / 255)) + (1.0f - O) * B);
+}
+
+static char blend_soft_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((L < 128) ? (2 * ((B >> 1) + 64)) * ((float)L / 255) : (255 - (2 * (255 - ((B >> 1) + 64)) * (float)(255 - L) / 255))) + (1.0f - O) * B);
+}
+
+static char blend_hard_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((B < 128) ? (2 * L * B / 255) : (255 - 2 * (255 - L) * (255 - B) / 255)) + (1.0f - O) * B);
+}
+
+static char blend_color_dodge(const char B, const char L, float O)
+{	
+	return (char)(O * ((L == 255) ? L : MIN2(255, ((B << 8 ) / (255 - L)))) + (1.0f - O) * B);
+}
+
+static char blend_color_burn(const char B, const char L, float O)
+{	
+	return (char)(O * ((L == 0) ? L : MAX2(0, (255 - ((255 - B) << 8 ) / L))) + (1.0f - O) * B);
+}
+
+static char blend_linear_dodge(const char B, const char L, float O)
+{	
+	return (char)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static char blend_linear_burn(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static char blend_linear_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((2 * L) < 128) ? ((B + (2 * L) < 255) ? 0 : (B + (2 * L) - 255)) : (MIN2(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static char blend_vivid_light(const char B, const char L, float O)
+{	
+	return (char)(O * (L < 128) ? (((2 * L) == 0) ? (2 * L) : MAX2(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (MIN2(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static char blend_pin_light(const char B, const char L, float O)
+{	
+	return (char)(O * (L < 128) ? (((2 * L) > B) ? B : (2 * L)) : (((2 * (L - 128)) > B) ? (2 * (L - 128)) : B) + (1.0f - O) * B);
+}
+
+static char blend_hard_mix(const char B, const char L, float O)
+{	
+	return (char)(O * (((L < 128) ? (((2 * L) == 0) ? (2 * L) : MAX2(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (MIN2(255, (B + (2 * (L - 128))))) < 128) ? 0 : 255) + (1.0f - O) * B);
+}
+
+/*static float blend_normal_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L) + (1.0f - O) * B);
+}
+
+static float blend_lighten_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L > B) ? L : B) + (1.0f - O) * B);
+}
+
+static float blend_darken_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L > B) ? B : L) + (1.0f - O) * B);
+}
+
+static float blend_multiply_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B * L) / 255) + (1.0f - O) * B);
+}
+
+static float blend_average_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L) / 2) + (1.0f - O) * B);
+}
+
+static float blend_add_f(const float B, const float L, float O)
+{	
+	return (float)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static float blend_subtract_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_difference_f(const float B, const float L, float O)
+{	
+	return (float)(O * (abs(B - L)) + (1.0f - O) * B);
+}
+
+static float blend_negation_f(const float B, const float L, float O)
+{	
+	return (float)(O * (255 - abs(255 - B - L)) + (1.0f - O) * B);
+}
+
+static float blend_screen_f(const float B, const float L, float O)
+{	
+	return (float)(O * (255 - (FTOCHAR((255 - B) * (255 - L)) >> 8)) + (1.0f - O) * B);
+}
+
+static float blend_exclusion_f(const float B, const float L, float O)
+{	
+	return (float)(O * (B + L - 2 * B * L / 255) + (1.0f - O) * B);
+}
+
+static float blend_overlay_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L < 128) ? (2 * B * L / 255) : (255 - 2 * (255 - B) * (255 - L) / 255)) + (1.0f - O) * B);
+}
+
+static float blend_soft_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L < 128) ? (2 * ((B >> 1) + 64)) * ((float)L / 255) : (255 - (2 * (255 - ((B >> 1) + 64)) * (float)(255 - L) / 255))) + (1.0f - O) * B);
+}
+
+static float blend_hard_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B < 128) ? (2 * L * B / 255) : (255 - 2 * (255 - L) * (255 - B) / 255)) + (1.0f - O) * B);
+}
+
+static float blend_color_dodge_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L == 255) ? L : minf(255, ((B << 8 ) / (255 - L)))) + (1.0f - O) * B);
+}
+
+static float blend_color_burn_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L == 0) ? L : maxf(0, (255 - ((255 - B) << 8 ) / L))) + (1.0f - O) * B);
+}
+
+static float blend_linear_dodge_f(const float B, const float L, float O)
+{	
+	return (float)(O * (minf(255, (B + L))) + (1.0f - O) * B);
+}
+
+static float blend_linear_burn_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_linear_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((2 * L) < 128) ? ((B + (2 * L) < 255) ? 0 : (B + (2 * L) - 255)) : (minf(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static float blend_vivid_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L < 128) ? (((2 * L) == 0) ? (2 * L) : maxf(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (minf(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static float blend_pin_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L < 128) ? (((2 * L) > B) ? B : (2 * L)) : (((2 * (L - 128)) > B) ? (2 * (L - 128)) : B) + (1.0f - O) * B);
+}
+
+static float blend_hard_mix_f(const float B, const float L, float O)
+{	
+	return (float)(O * (((L < 128) ? (((2 * L) == 0) ? (2 * L) : maxf(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (minf(255, (B + (2 * (L - 128))))) < 128) ? 0 : 255) + (1.0f - O) * B);
+}*/
+
+/*static float blend_normal_f(const float B, const float L, const float O)
+{	
+	return (char)(O * (L) + (1.0f - O) * B);
+}
+
+static float blend_multiply_f(const float B, const float L, const float O)
+{	
+	return (float)(O * ((B * L) / 1.0f) + (1.0f - O) * B);
+}
+
+static float blend_subtract_f(const float B, const float L, const float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_difference_f(const float B, const float L, const float O)
+{	
+	return (float)(O * (fabs(B - L)) + (1.0f - O) * B);
+}
+
+static float blend_overlay_f(float B, float L, float O)
+{	
+	return (float)(O * ((L < 0.5f) ? (2 * B * L / 1.0f) : (1.0f - 2 * (1.0f - B) * (1.0f - L) / 1.0f)) + (1.0f - O) * B);
+}*/
+
+ImBuf *imalayer_blend(ImBuf *base, ImBuf *layer, float opacity, short mode)
+{
+	ImBuf *dest;
+	int i, y;
+	//float (*blend_callback_f)(const float B, const float L, const float O) = NULL;	//Mode callback
+	char (*blend_callback)(const char B, const char L, const float O) = NULL;		//Mode callback
+
+	dest = IMB_dupImBuf(base);
+	if (opacity == 0.0f)
+		return dest;
+
+	switch(mode) {
+	case IMA_LAYER_NORMAL:
+		blend_callback = blend_normal;
+		break;
+
+	case IMA_LAYER_MULTIPLY:
+		blend_callback = blend_multiply;
+		break;
+
+	case IMA_LAYER_SCREEN:
+		blend_callback = blend_screen;
+		break;
+
+	case IMA_LAYER_OVERLAY:
+		blend_callback = blend_overlay;
+		break;
+
+	case IMA_LAYER_SOFT_LIGHT:
+		blend_callback = blend_soft_light;
+		break;
+
+	case IMA_LAYER_HARD_LIGHT:
+		blend_callback = blend_hard_light;
+		break;
+
+	case IMA_LAYER_COLOR_DODGE:
+		blend_callback = blend_color_dodge;
+		break;
+
+	case IMA_LAYER_LINEAR_DODGE:
+		blend_callback = blend_linear_dodge;
+		break;
+		
+	case IMA_LAYER_COLOR_BURN:
+		blend_callback = blend_color_burn;
+		break;
+
+	case IMA_LAYER_LINEAR_BURN:
+		blend_callback = blend_linear_burn;
+		break;
+
+	case IMA_LAYER_AVERAGE: 
+		blend_callback = blend_average;
+		break;       
+
+	case IMA_LAYER_ADD: 
+		blend_callback = blend_add;
+		break;
+
+	case IMA_LAYER_SUBTRACT: 
+		blend_callback = blend_subtract;
+		break;       
+
+	case IMA_LAYER_DIFFERENCE: 
+		blend_callback = blend_difference;
+		break;
+	
+	case IMA_LAYER_LIGHTEN: 
+		blend_callback = blend_lighten;
+		break;       
+
+	case IMA_LAYER_DARKEN: 
+		blend_callback = blend_darken;
+		break;
+	
+	case IMA_LAYER_NEGATION: 
+		blend_callback = blend_negation;
+		break;       
+
+	case IMA_LAYER_EXCLUSION: 
+		blend_callback = blend_exclusion;
+		break;
+	
+	case IMA_LAYER_LINEAR_LIGHT: 
+		blend_callback = blend_linear_light;
+		break;       
+
+	case IMA_LAYER_VIVID_LIGHT: 
+		blend_callback = blend_vivid_light;
+		break;
+	
+	case IMA_LAYER_PIN_LIGHT: 
+		blend_callback = blend_pin_light;
+		break;       
+
+	case IMA_LAYER_HARD_MIX: 
+		blend_callback = blend_hard_mix;
+		break;
+	}
+
+	if (base->rect_float) {
+		
+		float *fp_b = (float *) base->rect_float;
+		float *fp_l = (float *) layer->rect_float;
+		float *fp_d = (float *) dest->rect_float;
+		for( i = base->x * base->y; i > 0; i--, fp_b+=4, fp_l+=4, fp_d+=4 ) {
+			if (fp_l[3] != 0.0f) {
+				fp_d[0] = ((float)blend_callback(FTOCHAR(fp_b[0]), FTOCHAR(fp_l[0]), opacity)) / 255.0f;
+				fp_d[1] = ((float)blend_callback(FTOCHAR(fp_b[1]), FTOCHAR(fp_l[1]), opacity)) / 255.0f;
+				fp_d[2] = ((float)blend_callback(FTOCHAR(fp_b[2]), FTOCHAR(fp_l[2]), opacity)) / 255.0f;
+			}
+		}
+
+		if(base->rect) {
+			IMB_rect_from_float(base);
+		}
+	}
+	else if(base->rect) {
+		
+		char *cp_b = (char *) base->rect;
+		char *cp_l = (char *) layer->rect;
+		char *cp_d = (char *) dest->rect;
+		for( i = base->x * base->y; i > 0; i--, cp_b+=4, cp_l+=4, cp_d+=4 ) {
+			if (cp_l[3] != 0) {
+				cp_d[0] = blend_callback(cp_b[0], cp_l[0], opacity);
+				cp_d[1] = blend_callback(cp_b[1], cp_l[1], opacity);
+				cp_d[2] = blend_callback(cp_b[2], cp_l[2], opacity);
+				//cp_d[3] = blend_difference(cp_b[3], cp_l[3], opacity);
+			}
+		}
+	}
+
+	return dest;
+}
+ 
+/* Works in most of the cases but since no unique name is nessecary, this is acceptable as a start. */
+void imalayer_unique_name(const ListBase *imlayers, ImageLayer *newlayer)
+{
+	char *new_name = 0;
+	int new_len = 0;
+	int suffix;
+	ImageLayer *i;
+	char *name = newlayer->name;
+ 
+	/* When list is empty, there's no need to check name */
+	if (!imlayers->first)
+		return;
+ 
+	/* Iterate over every list element and check */
+	for(i=imlayers->first; i; i=i->next) {
+ 
+		/* If names differ, go to next element */
+		if(strcmp(name, i->name))
+			continue;
+ 
+		if(!new_name) {
+				int len = strlen(name);
+ 
+				if(len >= 4 && sscanf(name + len - 4, ".%03d", &suffix) == 1) {
+					new_len = len;
+				}
+				else {
+					suffix = 0;
+					new_len = len + 4;
+					if(new_len > 31)
+						new_len = 31;
+				}
+ 
+				new_name = MEM_mallocN(new_len + 1, "new_name");
+				strcpy(new_name, name);
+				name = new_name;
+		}
+		sprintf(new_name + new_len - 4, ".%03d", ++suffix);
+	}
+ 
+	if(new_name) {
+		strcpy(newlayer->name, new_name);
+		MEM_freeN(new_name);
+	}
+}
+ 
+ImageLayer *image_add_image_layer(Image *ima, const char *name, int depth, float color[4])
+{
+	ImageLayer *layer, *im_l = NULL;
+	ImBuf *ibuf, *imaibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return NULL;
+ 	
+	
+	/* Deselect other layers */
+	for(layer = ima->imlayers.first; layer; layer=layer->next)
+		layer->select = !IMA_LAYER_CURRENT;
+
+	im_l = layer_alloc(ima, name);
+
+	if (im_l) {
+		ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 
+		imaibuf = (ImBuf*)ima->ibufs.first;
+		ibuf = add_ibuf_size(imaibuf->x, imaibuf->y, im_l->name, depth, ima->gen_flag, 0, color);
+		BLI_addtail(&im_l->ibufs, ibuf);
+		BLI_addtail(&ima->imlayers, im_l);
+		ima->Act_Layers = BLI_countlist(&ima->imlayers)-1;
+		ima->Count_Layers += 1;
+
+		if (color[3] == 1.0f)
+			im_l->background = IMA_LAYER_BG_RGB;
+
+		BKE_image_release_ibuf(ima, lock);
+	}
+ 
+	return im_l;
+}
+ 
+/* TODO: (kwk) Base image layer needs proper locking... */
+void image_add_image_layer_base(Image *ima)
+{
+	ImageLayer *im_l = NULL;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima) {
+		im_l = layer_alloc(ima, "BaseLayer");
+		if (im_l) {	
+			//ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 			im_l->type = IMA_LAYER_BASE; /* BASE causes no free on deletion of layer */
+			ima->Act_Layers = 0;
+			ima->Count_Layers = 1;
+			/* Get ImBuf from ima */
+			ibuf = IMB_dupImBuf((ImBuf*)ima->ibufs.first);
+			BLI_addtail(&im_l->ibufs, ibuf);
+			BLI_addtail(&ima->imlayers, im_l);
+ 
+			//BKE_image_release_ibuf(ima, lock);
+		}
+	}
+}
+
+/* TODO: (kwk) This function must also calculate  */
Index: source/blender/editors/interface/interface_templates.c
===================================================================
--- source/blender/editors/interface/interface_templates.c	(revisione 44608)
+++ source/blender/editors/interface/interface_templates.c	(copia locale)
@@ -2139,6 +2139,11 @@
 		uiBlockSetEmboss(block, UI_EMBOSS);
 		uiDefButR(block, OPTION, 0, "", 0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "use", 0, 0, 0, 0, 0,  NULL);
 	}
+	else if(RNA_struct_is_a(itemptr->type, &RNA_ImageLayer)) {
+		uiItemL(sub, name, icon);
+		uiBlockSetEmboss(block, UI_EMBOSS);
+		uiDefButR(block, OPTION, 0, "", 0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "visible", 0, 0, 0, 0, 0,  NULL);
+	}
 	else if(RNA_struct_is_a(itemptr->type, &RNA_MaterialSlot)) {
 		/* provision to draw active node name */
 		Material *ma, *manode;
Index: source/blender/editors/space_image/image_draw.c
===================================================================
--- source/blender/editors/space_image/image_draw.c	(revisione 44608)
+++ source/blender/editors/space_image/image_draw.c	(copia locale)
@@ -54,6 +54,7 @@
 #include "BKE_context.h"
 #include "BKE_global.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_paint.h"
 
 #include "BIF_gl.h"
@@ -490,6 +491,53 @@
 	MEM_freeN(rectf);
 }
 
+static void draw_layer_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
+{
+	int x, y;
+	int color_manage = scene->r.color_mgt_flag & R_COLOR_MANAGEMENT;
+
+	/* set zoom */
+	glPixelZoom(zoomx, zoomy);
+
+	/* find window pixel coordinates of origin */
+	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
+	
+	/* this part is generic image display */
+	if(sima->flag & SI_SHOW_ALPHA) {
+		if(ibuf->rect)
+			sima_draw_alpha_pixels(x, y, ibuf->x, ibuf->y, ibuf->rect);
+		else if(ibuf->rect_float && ibuf->channels==4)
+			sima_draw_alpha_pixelsf(x, y, ibuf->x, ibuf->y, ibuf->rect_float);
+	}
+	else if(sima->flag & SI_SHOW_ZBUF && (ibuf->zbuf || ibuf->zbuf_float || (ibuf->channels==1))) {
+		if(ibuf->zbuf)
+			sima_draw_zbuf_pixels(x, y, ibuf->x, ibuf->y, ibuf->zbuf);
+		else if(ibuf->zbuf_float)
+			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->zbuf_float);
+		else if(ibuf->channels==1)
+			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->rect_float);
+	}
+	else {
+		
+		/* we don't draw floats buffers directly but
+		 * convert them, and optionally apply curves */
+		image_verify_buffer_float(ima, ibuf, color_manage);
+		
+		if(ibuf->rect)
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
+			glaDrawPixelsTexScaled(x, y, ibuf->x, ibuf->y, GL_RGBA, ibuf->rect, 1.0f, 1.0f);
+		//else
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_FLOAT, ibuf->rect_float);
+		
+		if(sima->flag & SI_USE_ALPHA)
+			glDisable(GL_BLEND);
+	}
+	
+	/* reset zoom */
+	glPixelZoom(1.0f, 1.0f);
+}
+
+
 static void draw_image_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
 {
 	int x, y;
@@ -500,7 +548,7 @@
 
 	/* find window pixel coordinates of origin */
 	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
-
+	
 	/* this part is generic image display */
 	if(sima->flag & SI_SHOW_ALPHA) {
 		if(ibuf->rect)
@@ -517,27 +565,27 @@
 			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->rect_float);
 	}
 	else {
-		if(sima->flag & SI_USE_ALPHA) {
+		if (sima->flag & SI_USE_ALPHA) {
 			unsigned char col1[3]= {100, 100, 100}, col2[3]= {160, 160, 160};
 			sima_draw_alpha_backdrop(x, y, ibuf->x, ibuf->y, zoomx, zoomy, col1, col2);
 
 			glEnable(GL_BLEND);
 			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 		}
-
+		
 		/* we don't draw floats buffers directly but
 		 * convert them, and optionally apply curves */
 		image_verify_buffer_float(ima, ibuf, color_manage);
-
+		
 		if(ibuf->rect)
 			glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
-		/*else
-			glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_FLOAT, ibuf->rect_float);*/
+		//else
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_FLOAT, ibuf->rect_float);
 		
 		if(sima->flag & SI_USE_ALPHA)
 			glDisable(GL_BLEND);
 	}
-
+	
 	/* reset zoom */
 	glPixelZoom(1.0f, 1.0f);
 }
@@ -759,10 +807,14 @@
 void draw_image_main(SpaceImage *sima, ARegion *ar, Scene *scene)
 {
 	Image *ima;
+	ImageLayer *layer;
 	ImBuf *ibuf;
+	ImBuf *prev_ibuf, *result_ibuf;
 	float zoomx, zoomy;
 	int show_viewer, show_render;
+	int first = 0;
 	void *lock;
+	char background=0;
 
 	/* XXX can we do this in refresh? */
 #if 0
@@ -791,7 +843,7 @@
 
 	show_viewer= (ima && ima->source == IMA_SRC_VIEWER);
 	show_render= (show_viewer && ima->type == IMA_TYPE_R_RESULT);
-
+	
 	/* draw the image or grid */
 	if(ibuf==NULL)
 		draw_image_grid(ar, zoomx, zoomy);
@@ -799,8 +851,89 @@
 		draw_image_buffer_repeated(sima, ar, scene, ima, ibuf, zoomx, zoomy);
 	else if(ima && (ima->tpageflag & IMA_TILES))
 		draw_image_buffer_tiled(sima, ar, scene, ima, ibuf, 0.0f, 0.0, zoomx, zoomy);
-	else
+	else if (ima && !show_render && (sima->flag & SI_DRAWTOOL))
+		//((ima->type & IMA_TYPE_R_RESULT) == 0) && 
+		//((ima->type & IMA_TYPE_COMPOSITE) == 0) && (sima->flag & SI_DRAWTOOL))
+	{
+		prev_ibuf = NULL;
+		ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+		layer=ima->imlayers.first;
+		
+		if (layer->background & IMA_LAYER_BG_ALPHA) //Alpha
+			background = 1;
+
+		for(layer=ima->imlayers.first; layer; layer=layer->next) {
+			if (!first) {
+				if ((layer->opacity!=1.0f) || (ibuf->channels==4) || (background==1)) {
+					int x, y;
+					unsigned char col1[3]= {100, 100, 100}, col2[3]= {160, 160, 160};
+					glEnable(GL_BLEND);
+					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+					UI_view2d_to_region_no_clip(&ar->v2d, 0.0f, 0.0f, &x, &y);
+					sima_draw_alpha_backdrop(x, y, ibuf->x, ibuf->y, zoomx, zoomy, col1, col2);
+					glDisable(GL_BLEND);
+					first = 1;
+				}
+			}
+			//glEnable(GL_BLEND);
+			if (layer->visible & IMA_LAYER_VISIBLE) {
+				ibuf= (ImBuf*)((ImageLayer*)layer->ibufs.first);
+				if (ibuf) {
+					if (prev_ibuf) {
+						result_ibuf = imalayer_blend(prev_ibuf, ibuf, layer->opacity, layer->mode);
+						IMB_freeImBuf(prev_ibuf);
+						prev_ibuf = IMB_dupImBuf(result_ibuf);
+					}
+					else {
+						prev_ibuf = IMB_dupImBuf(ibuf);
+						result_ibuf = prev_ibuf;
+					}
+					glEnable(GL_BLEND);
+					//glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					
+					//if ((layer=ima->imlayers.first)->flag & IMA_LAYER_BASE) {
+						//glEnable(GL_BLEND);
+						if (background == 0) {
+							//RGB
+							glBlendFunc(GL_SRC_COLOR, GL_ONE_MINUS_SRC_ALPHA);
+						}
+						else {
+							//Alpha
+							glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+						}
+					//}
+					glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					draw_layer_buffer(sima, ar, scene, ima, result_ibuf, 0.0f, 0.0f, zoomx, zoomy);
+					
+					glDisable(GL_BLEND);
+					/*if (layer->flag & IMA_LAYER_BASE)
+						glDisable(GL_BLEND);*/
+					if (!(layer->type & IMA_LAYER_BASE))
+						IMB_freeImBuf(result_ibuf);
+				}
+			}
+		}
+		glDisable(GL_BLEND);
+		/*glEnable(GL_DEPTH_TEST);*/
+		IMB_freeImBuf(prev_ibuf);
+		BKE_image_release_ibuf(ima, lock);		
+	}
+	else {
+		layer=ima->imlayers.first;
+		if (layer->background & IMA_LAYER_BG_ALPHA) {
+			int x, y;
+			unsigned char col1[3]= {100, 100, 100}, col2[3]= {160, 160, 160};
+			glEnable(GL_BLEND);
+			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+			UI_view2d_to_region_no_clip(&ar->v2d, 0.0f, 0.0f, &x, &y);
+			sima_draw_alpha_backdrop(x, y, ibuf->x, ibuf->y, zoomx, zoomy, col1, col2);
+		}
+
 		draw_image_buffer(sima, ar, scene, ima, ibuf, 0.0f, 0.0f, zoomx, zoomy);
+		
+		if (layer->background & IMA_LAYER_BG_ALPHA)
+			glDisable(GL_BLEND);
+	}
 
 	/* paint helpers */
 	if(sima->flag & SI_DRAWTOOL)
Index: source/blender/editors/space_image/image_intern.h
===================================================================
--- source/blender/editors/space_image/image_intern.h	(revisione 44608)
+++ source/blender/editors/space_image/image_intern.h	(copia locale)
@@ -93,5 +93,11 @@
 void IMAGE_OT_properties(struct wmOperatorType *ot);
 void IMAGE_OT_scopes(struct wmOperatorType *ot);
 
+/* image layers */
+void IMAGE_OT_image_layer_move(struct wmOperatorType *ot);
+//void IMAGE_OT_image_layer_fill_color(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_remove(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_duplicate(struct wmOperatorType *ot);
+
 #endif /* __IMAGE_INTERN_H__ */
-
Index: source/blender/editors/space_image/image_ops.c
===================================================================
--- source/blender/editors/space_image/image_ops.c	(revisione 44608)
+++ source/blender/editors/space_image/image_ops.c	(copia locale)
@@ -47,6 +47,7 @@
 #include "BKE_colortools.h"
 #include "BKE_context.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_global.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
@@ -1501,6 +1502,7 @@
 	char name[MAX_ID_NAME-2];
 	float color[4];
 	int width, height, floatbuf, uvtestgrid, alpha;
+	short background;
 
 	/* retrieve state */
 	sima= CTX_wm_space_image(C);
@@ -1508,13 +1510,27 @@
 	obedit= CTX_data_edit_object(C);
 
 	RNA_string_get(op->ptr, "name", name);
-	width= RNA_int_get(op->ptr, "width");
-	height= RNA_int_get(op->ptr, "height");
-	floatbuf= RNA_boolean_get(op->ptr, "float");
-	uvtestgrid= RNA_boolean_get(op->ptr, "uv_test_grid");
+	width = RNA_int_get(op->ptr, "width");
+	height = RNA_int_get(op->ptr, "height");
+	floatbuf = RNA_boolean_get(op->ptr, "float");
+	uvtestgrid = RNA_boolean_get(op->ptr, "uv_test_grid");
 	RNA_float_get_array(op->ptr, "color", color);
-	alpha= RNA_boolean_get(op->ptr, "alpha");
-	
+	alpha = RNA_boolean_get(op->ptr, "alpha");
+	background = RNA_enum_get(op->ptr, "background");
+
+	if (background & IMA_LAYER_BG_WHITE) {
+		color[0] = 1.0f;
+		color[1] = 1.0f;
+		color[2] = 1.0f;
+		color[3] = 1.0f;
+	}
+	else if (background & IMA_LAYER_BG_ALPHA) {
+		color[0] = 0.0f;
+		color[1] = 0.0f;
+		color[2] = 0.0f;
+		color[3] = 0.0f;
+	}
+
 	if (!floatbuf && scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
 		linearrgb_to_srgb_v3_v3(color, color);
 
@@ -1522,6 +1538,7 @@
 		color[3]= 1.0f;
 
 	ima = BKE_add_image_size(width, height, name, alpha ? 32 : 24, floatbuf, uvtestgrid, color);
+	((ImageLayer *)ima->imlayers.first)->background = background;
 
 	if(!ima)
 		return OPERATOR_CANCELLED;
@@ -1554,10 +1571,51 @@
 
 }
 
+/*static int image_new_draw_check_prop(PointerRNA *ptr, PropertyRNA *prop)
+{
+	const char *prop_id= RNA_property_identifier(prop);
+
+	return !(strcmp(prop_id, "filepath") == 0 ||
+	         strcmp(prop_id, "directory") == 0 ||
+	         strcmp(prop_id, "filename") == 0 ||
+	         ((strcmp(prop_id, "relative_path") == 0) && RNA_boolean_get(ptr, "copy"))
+	         );
+}*/
+
+/*static void image_new_draw(bContext *C, wmOperator *op)
+{
+	uiLayout *layout = op->layout;
+	wmWindowManager *wm= CTX_wm_manager(C);
+	PointerRNA ptr;
+	PropertyRNA *prop;
+	PropertyRNA *prop_color;
+	
+	short background = RNA_enum_get(op->ptr, "background");
+	if (!(background & IMA_LAYER_BG_RGB)) {
+		prop_color = RNA_struct_find_property(op->ptr, "color");
+		RNA_def_property_flag(prop_color, PROP_HIDDEN);
+	}
+
+
+	RNA_pointer_create(&wm->id, op->type->srna, op->properties, &ptr);
+
+
+	uiDefAutoButsRNA(layout, &ptr, image_new_draw_check_prop, '\0');
+}*/
+
 void IMAGE_OT_new(wmOperatorType *ot)
 {
 	PropertyRNA *prop;
+	short background;
+	
 	static float default_color[4]= {0.0f, 0.0f, 0.0f, 1.0f};
+
+	static EnumPropertyItem prop_background_items[] = {
+		{IMA_LAYER_BG_RGB, "RGB", 0, "RGB", ""},
+		{IMA_LAYER_BG_WHITE, "WHITE", 0, "White", ""},
+		{IMA_LAYER_BG_ALPHA, "ALPHA", 0, "Transparent", ""},
+		{0, NULL, 0, NULL, NULL}};
+
 	
 	/* identifiers */
 	ot->name= "New Image";
@@ -1567,7 +1625,8 @@
 	/* api callbacks */
 	ot->exec= image_new_exec;
 	ot->invoke= image_new_invoke;
-	
+	//ot->ui = image_new_draw;
+		
 	/* flags */
 	ot->flag= OPTYPE_UNDO;
 
@@ -1575,11 +1634,14 @@
 	RNA_def_string(ot->srna, "name", "untitled", MAX_ID_NAME-2, "Name", "Image datablock name");
 	RNA_def_int(ot->srna, "width", 1024, 1, INT_MAX, "Width", "Image width", 1, 16384);
 	RNA_def_int(ot->srna, "height", 1024, 1, INT_MAX, "Height", "Image height", 1, 16384);
+	RNA_def_enum(ot->srna, "background", prop_background_items, 0, "Background", "");
+
 	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Color", "Default fill color", 0.0f, 1.0f);
 	RNA_def_property_float_array_default(prop, default_color);
 	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel");
+	RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth");
 	RNA_def_boolean(ot->srna, "uv_test_grid", 0, "UV Test Grid", "Fill the image with a grid for UV map testing");
-	RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth");
+	
 }
 
 /********************* invert operators *********************/
@@ -1667,6 +1729,212 @@
 	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
 }
 
+/********************** new image layer operators *********************/
+
+int image_layer_poll(bContext *C)
+{
+	return NULL != CTX_data_edit_image(C);
+}
+ 
+static int image_layer_add_exec(bContext *C, wmOperator *op)
+{	
+	char name[22];
+	float color[4];
+	int alpha;
+	Scene *scene;
+	Image *im = CTX_data_edit_image(C);
+	ImageLayer *iml;
+	
+	scene= (Scene*)CTX_data_scene(C);
+
+	RNA_string_get(op->ptr, "name", name);
+	RNA_float_get_array(op->ptr, "color", color);
+	alpha= RNA_boolean_get(op->ptr, "alpha");
+
+	if (scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
+		linearrgb_to_srgb_v3_v3(color, color);
+
+	if(!alpha) 
+		color[3] = 1.0f;
+	
+	iml = image_add_image_layer(im, name, alpha ? 32 : 24, color);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	/* hook into UI */
+	//Delete
+	//uiIDContextProperty(C, &ptr, &prop);
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, im);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_add(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "Add Image Layer";
+	ot->idname= "IMAGE_OT_image_layer_add";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_add_exec;
+	//ot->poll = image_layer_poll;
+	ot->invoke= image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "ImageLayer", 21, "Name", "Image datablock name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+static int image_layer_duplicate_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *iml;
+
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	iml = image_duplicate_current_image_layer(ima);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_duplicate(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name= "Duplicate Image Layer";
+	ot->idname= "IMAGE_OT_image_layer_duplicate";
+	ot->description="Duplicate the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_duplicate_exec;
+	//ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
+
+
+static int image_layer_remove_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	image_remove_current_image_layer(ima);
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_remove(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name= "Remove Image Layer";
+	ot->idname= "IMAGE_OT_image_layer_remove";
+	ot->description="Remove the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_remove_exec;
+	//ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
+ 
+ 
+static int image_layer_move_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer, *tmp;
+	int type, layerID;
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	layer= imalayer_get_current(ima);
+ 
+	if (!layer)
+		return OPERATOR_CANCELLED;
+ 
+	type= RNA_enum_get(op->ptr, "type");
+	layerID= imalayer_get_current_act(ima);
+ 
+	if (type == -1) 
+	{ /* Move direction: Up */
+		if (layerID > 0)
+		{
+			tmp= layer->prev;
+			BLI_remlink(&ima->imlayers, layer);
+			layer->next = layer->prev = NULL;
+			if (tmp) {
+				BLI_insertlinkbefore(&ima->imlayers, tmp, layer);
+			}
+			else {
+				BLI_addhead(&ima->imlayers, layer);
+			}
+			imalayer_set_current_act(ima, layerID-1);
+		}
+	}
+	else 
+	{ /* Move direction: Down */
+		if (layerID < (BLI_countlist(&ima->imlayers)-1))
+		{
+			tmp= layer->next;
+			BLI_remlink(&ima->imlayers, layer);
+			layer->next = layer->prev = NULL;
+			if (tmp) {
+				BLI_insertlinkafter(&ima->imlayers, tmp, layer);
+			}
+			else {
+				BLI_addtail(&ima->imlayers, layer);
+			}	
+			imalayer_set_current_act(ima, layerID+1);
+		}
+	}
+ 
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_move(wmOperatorType *ot)
+{
+	static EnumPropertyItem slot_move[] = {
+		{-1, "UP", 0, "Up", ""},
+		{1, "DOWN", 0, "Down", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Move Imahe Layer";
+	ot->idname= "IMAGE_OT_image_layer_move";
+	ot->description="Move image layers up and down";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_move_exec;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "type", slot_move, 0, "Type", "");
+}
+
 /********************* pack operator *********************/
 
 static int image_pack_test(bContext *C, wmOperator *op)
Index: source/blender/editors/space_image/space_image.c
===================================================================
--- source/blender/editors/space_image/space_image.c	(revisione 44608)
+++ source/blender/editors/space_image/space_image.c	(copia locale)
@@ -491,6 +491,12 @@
 
 	WM_operatortype_append(IMAGE_OT_properties);
 	WM_operatortype_append(IMAGE_OT_scopes);
+
+	WM_operatortype_append(IMAGE_OT_image_layer_move);
+	//WM_operatortype_append(IMAGE_OT_image_layer_fill_color);
+	WM_operatortype_append(IMAGE_OT_image_layer_remove);
+	WM_operatortype_append(IMAGE_OT_image_layer_add);
+	WM_operatortype_append(IMAGE_OT_image_layer_duplicate);
 }
 
 static void image_keymap(struct wmKeyConfig *keyconf)
Index: source/blender/makesdna/DNA_image_types.h
===================================================================
--- source/blender/makesdna/DNA_image_types.h	(revisione 44608)
+++ source/blender/makesdna/DNA_image_types.h	(copia locale)
@@ -34,6 +34,10 @@
 
 #include "DNA_ID.h"
 
+#ifndef MAX_LIMA
+#define MAX_LIMA	18
+#endif
+
 struct PackedFile;
 struct Scene;
 struct anim;
@@ -66,6 +70,186 @@
 #define IMA_ANIM_REFRESHED	2
 /* #define IMA_DO_PREMUL	4 */
 
+
+typedef struct ImageLayer {
+	struct ImageLayer *next, *prev;
+
+	char name[240];
+	short background;
+	short color_space;
+	float opacity;
+	short mode;
+	short type;
+	short visible;
+	short select;
+	ListBase ibufs;
+}ImageLayer;
+
+/* **************** IMAGE LAYER********************* */
+#define IMA_LAYER_MAX_LEN	240
+
+/* ImageLayer.background */
+#define IMA_LAYER_BG_RGB		(1<<0)
+#define IMA_LAYER_BG_WHITE		(1<<1)
+#define IMA_LAYER_BG_ALPHA		(1<<2)
+
+/* ImageLayer.color_space */
+#define IMA_LAYER_COL_RGB		(1<<0)
+#define IMA_LAYER_COL_GRAY		(1<<1)
+
+/* ImageLayer.mode */
+#define IMA_LAYER_NORMAL 		0
+
+#define IMA_LAYER_MULTIPLY		1
+#define IMA_LAYER_SCREEN		2
+#define IMA_LAYER_OVERLAY		3
+#define IMA_LAYER_SOFT_LIGHT	4
+#define IMA_LAYER_HARD_LIGHT	5
+
+#define IMA_LAYER_COLOR_DODGE	6
+#define IMA_LAYER_LINEAR_DODGE	7
+#define IMA_LAYER_COLOR_BURN	8
+#define IMA_LAYER_LINEAR_BURN	9
+
+#define IMA_LAYER_AVERAGE		10
+#define IMA_LAYER_ADD			11
+#define IMA_LAYER_SUBTRACT		12
+#define IMA_LAYER_DIFFERENCE	13
+#define IMA_LAYER_LIGHTEN		14
+#define IMA_LAYER_DARKEN		15
+
+#define IMA_LAYER_NEGATION		16
+#define IMA_LAYER_EXCLUSION	17
+
+#define IMA_LAYER_LINEAR_LIGHT	18
+#define IMA_LAYER_VIVID_LIGHT	19
+#define IMA_LAYER_PIN_LIGHT	20
+#define IMA_LAYER_HARD_MIX		21
+
+/*#define ChannelBlend_Reflect(A,B)    ((uint8)((B == 255) ? B:min(255, (A * A / (255 - B)))))
+#define ChannelBlend_Glow(A,B)       (ChannelBlend_Reflect(B,A))
+#define ChannelBlend_Phoenix(A,B)    ((uint8)(min(A,B) - max(A,B) + 255))
+#define ChannelBlend_Alpha(A,B,O)    ((uint8)(O * A + (1 - O) * B))
+#define ChannelBlend_AlphaF(A,B,F,O) (ChannelBlend_Alpha(F(A,B),A,O))
+
+#define ColorBlend_Hue(T,A,B)            ColorBlend_Hls(T,A,B,HueB,LuminationA,SaturationA)
+#define ColorBlend_Saturation(T,A,B)     ColorBlend_Hls(T,A,B,HueA,LuminationA,SaturationB)
+#define ColorBlend_Color(T,A,B)          ColorBlend_Hls(T,A,B,HueB,LuminationA,SaturationB)
+#define ColorBlend_Luminosity(T,A,B)     ColorBlend_Hls(T,A,B,HueA,LuminationB,SaturationA)
+
+#define ColorBlend_Hls(T,A,B,O1,O2,O3) {
+    float64 HueA, LuminationA, SaturationA;
+    float64 HueB, LuminationB, SaturationL;
+    Color_RgbToHls((A)[2],(A)[1],(A)[0], &HueA, &LuminationA, &SaturationA);
+    Color_RgbToHls((B)[2],(B)[1],(B)[0], &HueB, &LuminationB, &SaturationB);
+    Color_HlsToRgb(O1,O2,O3,&(T)[2],&(T)[1],&(T)[0]);
+    }
+
+int32 Color_HueToRgb(float64 M1, float64 M2, float64 Hue, float64 *Channel)
+{
+    if (Hue < 0.0)
+        Hue += 1.0;
+    else if (Hue > 1.0)
+        Hue -= 1.0;
+
+    if ((6.0 * Hue) < 1.0)
+        *Channel = (M1 + (M2 - M1) * Hue * 6.0);
+    else if ((2.0 * Hue) < 1.0)
+        *Channel = (M2);
+    else if ((3.0 * Hue) < 2.0)
+        *Channel = (M1 + (M2 - M1) * ((2.0F / 3.0F) - Hue) * 6.0);
+    else
+        *Channel = (M1);
+
+    return TRUE;
+}
+
+int32 Color_RgbToHls(uint8 Red, uint8 Green, uint8 Blue, float64 *Hue, float64 *Lumination, float64 *Saturation)
+{
+    float64 Delta;
+    float64 Max, Min;
+    float64 Redf, Greenf, Bluef;
+
+    Redf    = ((float64)Red   / 255.0F);
+    Greenf  = ((float64)Green / 255.0F);
+    Bluef   = ((float64)Blue  / 255.0F); 
+
+    Max     = max(max(Redf, Greenf), Bluef);
+    Min     = min(min(Redf, Greenf), Bluef);
+
+    *Hue        = 0;
+    *Lumination = (Max + Min) / 2.0F;
+    *Saturation = 0;
+
+    if (Max == Min)
+        return TRUE;
+
+    Delta = (Max - Min);
+
+    if (*Lumination < 0.5)
+        *Saturation = Delta / (Max + Min);
+    else
+        *Saturation = Delta / (2.0 - Max - Min);
+
+    if (Redf == Max)
+        *Hue = (Greenf - Bluef) / Delta;
+    else if (Greenf == Max)
+        *Hue = 2.0 + (Bluef - Redf) / Delta;
+    else
+        *Hue = 4.0 + (Redf - Greenf) / Delta;
+
+    *Hue /= 6.0; 
+
+    if (*Hue < 0.0)
+        *Hue += 1.0;       
+
+    return TRUE;
+}
+
+int32 Color_HlsToRgb(float64 Hue, float64 Lumination, float64 Saturation, uint8 *Red, uint8 *Green, uint8 *Blue)
+{
+    float64 M1, M2;
+    float64 Redf, Greenf, Bluef;
+
+    if (Saturation == 0)
+        {
+        Redf    = Lumination;
+        Greenf  = Lumination;
+        Bluef   = Lumination;
+        }
+    else
+        {
+        if (Lumination <= 0.5)
+            M2 = Lumination * (1.0 + Saturation);
+        else
+            M2 = Lumination + Saturation - Lumination * Saturation;
+
+        M1 = (2.0 * Lumination - M2);
+
+        Color_HueToRgb(M1, M2, Hue + (1.0F / 3.0F), &Redf);
+        Color_HueToRgb(M1, M2, Hue, &Greenf);
+        Color_HueToRgb(M1, M2, Hue - (1.0F / 3.0F), &Bluef);
+        }
+
+    *Red    = (uint8)(Redf * 255);
+    *Blue   = (uint8)(Bluef * 255);
+    *Green  = (uint8)(Greenf * 255);
+
+    return TRUE;
+}
+
+*/
+
+/* ImageLayer.type */
+#define IMA_LAYER_BASE		(1<<0)
+#define IMA_LAYER_LAYER		(1<<1)
+
+/* ImageLayer.visible */
+#define IMA_LAYER_VISIBLE	(1<<0)
+
+/* ImageLayer.select */
+#define IMA_LAYER_CURRENT	(1<<0)
+
 typedef struct Image {
 	ID id;
 	
@@ -106,6 +290,9 @@
 	
 	/* display aspect - for UV editing images resized for faster openGL display */
 	float aspx, aspy;
+	int Act_Layers;
+	int Count_Layers;
+	ListBase imlayers;
 } Image;
 
 
Index: source/blender/makesrna/intern/rna_image.c
===================================================================
--- source/blender/makesrna/intern/rna_image.c	(revisione 44608)
+++ source/blender/makesrna/intern/rna_image.c	(copia locale)
@@ -38,6 +38,7 @@
 #include "BKE_context.h"
 #include "BKE_depsgraph.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 
 #include "WM_types.h"
 #include "WM_api.h"
@@ -285,6 +286,59 @@
 	return planes;
 }
 
+static PointerRNA rna_Image_active_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= imalayer_get_current(ima);
+ 
+	return rna_pointer_inherit_refine(ptr, &RNA_ImageLayer, layer);
+}
+
+static void rna_Image_active_image_layer_set(PointerRNA *ptr, PointerRNA value)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= (ImageLayer*)value.data;
+	const int index= BLI_findindex(&ima->imlayers, layer);
+	if (index != -1) ima->Act_Layers= index;
+}
+
+static void rna_Image_layers_begin(CollectionPropertyIterator *iter, PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	rna_iterator_listbase_begin(iter, &ima->imlayers, NULL);
+}
+
+static int rna_Image_count_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_count(ima);
+}
+
+static int rna_Image_active_image_layer_index_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_current_act(ima);
+}
+ 
+static void rna_Image_active_image_layer_index_set(PointerRNA *ptr, int value)
+{
+	Image *ima= (Image*)ptr->data;
+	imalayer_set_current_act(ima, value);
+}
+ 
+static void rna_Image_active_image_layer_index_range(PointerRNA *ptr, int *min, int *max)
+{
+	Image *im= (Image*)ptr->data;
+	void *lock;
+	ImBuf *ibuf= BKE_image_acquire_ibuf(im, NULL, &lock);
+
+	*min= 0;
+	*max= BLI_countlist(&im->imlayers)-1;
+	*max= MAX2(0, *max);
+
+	BKE_image_release_ibuf(im, lock);
+}
+
 static int rna_Image_pixels_get_length(PointerRNA *ptr, int length[RNA_MAX_ARRAY_DIMENSION])
 {
 	Image *ima= ptr->id.data;
@@ -410,6 +464,130 @@
 	RNA_def_property_ui_text(prop, "Pass", "Pass in multilayer image");
 }
 
+static void rna_def_image_layer_common(StructRNA *srna)
+{
+	PropertyRNA *prop;
+
+	static EnumPropertyItem prop_type_items[] = {
+		{IMA_LAYER_BASE, "BASE", 0, "Base", ""},
+		{IMA_LAYER_LAYER, "LAYER", 0, "Layer", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	static EnumPropertyItem prop_background_items[] = {
+		{IMA_LAYER_BG_RGB, "RGB", 0, "RGB", ""},
+		{IMA_LAYER_BG_WHITE, "WHITE", 0, "White", ""},
+		{IMA_LAYER_BG_ALPHA, "ALPHA", 0, "Transparent", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	static EnumPropertyItem prop_blend_type_items[] = {
+		{IMA_LAYER_NORMAL, "NORMAL", 0, "Normal", ""},
+		{IMA_LAYER_MULTIPLY, "MULTIPLY", 0, "Multiply", ""},
+		{IMA_LAYER_SCREEN, "SCREEN", 0, "Screen", ""},
+		{IMA_LAYER_OVERLAY, "OVERLAY", 0, "Overlay", ""},
+		{IMA_LAYER_SOFT_LIGHT, "SOFT_LIGHT", 0, "Soft Light", ""},
+		{IMA_LAYER_HARD_LIGHT, "HARD_LIGHT", 0, "Hard Light", ""},
+		{IMA_LAYER_COLOR_DODGE, "COLOR_DODGE", 0, "Color Dodge", ""},
+		{IMA_LAYER_LINEAR_DODGE, "LINEAR_DODGE", 0, "Linear Dodge", ""},
+		{IMA_LAYER_COLOR_BURN, "COLOR_BURN", 0, "Color Burn", ""},
+		{IMA_LAYER_LINEAR_BURN, "LINEAR_BURN", 0, "Linear Burn", ""},
+		{IMA_LAYER_AVERAGE, "AVERAGE", 0, "Average", ""},
+		{IMA_LAYER_ADD, "ADD", 0, "Add", ""},
+		{IMA_LAYER_SUBTRACT, "SUBTRACT", 0, "Subtract", ""},
+		{IMA_LAYER_DIFFERENCE, "DIFFERENCE", 0, "Difference", ""},
+		{IMA_LAYER_LIGHTEN, "LIGHTEN", 0, "Lighten", ""}, 
+		{IMA_LAYER_DARKEN, "DARKEN", 0, "Darken", ""}, 
+		{IMA_LAYER_NEGATION, "NEGATION", 0, "Negation", ""},
+		{IMA_LAYER_EXCLUSION, "EXCLUSION", 0, "Exclusion", ""},
+		{IMA_LAYER_LINEAR_LIGHT, "LINEAR_LIGHT", 0, "Linear Light", ""},
+		{IMA_LAYER_VIVID_LIGHT, "VIVID_LIGHT", 0, "Vivid Light", ""},
+		{IMA_LAYER_PIN_LIGHT, "PIN_LIGHT", 0, "Pin Light", ""}, 
+		{IMA_LAYER_HARD_MIX, "HARD_LIGHT", 0, "Hard Light", ""},
+		{0, NULL, 0, NULL, NULL}};
+	
+	prop= RNA_def_property(srna, "name", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_default(prop, "ImageLayer");
+	RNA_def_property_string_maxlength(prop, IMA_LAYER_MAX_LEN);
+	RNA_def_property_update(prop, NC_OBJECT|ND_MODIFIER|NA_RENAME, NULL);
+	RNA_def_property_ui_text(prop, "Name", "The name of the image layer.");
+	RNA_def_struct_name_property(srna, prop);
+
+ 	prop= RNA_def_property(srna, "visible", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_ui_text(prop, "", "Hides the layer in the UV/Image Editor");
+	RNA_def_property_boolean_sdna(prop, NULL, "visible", IMA_LAYER_VISIBLE);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "opacity", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "opacity");
+	RNA_def_property_range(prop, 0.0, 1.0);
+	RNA_def_property_ui_range(prop, 0, 1.0, 1, 3);
+	RNA_def_property_ui_text(prop, "Opacity", "The opacity of the image layer when blended.");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "blend_type", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "mode");
+	RNA_def_property_enum_items(prop, prop_blend_type_items);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "background", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "background");
+	RNA_def_property_enum_items(prop, prop_background_items);
+	RNA_def_property_ui_text(prop, "Type Background", "");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "type", PROP_ENUM, PROP_NONE);
+	//RNA_def_property_ui_text(prop, "", "Defines the type of layer");
+	//RNA_def_property_boolean_sdna(prop, NULL, "type", IMA_LAYER_BASE);
+	RNA_def_property_enum_sdna(prop, NULL, "type");
+	RNA_def_property_enum_items(prop, prop_type_items);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
+static void rna_def_image_layer(BlenderRNA *brna)
+{
+	StructRNA *srna;
+		
+	srna= RNA_def_struct(brna, "ImageLayer", NULL);
+	RNA_def_struct_ui_text(srna, "Image Layer", "Image layer");
+	RNA_def_struct_ui_icon(srna, ICON_TEXTURE_DATA);
+
+	rna_def_image_layer_common(srna);
+}
+
+static void rna_def_image_layers(BlenderRNA *brna, PropertyRNA *cprop)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	FunctionRNA *func;
+	PropertyRNA *parm;
+
+	RNA_def_property_srna(cprop, "ImageLayers");
+	srna= RNA_def_struct(brna, "ImageLayers", NULL);
+	RNA_def_struct_sdna(srna, "Image");
+	RNA_def_struct_ui_text(srna, "Image Layers", "Image layer");
+
+	prop= RNA_def_property(srna, "active_image_layer", PROP_POINTER, PROP_NONE);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_pointer_funcs(prop, "rna_Image_active_image_layer_get", 
+								   "rna_Image_active_image_layer_set", NULL, NULL);
+	RNA_def_property_flag(prop, PROP_EDITABLE|PROP_NEVER_NULL);
+	RNA_def_property_ui_text(prop, "Active Image Layer", "Active image layer");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+ 
+	prop= RNA_def_property(srna, "active_image_layer_index", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Act_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_active_image_layer_index_get", "rna_Image_active_image_layer_index_set", 
+							   "rna_Image_active_image_layer_index_range");
+	RNA_def_property_ui_text(prop, "Active Image Layer Index", "Index of active image layer slot");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "count_image_layers", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Count_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_count_image_layer_get", NULL, NULL);
+	RNA_def_property_ui_text(prop, "Total number of layers", "");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
 static void rna_def_image(BlenderRNA *brna)
 {
 	StructRNA *srna;
@@ -476,6 +654,14 @@
 	RNA_def_property_ui_text(prop, "Field Order", "Order of video fields (select which lines are displayed first)");
 	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
 	
+	/* Image Layers */
+ 	prop= RNA_def_property(srna, "image_layers", PROP_COLLECTION, PROP_NONE);
+	RNA_def_property_collection_sdna(prop, NULL, "imlayers", NULL);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_collection_funcs(prop, "rna_Image_layers_begin", "rna_iterator_listbase_next", "rna_iterator_listbase_end", "rna_iterator_listbase_get", 0, 0, 0, 0);
+	RNA_def_property_ui_text(prop, "Image Layers", "");
+	rna_def_image_layers(brna, prop);
+
 	/* booleans */
 	prop= RNA_def_property(srna, "use_fields", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "flag", IMA_FIELDS);
@@ -624,6 +810,7 @@
 
 void RNA_def_image(BlenderRNA *brna)
 {
+	rna_def_image_layer(brna);
 	rna_def_image(brna);
 	rna_def_imageuser(brna);
 }
Index: source/blender/makesrna/RNA_access.h
===================================================================
--- source/blender/makesrna/RNA_access.h	(revisione 44608)
+++ source/blender/makesrna/RNA_access.h	(copia locale)
@@ -257,6 +257,7 @@
 extern StructRNA RNA_ID;
 extern StructRNA RNA_IKParam;
 extern StructRNA RNA_Image;
+extern StructRNA RNA_ImageLayer;
 extern StructRNA RNA_ImageFormatSettings;
 extern StructRNA RNA_ImagePaint;
 extern StructRNA RNA_ImageSequence;
Index: release/scripts/startup/bl_ui/space_image.py
===================================================================
--- release/scripts/startup/bl_ui/space_image.py	(revisione 44897)
+++ release/scripts/startup/bl_ui/space_image.py	(copia locale)
@@ -160,6 +160,35 @@
             layout.separator()
 
 
+class IMAGE_MT_layers(Menu):
+    bl_label = "Layer"
+
+    def draw(self, context):
+        layout = self.layout
+
+        sima = context.space_data
+        ima = sima.image
+
+        layout.menu("IMAGE_MT_layers_new")
+        # layout.operator("image.open")
+        layout.operator("image.image_layer_duplicate")
+        layout.operator("image.image_layer_remove")
+
+        layout.separator()
+
+
+class IMAGE_MT_layers_new(Menu):
+    bl_label = "Add"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_add", icon='NEW')
+        layout.separator()
+        layout.operator("image.image_layer_add_above")
+        layout.operator("image.image_layer_add_below")
+
+
 class IMAGE_MT_image_invert(Menu):
     bl_label = "Invert"
 
@@ -355,7 +384,7 @@
         toolsettings = context.tool_settings
 
         show_render = sima.show_render
-        # show_paint = sima.show_paint
+        show_paint = sima.show_paint
         show_uvedit = sima.show_uvedit
 
         row = layout.row(align=True)
@@ -374,6 +403,9 @@
             else:
                 sub.menu("IMAGE_MT_image", text="Image")
 
+            if show_paint:
+                sub.menu("IMAGE_MT_layers", text="Layer")
+
             if show_uvedit:
                 sub.menu("IMAGE_MT_uvs")
 
@@ -647,6 +679,56 @@
             sub.row().prop(uvedit, "draw_stretch_type", expand=True)
 
 
+class IMAGE_PT_image_layers(Panel, ImagePaintPanel):
+    bl_label = "Image Layers"
+
+    @classmethod
+    def poll(cls, context):
+        sima = context.space_data
+        return sima.show_paint
+
+    def draw(self, context):
+        layout = self.layout
+        sima = context.space_data
+        ima = sima.image
+        layers = ima.image_layers
+
+        if ima:
+            row = layout.row()
+            row.template_list(ima, "image_layers", ima.image_layers, "active_image_layer_index", 
+                              rows=5, maxrows=5)
+
+            col = row.column(align=True)
+            col.operator("image.image_layer_add", text="", icon='NEW')
+            
+            if layers.active_image_layer:
+                col.operator("image.image_layer_duplicate", text="", icon='GHOST')
+                sub = col.column()
+                
+                if (layers.active_image_layer.type == 'BASE'):
+                    sub.enabled = False
+                else:
+                    sub.enabled = True
+                sub.operator("image.image_layer_remove", text="", icon='CANCEL')
+                col.operator("image.image_layer_move", text="", icon='TRIA_UP').type = 'UP'
+                col.operator("image.image_layer_move", text="", icon='TRIA_DOWN').type = 'DOWN'
+                split = layout.split(percentage=0.35)
+                col = split.column()
+                col.label(text="Name")
+                col.label(text="Opacity:")
+                col.label(text="Blend Modes:")
+                col = split.column()
+                col.prop(layers.active_image_layer, "name", text="")
+                sub = col.column()
+                if ((layers.active_image_layer.background != 'ALPHA') and 
+                    (layers.active_image_layer.type == 'BASE')):
+                    sub.enabled = False
+                else:
+                    sub.enabled = True
+                sub.prop(layers.active_image_layer, "opacity", text="")
+                sub.prop(layers.active_image_layer, "blend_type", text="")
+
+
 class IMAGE_PT_paint(Panel, ImagePaintPanel):
     bl_space_type = 'IMAGE_EDITOR'
     bl_region_type = 'UI'
Index: source/blender/blenkernel/BKE_image.h
===================================================================
--- source/blender/blenkernel/BKE_image.h	(revisione 44897)
+++ source/blender/blenkernel/BKE_image.h	(copia locale)
@@ -130,6 +130,7 @@
 
 /* returns existing Image when filename/type is same (frame optional) */
 struct Image *BKE_add_image_file(const char *name);
+struct ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4]);
 
 /* adds image, adds ibuf, generates color or pattern */
 struct Image *BKE_add_image_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4]);
Index: source/blender/blenkernel/BKE_layer.h
===================================================================
--- source/blender/blenkernel/BKE_layer.h	(revisione 0)
+++ source/blender/blenkernel/BKE_layer.h	(copia locale)
@@ -0,0 +1,93 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): ruesp83.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+ #ifndef __BKE_LAYER_H__
+#define __BKE_LAYER_H__
+
+/** \file BKE_layer.h
+ *  \ingroup bke
+ *  \since March 2012
+ *  \author ruesp83
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct Image;
+struct ImageLayer;
+struct ImBuf;
+
+/* call from library */
+
+/* Removes all image layers from the image "ima" */
+void image_free_image_layers(struct Image *ima);
+ 
+/* Frees an image layer and associated memory */
+void free_image_layer(struct ImageLayer *layer);
+ 
+/* Removes the currently selected image layer */
+int image_remove_current_image_layer(struct Image *ima);
+
+/* Removes the currently selected image layer */
+struct ImageLayer *image_duplicate_current_image_layer(struct Image *ima);
+
+/* Adds another image layer and selects it */
+struct ImageLayer *image_add_image_layer(struct Image *ima, const char *name, int depth, float color[4], int order);
+
+/* Adds the base layer of images that points Image->ibufs.first */
+void image_add_image_layer_base(struct Image *ima);
+ 
+/* Returns the index of the currently selected image layer */
+short imalayer_get_current_act(struct Image *ima);
+
+short imalayer_get_count(struct Image *ima);
+ 
+/* Selects the image layer with the number specified in "value" */
+void imalayer_set_current_act(struct Image *ima, short value);
+ 
+/* Returns the image layer that is currently selected */
+struct ImageLayer *imalayer_get_current(struct Image *ima);
+ 
+/* Fills the current selected image layer with the color given */
+void imalayer_fill_color(struct Image *ima, float color[4]);
+
+void imalayer_unique_name(struct ImageLayer *iml, struct Image *ima);
+//void imalayer_unique_name(const struct ListBase *imlayers, struct ImageLayer *newlayer);
+
+struct ImBuf *imalayer_blend(struct ImBuf *base, struct ImBuf *layer, float opacity, short mode);
+
+//struct ImBuf *merge_layers(
+
+unsigned int IML_blend_color(unsigned int src1, unsigned int src2, int opacity, short mode);
+void IML_blend_color_float(float *dst, float *src1, float *src2, float opacity, short mode);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
Index: source/blender/blenkernel/CMakeLists.txt
===================================================================
--- source/blender/blenkernel/CMakeLists.txt	(revisione 44897)
+++ source/blender/blenkernel/CMakeLists.txt	(copia locale)
@@ -103,6 +103,7 @@
 	intern/key.c
 	intern/lamp.c
 	intern/lattice.c
+	intern/layer.c
 	intern/library.c
 	intern/material.c
 	intern/mball.c
@@ -190,6 +191,7 @@
 	BKE_key.h
 	BKE_lamp.h
 	BKE_lattice.h
+	BKE_layer.h
 	BKE_library.h
 	BKE_main.h
 	BKE_material.h
Index: source/blender/blenkernel/intern/image.c
===================================================================
--- source/blender/blenkernel/intern/image.c	(revisione 44897)
+++ source/blender/blenkernel/intern/image.c	(copia locale)
@@ -73,6 +73,7 @@
 #include "BKE_global.h"
 #include "BKE_icons.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
 #include "BKE_packedFile.h"
@@ -202,6 +203,7 @@
 {
 	int a;
 
+	image_free_image_layers(ima);
 	image_free_buffers(ima);
 	if (ima->packedfile) {
 		freePackedFile(ima->packedfile);
@@ -218,6 +220,7 @@
 			ima->renders[a]= NULL;
 		}
 	}
+	
 }
 
 /* only image block itself */
@@ -243,11 +246,21 @@
 /* get the ibuf from an image cache, local use here only */
 static ImBuf *image_get_ibuf(Image *ima, int index, int frame)
 {
+	/* unsigned int totsize= 0; */
+
 	/* this function is intended to be thread safe. with IMA_NO_INDEX this
 	 * should be OK, but when iterating over the list this is more tricky
 	 * */
-	if(index==IMA_NO_INDEX)
+	if(index==IMA_NO_INDEX) {
+		/* TODO: (kwk) This is an ugly hack to return always the active layer's ibuf */
+		ImageLayer *layer= imalayer_get_current(ima);
+		
+		if (layer && layer->ibufs.first)
+			return layer->ibufs.first;
+		
+		/* Only return "normal" image ibuf if no layer ibuf was found. */
 		return ima->ibufs.first;
+	}
 	else {
 		ImBuf *ibuf;
 
@@ -296,6 +309,8 @@
 		/* now we don't want copies? */
 		if(link && ibuf->index==link->index)
 			image_remove_ibuf(ima, link);
+
+		image_add_image_layer_base(ima);
 	}
 }
 
@@ -560,7 +575,7 @@
 	return ima;
 }
 
-static ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4])
+ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4])
 {
 	ImBuf *ibuf;
 	unsigned char *rect= NULL;
@@ -609,7 +624,7 @@
 		
 		ibuf= add_ibuf_size(width, height, ima->name, depth, floatbuf, uvtestgrid, color);
 		image_assign_ibuf(ima, ibuf, IMA_NO_INDEX, 0);
-		
+
 		ima->ok= IMA_OK_LOADED;
 	}
 
Index: source/blender/blenkernel/intern/layer.c
===================================================================
--- source/blender/blenkernel/intern/layer.c	(revisione 0)
+++ source/blender/blenkernel/intern/layer.c	(copia locale)
@@ -0,0 +1,751 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * Contributor(s): Blender Foundation, 2006, full recode
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/blenkernel/intern/layer.c
+ *  \ingroup bke
+ */
+ 
+#include <stdio.h>
+#include <string.h>
+
+#include "MEM_guardedalloc.h"
+#include "IMB_imbuf_types.h"
+#include "IMB_imbuf.h"
+
+#include "DNA_userdef_types.h"
+
+#include "BLI_blenlib.h"
+#include "BLI_utildefines.h"
+#include "BLI_math_base.h"
+
+//#include "BKE_icons.h"
+//#include "BKE_global.h"
+#include "BKE_image.h"
+#include "BKE_layer.h"
+//#include "BKE_library.h"
+
+ 
+ static ImageLayer *layer_alloc(Image *ima, const char *name)
+{
+	ImageLayer *im_l;
+	
+	im_l = (ImageLayer*) MEM_callocN(sizeof(ImageLayer), "image_layer");
+	if(im_l) {
+		strcpy(im_l->name, name);
+		imalayer_unique_name(im_l, ima);
+		im_l->next = im_l->prev = NULL;
+
+		im_l->background = IMA_LAYER_BG_ALPHA;
+		im_l->color_space = IMA_LAYER_COL_RGB;
+		im_l->opacity = 1.0f;
+		im_l->mode = IMA_LAYER_NORMAL;
+		im_l->type = IMA_LAYER_LAYER;
+		im_l->visible = IMA_LAYER_VISIBLE;
+		im_l->select = IMA_LAYER_CURRENT;
+	}
+	return im_l;
+}
+
+void image_free_image_layers(struct Image *ima)
+{
+	ImageLayer *img_lay, *next;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima->imlayers.first == NULL)
+		return;
+
+	ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+	while((img_lay=ima->imlayers.first)) {
+		BLI_remlink(&ima->imlayers, img_lay);
+		free_image_layer(img_lay);
+	}
+
+	ima->Count_Layers = 0;
+	BKE_image_release_ibuf(ima, lock);
+}
+ 
+void free_image_layer(ImageLayer *layer)
+{
+	ImBuf *ibuf, *next;
+ 
+	if (!layer)
+		return;
+
+	while((ibuf = layer->ibufs.first)) {
+		BLI_remlink(&layer->ibufs, ibuf);
+ 
+		if (ibuf->userdata) {
+			MEM_freeN(ibuf->userdata);
+			ibuf->userdata = NULL;
+		}
+ 
+		IMB_freeImBuf(ibuf);
+	}
+
+	MEM_freeN(layer);
+}
+ 
+ImageLayer *imalayer_get_current(Image *ima)
+{
+	ImageLayer *layer;
+	if(ima == NULL)
+		return 0;
+ 
+	for(layer=ima->imlayers.last; layer; layer=layer->prev){
+		if(layer->select & IMA_LAYER_CURRENT)
+			return layer;
+	}
+ 
+	return NULL;
+}
+
+short imalayer_get_count(Image *ima)
+{
+	if(ima == NULL)
+		return 0;
+ 
+	return ima->Count_Layers;
+}
+short imalayer_get_current_act(Image *ima)
+{
+	if(ima == NULL)
+		return 0;
+ 
+	return ima->Act_Layers;
+}
+ 
+void imalayer_set_current_act(Image *ima, short index)
+{
+	ImageLayer *layer;
+	short i;
+ 
+	if(ima == NULL)
+		return;
+
+	for(layer=ima->imlayers.last, i = BLI_countlist(&ima->imlayers)-1; layer; layer=layer->prev, i--) {
+		if(i == index) {
+			layer->select = IMA_LAYER_CURRENT;
+			ima->Act_Layers = i;
+		}
+		else
+			layer->select = !IMA_LAYER_CURRENT;
+	}
+	
+}
+ 
+void imalayer_fill_color(struct Image *ima, float color[4])
+{
+	ImageLayer *layer= NULL;
+	ImBuf *ibuf= NULL;
+	unsigned char *rect= NULL;
+	float *rect_float= NULL;
+	void *lock;
+ 
+	if (ima==NULL)
+		return;
+ 
+	ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 
+ 
+	layer= imalayer_get_current(ima);
+ 
+	if ((ibuf = ima->imlayers.first)) {
+		if (ibuf->flags & IB_rectfloat) {
+			rect_float= (float*)ibuf->rect_float;
+		}
+		else {
+			rect= (unsigned char*)ibuf->rect;
+		}
+ 
+		//BKE_image_buf_fill_color(rect, rect_float, ibuf->x, ibuf->y, color);
+	}
+ 
+	BKE_image_release_ibuf(ima, lock);
+}
+
+ImageLayer *image_duplicate_current_image_layer(Image *ima)
+{
+	ImageLayer *layer = NULL, *im_l = NULL;
+	char dup_name[sizeof(layer->name)];
+	ImBuf *ibuf, *new_ibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return NULL;
+ 
+	layer = imalayer_get_current(ima);
+
+	if(!strstr(layer->name, "_copy")) {
+		BLI_snprintf(dup_name, sizeof(dup_name), "%s_copy", layer->name);
+	}
+	else {
+		BLI_snprintf(dup_name, sizeof(dup_name), "%s", layer->name);
+	}
+
+	im_l = layer_alloc(ima, dup_name);
+	if (im_l) {
+		ibuf= (ImBuf*)((ImageLayer*)layer->ibufs.first);
+		if (ibuf) {
+			new_ibuf = IMB_dupImBuf(ibuf);
+			BLI_addtail(&im_l->ibufs, new_ibuf);
+
+			im_l->next = im_l->prev = NULL;
+			if (layer) {
+				BLI_insertlinkbefore(&ima->imlayers, layer, im_l);
+			}
+			else {
+				BLI_addhead(&ima->imlayers, layer);
+			}
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+
+			im_l->background = layer->background;
+			im_l->color_space = layer->color_space;
+			im_l->mode = layer->mode;
+			im_l->opacity = layer->opacity;
+			im_l->type = IMA_LAYER_LAYER;
+			im_l->visible = layer->visible;
+		}
+		ima->Count_Layers += 1;
+	}
+	return im_l;
+}
+ 
+int image_remove_current_image_layer(Image *ima)
+{
+	ImageLayer *layer= NULL;
+	 
+	if(ima==NULL)
+		return FALSE;
+ 
+	layer = imalayer_get_current(ima);
+
+	if (layer) {
+		BLI_remlink(&ima->imlayers, layer);
+		free_image_layer(layer);
+	}
+	/* Ensure the first element in list gets selected (if any) */
+	if(ima->imlayers.first) {
+		if (imalayer_get_current_act(ima) != 1)
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+		else
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima)-1);
+	}
+	ima->Count_Layers -= 1;
+	return TRUE;
+}
+
+static char blend_normal(const char B, const char L, float O)
+{	
+	return (char)(O * (L) + (1.0f - O) * B);
+}
+
+static char blend_lighten(const char B, const char L, float O)
+{	
+	return (char)(O * ((L > B) ? L : B) + (1.0f - O) * B);
+}
+
+static char blend_darken(const char B, const char L, float O)
+{	
+	return (char)(O * ((L > B) ? B : L) + (1.0f - O) * B);
+}
+
+static char blend_multiply(const char B, const char L, float O)
+{	
+	return (char)(O * ((B * L) / 255) + (1.0f - O) * B);
+}
+
+static char blend_average(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L) / 2) + (1.0f - O) * B);
+}
+
+static char blend_add(const char B, const char L, float O)
+{	
+	return (char)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static char blend_subtract(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static char blend_difference(const char B, const char L, float O)
+{	
+	return (char)(O * (abs(B - L)) + (1.0f - O) * B);
+}
+
+static char blend_negation(const char B, const char L, float O)
+{	
+	return (char)(O * (255 - abs(255 - B - L)) + (1.0f - O) * B);
+}
+
+static char blend_screen(const char B, const char L, float O)
+{	
+	return (char)(O * (255 - (((255 - B) * (255 - L)) >> 8)) + (1.0f - O) * B);
+}
+
+static char blend_exclusion(const char B, const char L, float O)
+{	
+	return (char)(O * (B + L - 2 * B * L / 255) + (1.0f - O) * B);
+}
+
+static char blend_overlay(const char B, const char L, float O)
+{	
+	return (char)(O * ((L < 128) ? (2 * B * L / 255) : (255 - 2 * (255 - B) * (255 - L) / 255)) + (1.0f - O) * B);
+}
+
+static char blend_soft_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((L < 128) ? (2 * ((B >> 1) + 64)) * ((float)L / 255) : (255 - (2 * (255 - ((B >> 1) + 64)) * (float)(255 - L) / 255))) + (1.0f - O) * B);
+}
+
+static char blend_hard_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((B < 128) ? (2 * L * B / 255) : (255 - 2 * (255 - L) * (255 - B) / 255)) + (1.0f - O) * B);
+}
+
+static char blend_color_dodge(const char B, const char L, float O)
+{	
+	return (char)(O * ((L == 255) ? L : MIN2(255, ((B << 8 ) / (255 - L)))) + (1.0f - O) * B);
+}
+
+static char blend_color_burn(const char B, const char L, float O)
+{	
+	return (char)(O * ((L == 0) ? L : MAX2(0, (255 - ((255 - B) << 8 ) / L))) + (1.0f - O) * B);
+}
+
+static char blend_linear_dodge(const char B, const char L, float O)
+{	
+	return (char)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static char blend_linear_burn(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static char blend_linear_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((2 * L) < 128) ? ((B + (2 * L) < 255) ? 0 : (B + (2 * L) - 255)) : (MIN2(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static char blend_vivid_light(const char B, const char L, float O)
+{	
+	return (char)(O * (L < 128) ? (((2 * L) == 0) ? (2 * L) : MAX2(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (MIN2(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static char blend_pin_light(const char B, const char L, float O)
+{	
+	return (char)(O * (L < 128) ? (((2 * L) > B) ? B : (2 * L)) : (((2 * (L - 128)) > B) ? (2 * (L - 128)) : B) + (1.0f - O) * B);
+}
+
+static char blend_hard_mix(const char B, const char L, float O)
+{	
+	return (char)(O * (((L < 128) ? (((2 * L) == 0) ? (2 * L) : MAX2(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (MIN2(255, (B + (2 * (L - 128))))) < 128) ? 0 : 255) + (1.0f - O) * B);
+}
+
+/*static float blend_normal_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L) + (1.0f - O) * B);
+}
+
+static float blend_lighten_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L > B) ? L : B) + (1.0f - O) * B);
+}
+
+static float blend_darken_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L > B) ? B : L) + (1.0f - O) * B);
+}
+
+static float blend_multiply_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B * L) / 255) + (1.0f - O) * B);
+}
+
+static float blend_average_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L) / 2) + (1.0f - O) * B);
+}
+
+static float blend_add_f(const float B, const float L, float O)
+{	
+	return (float)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static float blend_subtract_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_difference_f(const float B, const float L, float O)
+{	
+	return (float)(O * (abs(B - L)) + (1.0f - O) * B);
+}
+
+static float blend_negation_f(const float B, const float L, float O)
+{	
+	return (float)(O * (255 - abs(255 - B - L)) + (1.0f - O) * B);
+}
+
+static float blend_screen_f(const float B, const float L, float O)
+{	
+	return (float)(O * (255 - (FTOCHAR((255 - B) * (255 - L)) >> 8)) + (1.0f - O) * B);
+}
+
+static float blend_exclusion_f(const float B, const float L, float O)
+{	
+	return (float)(O * (B + L - 2 * B * L / 255) + (1.0f - O) * B);
+}
+
+static float blend_overlay_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L < 128) ? (2 * B * L / 255) : (255 - 2 * (255 - B) * (255 - L) / 255)) + (1.0f - O) * B);
+}
+
+static float blend_soft_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L < 128) ? (2 * ((B >> 1) + 64)) * ((float)L / 255) : (255 - (2 * (255 - ((B >> 1) + 64)) * (float)(255 - L) / 255))) + (1.0f - O) * B);
+}
+
+static float blend_hard_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B < 128) ? (2 * L * B / 255) : (255 - 2 * (255 - L) * (255 - B) / 255)) + (1.0f - O) * B);
+}
+
+static float blend_color_dodge_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L == 255) ? L : minf(255, ((B << 8 ) / (255 - L)))) + (1.0f - O) * B);
+}
+
+static float blend_color_burn_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L == 0) ? L : maxf(0, (255 - ((255 - B) << 8 ) / L))) + (1.0f - O) * B);
+}
+
+static float blend_linear_dodge_f(const float B, const float L, float O)
+{	
+	return (float)(O * (minf(255, (B + L))) + (1.0f - O) * B);
+}
+
+static float blend_linear_burn_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_linear_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((2 * L) < 128) ? ((B + (2 * L) < 255) ? 0 : (B + (2 * L) - 255)) : (minf(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static float blend_vivid_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L < 128) ? (((2 * L) == 0) ? (2 * L) : maxf(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (minf(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static float blend_pin_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L < 128) ? (((2 * L) > B) ? B : (2 * L)) : (((2 * (L - 128)) > B) ? (2 * (L - 128)) : B) + (1.0f - O) * B);
+}
+
+static float blend_hard_mix_f(const float B, const float L, float O)
+{	
+	return (float)(O * (((L < 128) ? (((2 * L) == 0) ? (2 * L) : maxf(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (minf(255, (B + (2 * (L - 128))))) < 128) ? 0 : 255) + (1.0f - O) * B);
+}*/
+
+/*static float blend_normal_f(const float B, const float L, const float O)
+{	
+	return (char)(O * (L) + (1.0f - O) * B);
+}
+
+static float blend_multiply_f(const float B, const float L, const float O)
+{	
+	return (float)(O * ((B * L) / 1.0f) + (1.0f - O) * B);
+}
+
+static float blend_subtract_f(const float B, const float L, const float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_difference_f(const float B, const float L, const float O)
+{	
+	return (float)(O * (fabs(B - L)) + (1.0f - O) * B);
+}
+
+static float blend_overlay_f(float B, float L, float O)
+{	
+	return (float)(O * ((L < 0.5f) ? (2 * B * L / 1.0f) : (1.0f - 2 * (1.0f - B) * (1.0f - L) / 1.0f)) + (1.0f - O) * B);
+}*/
+
+ImBuf *imalayer_blend(ImBuf *base, ImBuf *layer, float opacity, short mode)
+{
+	ImBuf *dest;
+	int i, y;
+	//float (*blend_callback_f)(const float B, const float L, const float O) = NULL;	//Mode callback
+	char (*blend_callback)(const char B, const char L, const float O) = NULL;		//Mode callback
+	
+	if (!base)
+		return IMB_dupImBuf(layer);
+
+	dest = IMB_dupImBuf(base);
+
+	if (opacity == 0.0f)
+		return dest;
+
+	switch(mode) {
+	case IMA_LAYER_NORMAL:
+		blend_callback = blend_normal;
+		break;
+
+	case IMA_LAYER_MULTIPLY:
+		blend_callback = blend_multiply;
+		break;
+
+	case IMA_LAYER_SCREEN:
+		blend_callback = blend_screen;
+		break;
+
+	case IMA_LAYER_OVERLAY:
+		blend_callback = blend_overlay;
+		break;
+
+	case IMA_LAYER_SOFT_LIGHT:
+		blend_callback = blend_soft_light;
+		break;
+
+	case IMA_LAYER_HARD_LIGHT:
+		blend_callback = blend_hard_light;
+		break;
+
+	case IMA_LAYER_COLOR_DODGE:
+		blend_callback = blend_color_dodge;
+		break;
+
+	case IMA_LAYER_LINEAR_DODGE:
+		blend_callback = blend_linear_dodge;
+		break;
+		
+	case IMA_LAYER_COLOR_BURN:
+		blend_callback = blend_color_burn;
+		break;
+
+	case IMA_LAYER_LINEAR_BURN:
+		blend_callback = blend_linear_burn;
+		break;
+
+	case IMA_LAYER_AVERAGE: 
+		blend_callback = blend_average;
+		break;       
+
+	case IMA_LAYER_ADD: 
+		blend_callback = blend_add;
+		break;
+
+	case IMA_LAYER_SUBTRACT: 
+		blend_callback = blend_subtract;
+		break;       
+
+	case IMA_LAYER_DIFFERENCE: 
+		blend_callback = blend_difference;
+		break;
+	
+	case IMA_LAYER_LIGHTEN: 
+		blend_callback = blend_lighten;
+		break;       
+
+	case IMA_LAYER_DARKEN: 
+		blend_callback = blend_darken;
+		break;
+	
+	case IMA_LAYER_NEGATION: 
+		blend_callback = blend_negation;
+		break;       
+
+	case IMA_LAYER_EXCLUSION: 
+		blend_callback = blend_exclusion;
+		break;
+	
+	case IMA_LAYER_LINEAR_LIGHT: 
+		blend_callback = blend_linear_light;
+		break;       
+
+	case IMA_LAYER_VIVID_LIGHT: 
+		blend_callback = blend_vivid_light;
+		break;
+	
+	case IMA_LAYER_PIN_LIGHT: 
+		blend_callback = blend_pin_light;
+		break;       
+
+	case IMA_LAYER_HARD_MIX: 
+		blend_callback = blend_hard_mix;
+		break;
+	}
+
+	if (base->rect_float) {
+		
+		float *fp_b = (float *) base->rect_float;
+		float *fp_l = (float *) layer->rect_float;
+		float *fp_d = (float *) dest->rect_float;
+		for( i = base->x * base->y; i > 0; i--, fp_b+=4, fp_l+=4, fp_d+=4 ) {
+			if (fp_l[3] != 0.0f) {
+				fp_d[0] = ((float)blend_callback(FTOCHAR(fp_b[0]), FTOCHAR(fp_l[0]), opacity)) / 255.0f;
+				fp_d[1] = ((float)blend_callback(FTOCHAR(fp_b[1]), FTOCHAR(fp_l[1]), opacity)) / 255.0f;
+				fp_d[2] = ((float)blend_callback(FTOCHAR(fp_b[2]), FTOCHAR(fp_l[2]), opacity)) / 255.0f;
+			}
+		}
+
+		if(base->rect) {
+			IMB_rect_from_float(base);
+		}
+	}
+	else if(base->rect) {
+		
+		char *cp_b = (char *) base->rect;
+		char *cp_l = (char *) layer->rect;
+		char *cp_d = (char *) dest->rect;
+		for( i = base->x * base->y; i > 0; i--, cp_b+=4, cp_l+=4, cp_d+=4 ) {
+			if (cp_l[3] != 0) {
+				cp_d[0] = blend_callback(cp_b[0], cp_l[0], opacity);
+				cp_d[1] = blend_callback(cp_b[1], cp_l[1], opacity);
+				cp_d[2] = blend_callback(cp_b[2], cp_l[2], opacity);
+				//cp_d[3] = blend_difference(cp_b[3], cp_l[3], opacity);
+			}
+		}
+	}
+
+	return dest;
+}
+
+static int imlayer_find_name_dupe(const char *name, ImageLayer *iml, Image *ima)
+{
+	ImageLayer *layer;
+
+	for (layer = ima->imlayers.last; layer; layer=layer->prev) {
+		if (iml!=layer) {
+			if (!strcmp(layer->name, name)) {
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int imlayer_unique_check(void *arg, const char *name)
+{
+	struct {Image *ima; void *iml;} *data= arg;
+	return imlayer_find_name_dupe(name, data->iml, data->ima);
+}
+
+void imalayer_unique_name(ImageLayer *iml, Image *ima)
+{
+	struct {Image *ima; void *iml;} data;
+	data.ima = ima;
+	data.iml = iml;
+
+	BLI_uniquename_cb(imlayer_unique_check, &data, "Layer", '.', iml->name, sizeof(iml->name));
+}
+
+ImageLayer *image_add_image_layer(Image *ima, const char *name, int depth, float color[4], int order)
+{
+	ImageLayer *layer, *layer_act, *im_l = NULL;
+	ImBuf *ibuf, *imaibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return NULL;
+
+ 	layer_act = imalayer_get_current(ima);
+
+	/* Deselect other layers */
+	for(layer = ima->imlayers.first; layer; layer=layer->next)
+		layer->select = !IMA_LAYER_CURRENT;
+	
+	im_l = layer_alloc(ima, name);
+	if (im_l) {
+		ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 
+		imaibuf = (ImBuf*)ima->ibufs.first;
+		ibuf = add_ibuf_size(imaibuf->x, imaibuf->y, im_l->name, depth, ima->gen_flag, 0, color);
+		BLI_addtail(&im_l->ibufs, ibuf);
+		if (order == 2) { /*Head*/
+			BLI_addhead(&ima->imlayers, im_l);
+			ima->Act_Layers = 0;
+		}
+		else if (order == -1) { /*Before*/
+			/* Layer Act
+			 * --> Add Layer
+			 */
+			BLI_insertlinkafter(&ima->imlayers, layer_act , im_l);
+			ima->Act_Layers += 1;
+			imalayer_set_current_act(ima, ima->Act_Layers);
+		}
+		else { /*After*/
+			/* --> Add Layer
+			 * Layer Act
+			 */
+			BLI_insertlinkbefore(&ima->imlayers, layer_act , im_l);
+			//ima->Act_Layers -= 1;
+			imalayer_set_current_act(ima, ima->Act_Layers);
+		}
+		ima->Count_Layers += 1;
+
+		if (color[3] == 1.0f)
+			im_l->background = IMA_LAYER_BG_RGB;
+
+		BKE_image_release_ibuf(ima, lock);
+	}
+ 
+	return im_l;
+}
+ 
+/* TODO: (kwk) Base image layer needs proper locking... */
+void image_add_image_layer_base(Image *ima)
+{
+	ImageLayer *im_l = NULL;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima) {
+		im_l = layer_alloc(ima, "Background");
+		if (im_l) {	
+			ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 			im_l->type = IMA_LAYER_BASE; /* BASE causes no free on deletion of layer */
+			ima->Act_Layers = 0;
+			ima->Count_Layers = 1;
+			/* Get ImBuf from ima */
+			ibuf = IMB_dupImBuf((ImBuf*)ima->ibufs.first);
+			BLI_addtail(&im_l->ibufs, ibuf);
+			BLI_addhead(&ima->imlayers, im_l);
+ 
+			BKE_image_release_ibuf(ima, lock);
+		}
+	}
+}
+
Index: source/blender/blenloader/intern/readfile.c
===================================================================
--- source/blender/blenloader/intern/readfile.c	(revisione 44897)
+++ source/blender/blenloader/intern/readfile.c	(copia locale)
@@ -2952,22 +2952,6 @@
 }
 
 /* ************ READ IMAGE ***************** */
-
-static void lib_link_image(FileData *fd, Main *main)
-{
-	Image *ima;
-
-	ima= main->image.first;
-	while (ima) {
-		if(ima->id.flag & LIB_NEEDLINK) {
-			if (ima->id.properties) IDP_LibLinkProperty(ima->id.properties, (fd->flags & FD_FLAGS_SWITCH_ENDIAN), fd);
-
-			ima->id.flag -= LIB_NEEDLINK;
-		}
-		ima= ima->id.next;
-	}
-}
-
 static void link_ibuf_list(FileData *fd, ListBase *lb)
 {
 	Link *ln, *prev;
@@ -2986,13 +2970,64 @@
 	lb->last= prev;
 }
 
+static void link_imalayers_list(FileData *fd, ListBase *lb)
+{
+	Link *ln, *prev;
+	ImageLayer *layer;
+	
+	if(lb->first==NULL) return;
+	
+	lb->first = newimaadr(fd, lb->first);
+	printf("1\n");
+	ln = lb->first;
+	printf("2\n");
+	layer = (ImageLayer*)ln;
+	printf("3\n");
+	if (layer->name)
+		printf("Name=%s\n", layer->name);
+	else{
+		printf("4\n");
+		printf("Opacity=%d\n", layer->opacity);
+	}
+	prev= NULL;
+	while(ln) {
+		ln->next = newimaadr(fd, ln->next);
+		ln->prev = prev;
+		prev = ln;
+		layer = (ImageLayer*)ln;
+		printf("Name=%s\n", layer->name);
+		link_ibuf_list(fd, &layer->ibufs);
+		ln = ln->next;
+	}
+	lb->last= prev;
+}
+
+static void lib_link_image(FileData *fd, Main *main)
+{
+	Image *ima;
+	
+	ima= main->image.first;
+	while (ima) {
+		if(ima->id.flag & LIB_NEEDLINK) {
+			if (ima->id.properties) IDP_LibLinkProperty(ima->id.properties, (fd->flags & FD_FLAGS_SWITCH_ENDIAN), fd);
+
+			ima->id.flag -= LIB_NEEDLINK;
+		}
+
+		ima= ima->id.next;
+	}
+}
+
+
+
 static void direct_link_image(FileData *fd, Image *ima)
 {
 	/* for undo system, pointers could be restored */
+	
 	if(fd->imamap)
 		link_ibuf_list(fd, &ima->ibufs);
 	else
-		ima->ibufs.first= ima->ibufs.last= NULL;
+		ima->ibufs.first = ima->ibufs.last = NULL;
 	
 	/* if not restored, we keep the binded opengl index */
 	if(ima->ibufs.first==NULL) {
@@ -3000,6 +3035,7 @@
 		ima->gputexture= NULL;
 	}
 	
+	
 	ima->anim= NULL;
 	ima->rr= NULL;
 	ima->repbind= NULL;
@@ -3019,6 +3055,10 @@
 	ima->packedfile = direct_link_packedfile(fd, ima->packedfile);
 	ima->preview = direct_link_preview_image(fd, ima->preview);
 	ima->ok= 1;
+	if (ima->imlayers.first)
+		link_imalayers_list(fd, &ima->imlayers);
+	else
+		ima->imlayers.first = ima->imlayers.last = NULL;
 }
 
 
Index: source/blender/blenloader/intern/writefile.c
===================================================================
--- source/blender/blenloader/intern/writefile.c	(revisione 44897)
+++ source/blender/blenloader/intern/writefile.c	(copia locale)
@@ -1885,8 +1885,8 @@
 {
 	Image *ima;
 	PackedFile * pf;
+	ImageLayer *iml;
 
-
 	ima= idbase->first;
 	while(ima) {
 		if(ima->id.us>0 || wd->current) {
@@ -1900,6 +1900,13 @@
 				writedata(wd, DATA, pf->size, pf->data);
 			}
 
+			if (ima->imlayers.first) {
+				iml = ima->imlayers.first;
+				while(iml) {
+					writestruct(wd, DATA, "ImageLayer", 1, iml);
+					iml= iml->next;
+				}
+			}
 			write_previews(wd, ima->preview);
 		}
 		ima= ima->id.next;
Index: source/blender/editors/interface/interface_templates.c
===================================================================
--- source/blender/editors/interface/interface_templates.c	(revisione 44897)
+++ source/blender/editors/interface/interface_templates.c	(copia locale)
@@ -2075,6 +2075,10 @@
 	else if(RNA_struct_is_a(itemptr->type, &RNA_TextureSlot)) {
 		id= RNA_pointer_get(itemptr, "texture").data;
 	}
+	/*else if(RNA_struct_is_a(itemptr->type, &RNA_ImageLayer)) {
+		//id= RNA_pointer_get(itemptr, "imagelayer").data;
+
+	}*/
 	else if(RNA_struct_is_a(itemptr->type, &RNA_DynamicPaintSurface)) {
 		DynamicPaintSurface *surface= (DynamicPaintSurface*)itemptr->data;
 
@@ -2138,6 +2142,18 @@
 		uiBlockSetEmboss(block, UI_EMBOSS);
 		uiDefButR(block, OPTION, 0, "", 0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "use", 0, 0, 0, 0, 0,  NULL);
 	}
+	else if(RNA_struct_is_a(itemptr->type, &RNA_ImageLayer)) {
+		ImageLayer *layer = (ImageLayer*)itemptr->data;
+		uiItemL(sub, name, icon);
+		uiBlockSetEmboss(block, UI_EMBOSSN);
+		//uiDefButR(block, OPTION, 0, "", 0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "visible", 0, 0, 0, 0, 0,  NULL);
+		uiDefIconButR(block, OPTION, 0, (layer->lock & IMA_LAYER_LOCK) ? ICON_LOCKED : ICON_UNLOCKED,
+				0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "lock", 0, 0, 0, 0, 0, NULL);
+		uiDefIconButR(block, OPTION, 0, (layer->visible & IMA_LAYER_VISIBLE) ? ICON_RESTRICT_VIEW_OFF : ICON_RESTRICT_VIEW_ON,
+				0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "visible", 0, 0, 0, 0, 0, NULL);
+		uiBlockSetEmboss(block, UI_EMBOSS);
+
+	}
 	else if(RNA_struct_is_a(itemptr->type, &RNA_MaterialSlot)) {
 		/* provision to draw active node name */
 		Material *ma, *manode;
Index: source/blender/editors/space_image/image_draw.c
===================================================================
--- source/blender/editors/space_image/image_draw.c	(revisione 44897)
+++ source/blender/editors/space_image/image_draw.c	(copia locale)
@@ -54,6 +54,7 @@
 #include "BKE_context.h"
 #include "BKE_global.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_paint.h"
 
 #include "BIF_gl.h"
@@ -490,6 +491,53 @@
 	MEM_freeN(rectf);
 }
 
+static void draw_layer_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
+{
+	int x, y;
+	int color_manage = scene->r.color_mgt_flag & R_COLOR_MANAGEMENT;
+
+	/* set zoom */
+	glPixelZoom(zoomx, zoomy);
+
+	/* find window pixel coordinates of origin */
+	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
+	
+	/* this part is generic image display */
+	if(sima->flag & SI_SHOW_ALPHA) {
+		if(ibuf->rect)
+			sima_draw_alpha_pixels(x, y, ibuf->x, ibuf->y, ibuf->rect);
+		else if(ibuf->rect_float && ibuf->channels==4)
+			sima_draw_alpha_pixelsf(x, y, ibuf->x, ibuf->y, ibuf->rect_float);
+	}
+	else if(sima->flag & SI_SHOW_ZBUF && (ibuf->zbuf || ibuf->zbuf_float || (ibuf->channels==1))) {
+		if(ibuf->zbuf)
+			sima_draw_zbuf_pixels(x, y, ibuf->x, ibuf->y, ibuf->zbuf);
+		else if(ibuf->zbuf_float)
+			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->zbuf_float);
+		else if(ibuf->channels==1)
+			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->rect_float);
+	}
+	else {
+		
+		/* we don't draw floats buffers directly but
+		 * convert them, and optionally apply curves */
+		image_verify_buffer_float(ima, ibuf, color_manage);
+		
+		if(ibuf->rect)
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
+			glaDrawPixelsTexScaled(x, y, ibuf->x, ibuf->y, GL_RGBA, ibuf->rect, 1.0f, 1.0f);
+		//else
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_FLOAT, ibuf->rect_float);
+		
+		if(sima->flag & SI_USE_ALPHA)
+			glDisable(GL_BLEND);
+	}
+	
+	/* reset zoom */
+	glPixelZoom(1.0f, 1.0f);
+}
+
+
 static void draw_image_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
 {
 	int x, y;
@@ -500,7 +548,7 @@
 
 	/* find window pixel coordinates of origin */
 	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
-
+	
 	/* this part is generic image display */
 	if(sima->flag & SI_SHOW_ALPHA) {
 		if(ibuf->rect)
@@ -517,18 +565,18 @@
 			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->rect_float);
 	}
 	else {
-		if(sima->flag & SI_USE_ALPHA) {
+		if (sima->flag & SI_USE_ALPHA) {
 			unsigned char col1[3]= {100, 100, 100}, col2[3]= {160, 160, 160};
 			sima_draw_alpha_backdrop(x, y, ibuf->x, ibuf->y, zoomx, zoomy, col1, col2);
 
 			glEnable(GL_BLEND);
 			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 		}
-
+		
 		/* we don't draw floats buffers directly but
 		 * convert them, and optionally apply curves */
 		image_verify_buffer_float(ima, ibuf, color_manage);
-
+		
 		if(ibuf->rect)
 			glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
 #if 0
@@ -539,7 +587,7 @@
 		if(sima->flag & SI_USE_ALPHA)
 			glDisable(GL_BLEND);
 	}
-
+	
 	/* reset zoom */
 	glPixelZoom(1.0f, 1.0f);
 }
@@ -761,10 +809,14 @@
 void draw_image_main(SpaceImage *sima, ARegion *ar, Scene *scene)
 {
 	Image *ima;
+	ImageLayer *layer;
 	ImBuf *ibuf;
+	ImBuf *prev_ibuf, *result_ibuf;
 	float zoomx, zoomy;
 	int show_viewer, show_render;
+	int first = 0;
 	void *lock;
+	char background=0;
 
 	/* XXX can we do this in refresh? */
 #if 0
@@ -793,7 +845,7 @@
 
 	show_viewer= (ima && ima->source == IMA_SRC_VIEWER);
 	show_render= (show_viewer && ima->type == IMA_TYPE_R_RESULT);
-
+	
 	/* draw the image or grid */
 	if(ibuf==NULL)
 		draw_image_grid(ar, zoomx, zoomy);
@@ -801,8 +853,93 @@
 		draw_image_buffer_repeated(sima, ar, scene, ima, ibuf, zoomx, zoomy);
 	else if(ima && (ima->tpageflag & IMA_TILES))
 		draw_image_buffer_tiled(sima, ar, scene, ima, ibuf, 0.0f, 0.0, zoomx, zoomy);
-	else
+	else if (ima && !show_render && (sima->flag & SI_DRAWTOOL))
+		//((ima->type & IMA_TYPE_R_RESULT) == 0) && 
+		//((ima->type & IMA_TYPE_COMPOSITE) == 0) && (sima->flag & SI_DRAWTOOL))
+	{
+		prev_ibuf = NULL;
+		ibuf = BKE_image_acquire_ibuf(ima, NULL, &lock);
+		layer = ima->imlayers.first;
+		
+		if (layer->background & IMA_LAYER_BG_ALPHA) //Alpha
+			background = 1;
+
+		for(layer=ima->imlayers.last; layer; layer=layer->prev) {
+			if (!first) {
+				if ((layer->opacity!=1.0f) || (ibuf->channels==4) || (background==1)) {
+					int x, y;
+					unsigned char col1[3]= {100, 100, 100}, col2[3]= {160, 160, 160};
+					glEnable(GL_BLEND);
+					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+					UI_view2d_to_region_no_clip(&ar->v2d, 0.0f, 0.0f, &x, &y);
+					sima_draw_alpha_backdrop(x, y, ibuf->x, ibuf->y, zoomx, zoomy, col1, col2);
+					glDisable(GL_BLEND);
+					first = 1;
+				}
+			}
+			//glEnable(GL_BLEND);
+			if (layer->visible & IMA_LAYER_VISIBLE) {
+				ibuf= (ImBuf*)((ImageLayer*)layer->ibufs.first);
+				
+				if (ibuf) {
+					//if (prev_ibuf) {
+						result_ibuf = imalayer_blend(prev_ibuf, ibuf, layer->opacity, layer->mode);
+						if (prev_ibuf)
+							IMB_freeImBuf(prev_ibuf);
+						//IMB_freeImBuf(prev_ibuf);
+						prev_ibuf = IMB_dupImBuf(result_ibuf);
+					//}
+					//else {
+					//	prev_ibuf = IMB_dupImBuf(ibuf);
+					//	result_ibuf = prev_ibuf;
+					//}
+					glEnable(GL_BLEND);
+					//glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					
+					//glEnable(GL_BLEND);
+					//if (background == 0) //RGB
+						//glBlendFunc(GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR);
+                        //GL_ONE_MINUS_SRC_ALPHA);
+					//else //Alpha
+						glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+					glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					draw_layer_buffer(sima, ar, scene, ima, result_ibuf, 0.0f, 0.0f, zoomx, zoomy);
+					
+					glDisable(GL_BLEND);
+
+					//if (layer->type & IMA_LAYER_LAYER)
+					if (result_ibuf)
+						IMB_freeImBuf(result_ibuf);
+					/*if (prev_ibuf)
+						IMB_freeImBuf(prev_ibuf);*/
+				}
+			}
+		}
+		glDisable(GL_BLEND);
+		/*glEnable(GL_DEPTH_TEST);*/
+		/*if (result_ibuf)
+			IMB_freeImBuf(result_ibuf);*/
+		if (prev_ibuf)
+			IMB_freeImBuf(prev_ibuf);
+		BKE_image_release_ibuf(ima, lock);
+	}
+	else {
+		layer = ima->imlayers.last;
+		if (layer->background & IMA_LAYER_BG_ALPHA) {
+			int x, y;
+			unsigned char col1[3]= {100, 100, 100}, col2[3]= {160, 160, 160};
+			glEnable(GL_BLEND);
+			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+			UI_view2d_to_region_no_clip(&ar->v2d, 0.0f, 0.0f, &x, &y);
+			sima_draw_alpha_backdrop(x, y, ibuf->x, ibuf->y, zoomx, zoomy, col1, col2);
+		}
+
 		draw_image_buffer(sima, ar, scene, ima, ibuf, 0.0f, 0.0f, zoomx, zoomy);
+		
+		if (layer->background & IMA_LAYER_BG_ALPHA)
+			glDisable(GL_BLEND);
+	}
 
 	/* paint helpers */
 	if(sima->flag & SI_DRAWTOOL)
Index: source/blender/editors/space_image/image_intern.h
===================================================================
--- source/blender/editors/space_image/image_intern.h	(revisione 44897)
+++ source/blender/editors/space_image/image_intern.h	(copia locale)
@@ -93,5 +93,13 @@
 void IMAGE_OT_properties(struct wmOperatorType *ot);
 void IMAGE_OT_scopes(struct wmOperatorType *ot);
 
+/* image layers */
+void IMAGE_OT_image_layer_move(struct wmOperatorType *ot);
+//void IMAGE_OT_image_layer_fill_color(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_remove(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add_below(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add_above(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_duplicate(struct wmOperatorType *ot);
+
 #endif /* __IMAGE_INTERN_H__ */
-
Index: source/blender/editors/space_image/image_ops.c
===================================================================
--- source/blender/editors/space_image/image_ops.c	(revisione 44897)
+++ source/blender/editors/space_image/image_ops.c	(copia locale)
@@ -47,6 +47,7 @@
 #include "BKE_colortools.h"
 #include "BKE_context.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_global.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
@@ -1501,6 +1502,7 @@
 	char name[MAX_ID_NAME-2];
 	float color[4];
 	int width, height, floatbuf, uvtestgrid, alpha;
+	short background;
 
 	/* retrieve state */
 	sima= CTX_wm_space_image(C);
@@ -1508,13 +1510,27 @@
 	obedit= CTX_data_edit_object(C);
 
 	RNA_string_get(op->ptr, "name", name);
-	width= RNA_int_get(op->ptr, "width");
-	height= RNA_int_get(op->ptr, "height");
-	floatbuf= RNA_boolean_get(op->ptr, "float");
-	uvtestgrid= RNA_boolean_get(op->ptr, "uv_test_grid");
+	width = RNA_int_get(op->ptr, "width");
+	height = RNA_int_get(op->ptr, "height");
+	floatbuf = RNA_boolean_get(op->ptr, "float");
+	uvtestgrid = RNA_boolean_get(op->ptr, "uv_test_grid");
 	RNA_float_get_array(op->ptr, "color", color);
-	alpha= RNA_boolean_get(op->ptr, "alpha");
-	
+	alpha = RNA_boolean_get(op->ptr, "alpha");
+	background = RNA_enum_get(op->ptr, "background");
+
+	if (background & IMA_LAYER_BG_WHITE) {
+		color[0] = 1.0f;
+		color[1] = 1.0f;
+		color[2] = 1.0f;
+		color[3] = 1.0f;
+	}
+	else if (background & IMA_LAYER_BG_ALPHA) {
+		color[0] = 0.0f;
+		color[1] = 0.0f;
+		color[2] = 0.0f;
+		color[3] = 0.0f;
+	}
+
 	if (!floatbuf && scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
 		linearrgb_to_srgb_v3_v3(color, color);
 
@@ -1522,6 +1538,7 @@
 		color[3]= 1.0f;
 
 	ima = BKE_add_image_size(width, height, name, alpha ? 32 : 24, floatbuf, uvtestgrid, color);
+	((ImageLayer *)ima->imlayers.first)->background = background;
 
 	if(!ima)
 		return OPERATOR_CANCELLED;
@@ -1557,7 +1574,16 @@
 void IMAGE_OT_new(wmOperatorType *ot)
 {
 	PropertyRNA *prop;
+	short background;
+	
 	static float default_color[4]= {0.0f, 0.0f, 0.0f, 1.0f};
+
+	static EnumPropertyItem prop_background_items[] = {
+		{IMA_LAYER_BG_RGB, "RGB", 0, "RGB", ""},
+		{IMA_LAYER_BG_WHITE, "WHITE", 0, "White", ""},
+		{IMA_LAYER_BG_ALPHA, "ALPHA", 0, "Transparent", ""},
+		{0, NULL, 0, NULL, NULL}};
+
 	
 	/* identifiers */
 	ot->name= "New Image";
@@ -1567,7 +1593,7 @@
 	/* api callbacks */
 	ot->exec= image_new_exec;
 	ot->invoke= image_new_invoke;
-	
+		
 	/* flags */
 	ot->flag= OPTYPE_UNDO;
 
@@ -1575,11 +1601,14 @@
 	RNA_def_string(ot->srna, "name", "untitled", MAX_ID_NAME-2, "Name", "Image datablock name");
 	RNA_def_int(ot->srna, "width", 1024, 1, INT_MAX, "Width", "Image width", 1, 16384);
 	RNA_def_int(ot->srna, "height", 1024, 1, INT_MAX, "Height", "Image height", 1, 16384);
+	RNA_def_enum(ot->srna, "background", prop_background_items, 0, "Background", "");
+
 	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Color", "Default fill color", 0.0f, 1.0f);
 	RNA_def_property_float_array_default(prop, default_color);
 	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel");
+	RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth");
 	RNA_def_boolean(ot->srna, "uv_test_grid", 0, "UV Test Grid", "Fill the image with a grid for UV map testing");
-	RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth");
+	
 }
 
 /********************* invert operators *********************/
@@ -1667,6 +1696,271 @@
 	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
 }
 
+/********************** new image layer operators *********************/
+
+int image_layer_poll(bContext *C)
+{	
+	SpaceImage *sima= CTX_wm_space_image(C);
+	return ED_space_image_show_paint(sima);
+}
+ 
+static int image_layer_add_exec(bContext *C, wmOperator *op)
+{	
+	char name[22];
+	float color[4];
+	int alpha, order;
+	Scene *scene;
+	Image *ima = CTX_data_edit_image(C);
+	ImageLayer *iml;
+	
+	scene= (Scene*)CTX_data_scene(C);
+
+	RNA_string_get(op->ptr, "name", name);
+	RNA_float_get_array(op->ptr, "color", color);
+	alpha = RNA_boolean_get(op->ptr, "alpha");
+
+	order = 2;
+	if (strcmp(op->idname, "IMAGE_OT_image_layer_add_above") == 0)
+		order = 1;
+	else if (strcmp(op->idname, "IMAGE_OT_image_layer_add_below") == 0)
+		order = -1;
+
+	if (scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
+		linearrgb_to_srgb_v3_v3(color, color);
+
+	if(!alpha) 
+		color[3] = 1.0f;
+	
+	iml = image_add_image_layer(ima, name, alpha ? 32 : 24, color, order);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_add(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+	/*static EnumPropertyItem layer_order[] = {
+		{-1, "BEFORE", 0, "Before", ""},
+		{1, "AFTER", 0, "After", ""},
+		{2, "HEAD", 0, "Head", ""},
+		{0, NULL, 0, NULL, NULL}
+	};*/
+
+	/* identifiers */
+	ot->name= "New Layer";
+	ot->idname= "IMAGE_OT_image_layer_add";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec = image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke = image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+void IMAGE_OT_image_layer_add_above(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "Above active layer";
+	ot->idname= "IMAGE_OT_image_layer_add_above";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke= image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+void IMAGE_OT_image_layer_add_below(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "Below active layer";
+	ot->idname= "IMAGE_OT_image_layer_add_below";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke= image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+static int image_layer_duplicate_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *iml;
+
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	iml = image_duplicate_current_image_layer(ima);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_duplicate(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name= "Duplicate Layer";
+	ot->idname= "IMAGE_OT_image_layer_duplicate";
+	ot->description="Duplicate the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_duplicate_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
+
+
+static int image_layer_remove_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	image_remove_current_image_layer(ima);
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_remove(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name= "Remove Layer";
+	ot->idname= "IMAGE_OT_image_layer_remove";
+	ot->description="Remove the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_remove_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
+ 
+ 
+static int image_layer_move_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer, *tmp;
+	int type, layerID;
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	layer= imalayer_get_current(ima);
+ 
+	if (!layer)
+		return OPERATOR_CANCELLED;
+ 
+	type = RNA_enum_get(op->ptr, "type");
+	layerID = imalayer_get_current_act(ima);
+	
+	if (!(layer->type & IMA_LAYER_BASE)) {
+		if (type == -1) { /* Move direction: Up */
+			if (layerID > 0) {
+				tmp = layer->prev;
+				BLI_remlink(&ima->imlayers, layer);
+				layer->next = layer->prev = NULL;
+				if (tmp) {
+					BLI_insertlinkbefore(&ima->imlayers, tmp, layer);
+				}
+				else {
+					BLI_addhead(&ima->imlayers, layer);
+				}
+				imalayer_set_current_act(ima, layerID-1);
+			}
+		}
+		else { /* Move direction: Down */
+			if (layerID < (BLI_countlist(&ima->imlayers)-1)) {
+				tmp = layer->next;
+				if (!(tmp->type & IMA_LAYER_BASE)) {
+					BLI_remlink(&ima->imlayers, layer);
+					layer->next = layer->prev = NULL;
+					if (tmp) {
+						BLI_insertlinkafter(&ima->imlayers, tmp, layer);
+					}
+					else {
+						BLI_addtail(&ima->imlayers, layer);
+					}	
+					imalayer_set_current_act(ima, layerID+1);
+				}
+			}
+		}
+	}
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_move(wmOperatorType *ot)
+{
+	static EnumPropertyItem slot_move[] = {
+		{-1, "UP", 0, "Up", ""},
+		{1, "DOWN", 0, "Down", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Move Layer";
+	ot->idname= "IMAGE_OT_image_layer_move";
+	ot->description="Move image layers up and down";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_move_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "type", slot_move, 0, "Type", "");
+}
+
 /********************* pack operator *********************/
 
 static int image_pack_test(bContext *C, wmOperator *op)
Index: source/blender/editors/space_image/space_image.c
===================================================================
--- source/blender/editors/space_image/space_image.c	(revisione 44897)
+++ source/blender/editors/space_image/space_image.c	(copia locale)
@@ -491,6 +491,14 @@
 
 	WM_operatortype_append(IMAGE_OT_properties);
 	WM_operatortype_append(IMAGE_OT_scopes);
+
+	WM_operatortype_append(IMAGE_OT_image_layer_move);
+	//WM_operatortype_append(IMAGE_OT_image_layer_fill_color);
+	WM_operatortype_append(IMAGE_OT_image_layer_remove);
+	WM_operatortype_append(IMAGE_OT_image_layer_add);
+	WM_operatortype_append(IMAGE_OT_image_layer_add_below);
+	WM_operatortype_append(IMAGE_OT_image_layer_add_above);
+	WM_operatortype_append(IMAGE_OT_image_layer_duplicate);
 }
 
 static void image_keymap(struct wmKeyConfig *keyconf)
@@ -505,6 +513,11 @@
 	WM_keymap_add_item(keymap, "IMAGE_OT_save_as", F3KEY, KM_PRESS, 0, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_properties", NKEY, KM_PRESS, 0, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_scopes", TKEY, KM_PRESS, 0, 0);
+	
+	/*Layers*/
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add", NKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add_above", UPARROWKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add_below", DOWNARROWKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
 
 	WM_keymap_add_item(keymap, "IMAGE_OT_cycle_render_slot", JKEY, KM_PRESS, 0, 0);
 	RNA_boolean_set(WM_keymap_add_item(keymap, "IMAGE_OT_cycle_render_slot", JKEY, KM_PRESS, KM_ALT, 0)->ptr, "reverse", TRUE);
Index: source/blender/makesdna/DNA_image_types.h
===================================================================
--- source/blender/makesdna/DNA_image_types.h	(revisione 44897)
+++ source/blender/makesdna/DNA_image_types.h	(copia locale)
@@ -34,6 +34,10 @@
 
 #include "DNA_ID.h"
 
+#ifndef MAX_LIMA
+#define MAX_LIMA	18
+#endif
+
 struct PackedFile;
 struct Scene;
 struct anim;
@@ -66,6 +70,194 @@
 #define IMA_ANIM_REFRESHED	2
 /* #define IMA_DO_PREMUL	4 */
 
+
+typedef struct ImageLayer {
+	struct ImageLayer *next, *prev;
+	//ID id;
+	//struct PreviewImage * preview;
+	char name[64];
+	short background;
+	short color_space;
+	float opacity;
+	short mode;
+	short type;
+	short visible;
+	short select;
+	short lock;
+	//int icon_id;
+	short pad1;
+	int pad2;
+	ListBase ibufs;
+}ImageLayer;
+
+/* **************** IMAGE LAYER********************* */
+#define IMA_LAYER_MAX_LEN	64
+
+/* ImageLayer.background */
+#define IMA_LAYER_BG_RGB		(1<<0)
+#define IMA_LAYER_BG_WHITE		(1<<1)
+#define IMA_LAYER_BG_ALPHA		(1<<2)
+
+/* ImageLayer.color_space */
+#define IMA_LAYER_COL_RGB		(1<<0)
+#define IMA_LAYER_COL_GRAY		(1<<1)
+
+/* ImageLayer.mode */
+#define IMA_LAYER_NORMAL 		0
+
+#define IMA_LAYER_MULTIPLY		1
+#define IMA_LAYER_SCREEN		2
+#define IMA_LAYER_OVERLAY		3
+#define IMA_LAYER_SOFT_LIGHT	4
+#define IMA_LAYER_HARD_LIGHT	5
+
+#define IMA_LAYER_COLOR_DODGE	6
+#define IMA_LAYER_LINEAR_DODGE	7
+#define IMA_LAYER_COLOR_BURN	8
+#define IMA_LAYER_LINEAR_BURN	9
+
+#define IMA_LAYER_AVERAGE		10
+#define IMA_LAYER_ADD			11
+#define IMA_LAYER_SUBTRACT		12
+#define IMA_LAYER_DIFFERENCE	13
+#define IMA_LAYER_LIGHTEN		14
+#define IMA_LAYER_DARKEN		15
+
+#define IMA_LAYER_NEGATION		16
+#define IMA_LAYER_EXCLUSION		17
+
+#define IMA_LAYER_LINEAR_LIGHT	18
+#define IMA_LAYER_VIVID_LIGHT	19
+#define IMA_LAYER_PIN_LIGHT		20
+#define IMA_LAYER_HARD_MIX		21
+
+/*#define ChannelBlend_Reflect(A,B)    ((uint8)((B == 255) ? B:min(255, (A * A / (255 - B)))))
+#define ChannelBlend_Glow(A,B)       (ChannelBlend_Reflect(B,A))
+#define ChannelBlend_Phoenix(A,B)    ((uint8)(min(A,B) - max(A,B) + 255))
+#define ChannelBlend_Alpha(A,B,O)    ((uint8)(O * A + (1 - O) * B))
+#define ChannelBlend_AlphaF(A,B,F,O) (ChannelBlend_Alpha(F(A,B),A,O))
+
+#define ColorBlend_Hue(T,A,B)            ColorBlend_Hls(T,A,B,HueB,LuminationA,SaturationA)
+#define ColorBlend_Saturation(T,A,B)     ColorBlend_Hls(T,A,B,HueA,LuminationA,SaturationB)
+#define ColorBlend_Color(T,A,B)          ColorBlend_Hls(T,A,B,HueB,LuminationA,SaturationB)
+#define ColorBlend_Luminosity(T,A,B)     ColorBlend_Hls(T,A,B,HueA,LuminationB,SaturationA)
+
+#define ColorBlend_Hls(T,A,B,O1,O2,O3) {
+    float64 HueA, LuminationA, SaturationA;
+    float64 HueB, LuminationB, SaturationL;
+    Color_RgbToHls((A)[2],(A)[1],(A)[0], &HueA, &LuminationA, &SaturationA);
+    Color_RgbToHls((B)[2],(B)[1],(B)[0], &HueB, &LuminationB, &SaturationB);
+    Color_HlsToRgb(O1,O2,O3,&(T)[2],&(T)[1],&(T)[0]);
+    }
+
+int32 Color_HueToRgb(float64 M1, float64 M2, float64 Hue, float64 *Channel)
+{
+    if (Hue < 0.0)
+        Hue += 1.0;
+    else if (Hue > 1.0)
+        Hue -= 1.0;
+
+    if ((6.0 * Hue) < 1.0)
+        *Channel = (M1 + (M2 - M1) * Hue * 6.0);
+    else if ((2.0 * Hue) < 1.0)
+        *Channel = (M2);
+    else if ((3.0 * Hue) < 2.0)
+        *Channel = (M1 + (M2 - M1) * ((2.0F / 3.0F) - Hue) * 6.0);
+    else
+        *Channel = (M1);
+
+    return TRUE;
+}
+
+int32 Color_RgbToHls(uint8 Red, uint8 Green, uint8 Blue, float64 *Hue, float64 *Lumination, float64 *Saturation)
+{
+    float64 Delta;
+    float64 Max, Min;
+    float64 Redf, Greenf, Bluef;
+
+    Redf    = ((float64)Red   / 255.0F);
+    Greenf  = ((float64)Green / 255.0F);
+    Bluef   = ((float64)Blue  / 255.0F); 
+
+    Max     = max(max(Redf, Greenf), Bluef);
+    Min     = min(min(Redf, Greenf), Bluef);
+
+    *Hue        = 0;
+    *Lumination = (Max + Min) / 2.0F;
+    *Saturation = 0;
+
+    if (Max == Min)
+        return TRUE;
+
+    Delta = (Max - Min);
+
+    if (*Lumination < 0.5)
+        *Saturation = Delta / (Max + Min);
+    else
+        *Saturation = Delta / (2.0 - Max - Min);
+
+    if (Redf == Max)
+        *Hue = (Greenf - Bluef) / Delta;
+    else if (Greenf == Max)
+        *Hue = 2.0 + (Bluef - Redf) / Delta;
+    else
+        *Hue = 4.0 + (Redf - Greenf) / Delta;
+
+    *Hue /= 6.0; 
+
+    if (*Hue < 0.0)
+        *Hue += 1.0;       
+
+    return TRUE;
+}
+
+int32 Color_HlsToRgb(float64 Hue, float64 Lumination, float64 Saturation, uint8 *Red, uint8 *Green, uint8 *Blue)
+{
+    float64 M1, M2;
+    float64 Redf, Greenf, Bluef;
+
+    if (Saturation == 0)
+        {
+        Redf    = Lumination;
+        Greenf  = Lumination;
+        Bluef   = Lumination;
+        }
+    else
+        {
+        if (Lumination <= 0.5)
+            M2 = Lumination * (1.0 + Saturation);
+        else
+            M2 = Lumination + Saturation - Lumination * Saturation;
+
+        M1 = (2.0 * Lumination - M2);
+
+        Color_HueToRgb(M1, M2, Hue + (1.0F / 3.0F), &Redf);
+        Color_HueToRgb(M1, M2, Hue, &Greenf);
+        Color_HueToRgb(M1, M2, Hue - (1.0F / 3.0F), &Bluef);
+        }
+
+    *Red    = (uint8)(Redf * 255);
+    *Blue   = (uint8)(Bluef * 255);
+    *Green  = (uint8)(Greenf * 255);
+
+    return TRUE;
+}
+
+*/
+
+/* ImageLayer.type */
+#define IMA_LAYER_BASE		(1<<0)
+#define IMA_LAYER_LAYER		(1<<1)
+
+/* ImageLayer.visible */
+#define IMA_LAYER_VISIBLE	(1<<0)
+
+/* ImageLayer.select */
+#define IMA_LAYER_CURRENT	(1<<0)
+
+/* ImageLayer.lock */
+#define IMA_LAYER_LOCK		(1<<0)
+
 typedef struct Image {
 	ID id;
 	
@@ -106,6 +298,9 @@
 	
 	/* display aspect - for UV editing images resized for faster openGL display */
 	float aspx, aspy;
+	int Act_Layers;
+	int Count_Layers;
+	ListBase imlayers;
 } Image;
 
 
Index: source/blender/makesrna/intern/rna_image.c
===================================================================
--- source/blender/makesrna/intern/rna_image.c	(revisione 44897)
+++ source/blender/makesrna/intern/rna_image.c	(copia locale)
@@ -38,6 +38,7 @@
 #include "BKE_context.h"
 #include "BKE_depsgraph.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 
 #include "WM_types.h"
 #include "WM_api.h"
@@ -285,6 +286,62 @@
 	return planes;
 }
 
+static PointerRNA rna_Image_active_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= imalayer_get_current(ima);
+ 
+	return rna_pointer_inherit_refine(ptr, &RNA_ImageLayer, layer);
+}
+
+static void rna_Image_active_image_layer_set(PointerRNA *ptr, PointerRNA value)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= (ImageLayer*)value.data;
+	const int index= BLI_findindex(&ima->imlayers, layer);
+	if (index != -1) ima->Act_Layers= index;
+}
+
+static void rna_Image_layers_begin(CollectionPropertyIterator *iter, PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	rna_iterator_listbase_begin(iter, &ima->imlayers, NULL);
+}
+
+static int rna_Image_count_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_count(ima);
+}
+
+static int rna_Image_active_image_layer_index_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_current_act(ima);
+}
+ 
+static void rna_Image_active_image_layer_index_set(PointerRNA *ptr, int value)
+{
+	Image *ima= (Image*)ptr->data;
+	imalayer_set_current_act(ima, value);
+}
+ 
+static void rna_Image_active_image_layer_index_range(PointerRNA *ptr, int *min, int *max)
+{
+	Image *im= (Image*)ptr->data;
+	void *lock;
+	ImBuf *ibuf= BKE_image_acquire_ibuf(im, NULL, &lock);
+
+	/**min= 0;
+	*max= BLI_countlist(&im->imlayers)-1;
+	*max= MAX2(0, *max);*/
+	*min= BLI_countlist(&im->imlayers)-1;
+	*max= 0;
+	*min= MAX2(0, *min);
+
+	BKE_image_release_ibuf(im, lock);
+}
+
 static int rna_Image_pixels_get_length(PointerRNA *ptr, int length[RNA_MAX_ARRAY_DIMENSION])
 {
 	Image *ima = ptr->id.data;
@@ -410,6 +467,136 @@
 	RNA_def_property_ui_text(prop, "Pass", "Pass in multilayer image");
 }
 
+static void rna_def_image_layer_common(StructRNA *srna)
+{
+	PropertyRNA *prop;
+
+	static EnumPropertyItem prop_type_items[] = {
+		{IMA_LAYER_BASE, "BASE", 0, "Base", ""},
+		{IMA_LAYER_LAYER, "LAYER", 0, "Layer", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	static EnumPropertyItem prop_background_items[] = {
+		{IMA_LAYER_BG_RGB, "RGB", 0, "RGB", ""},
+		{IMA_LAYER_BG_WHITE, "WHITE", 0, "White", ""},
+		{IMA_LAYER_BG_ALPHA, "ALPHA", 0, "Transparent", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	static EnumPropertyItem prop_blend_type_items[] = {
+		{IMA_LAYER_NORMAL, "NORMAL", 0, "Normal", ""},
+		{IMA_LAYER_MULTIPLY, "MULTIPLY", 0, "Multiply", ""},
+		{IMA_LAYER_SCREEN, "SCREEN", 0, "Screen", ""},
+		{IMA_LAYER_OVERLAY, "OVERLAY", 0, "Overlay", ""},
+		{IMA_LAYER_SOFT_LIGHT, "SOFT_LIGHT", 0, "Soft Light", ""},
+		{IMA_LAYER_HARD_LIGHT, "HARD_LIGHT", 0, "Hard Light", ""},
+		{IMA_LAYER_COLOR_DODGE, "COLOR_DODGE", 0, "Color Dodge", ""},
+		{IMA_LAYER_LINEAR_DODGE, "LINEAR_DODGE", 0, "Linear Dodge", ""},
+		{IMA_LAYER_COLOR_BURN, "COLOR_BURN", 0, "Color Burn", ""},
+		{IMA_LAYER_LINEAR_BURN, "LINEAR_BURN", 0, "Linear Burn", ""},
+		{IMA_LAYER_AVERAGE, "AVERAGE", 0, "Average", ""},
+		{IMA_LAYER_ADD, "ADD", 0, "Add", ""},
+		{IMA_LAYER_SUBTRACT, "SUBTRACT", 0, "Subtract", ""},
+		{IMA_LAYER_DIFFERENCE, "DIFFERENCE", 0, "Difference", ""},
+		{IMA_LAYER_LIGHTEN, "LIGHTEN", 0, "Lighten", ""}, 
+		{IMA_LAYER_DARKEN, "DARKEN", 0, "Darken", ""}, 
+		{IMA_LAYER_NEGATION, "NEGATION", 0, "Negation", ""},
+		{IMA_LAYER_EXCLUSION, "EXCLUSION", 0, "Exclusion", ""},
+		{IMA_LAYER_LINEAR_LIGHT, "LINEAR_LIGHT", 0, "Linear Light", ""},
+		{IMA_LAYER_VIVID_LIGHT, "VIVID_LIGHT", 0, "Vivid Light", ""},
+		{IMA_LAYER_PIN_LIGHT, "PIN_LIGHT", 0, "Pin Light", ""}, 
+		{IMA_LAYER_HARD_MIX, "HARD_LIGHT", 0, "Hard Light", ""},
+		{0, NULL, 0, NULL, NULL}};
+	
+	prop= RNA_def_property(srna, "name", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_default(prop, "ImageLayer");
+	RNA_def_property_string_maxlength(prop, IMA_LAYER_MAX_LEN);
+	RNA_def_property_update(prop, NC_OBJECT|ND_MODIFIER|NA_RENAME, NULL);
+	RNA_def_property_ui_text(prop, "Name", "The name of the image layer.");
+	RNA_def_struct_name_property(srna, prop);
+
+ 	prop= RNA_def_property(srna, "visible", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_ui_text(prop, "", "Hides the layer in the UV/Image Editor");
+	RNA_def_property_boolean_sdna(prop, NULL, "visible", IMA_LAYER_VISIBLE);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "lock", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_ui_text(prop, "", "Blocks the layer in the UV/Image Editor");
+	RNA_def_property_boolean_sdna(prop, NULL, "lock", IMA_LAYER_LOCK);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "opacity", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "opacity");
+	RNA_def_property_range(prop, 0.0, 1.0);
+	RNA_def_property_ui_range(prop, 0, 1.0, 1, 3);
+	RNA_def_property_ui_text(prop, "Opacity", "The opacity of the image layer when blended.");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "blend_type", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "mode");
+	RNA_def_property_enum_items(prop, prop_blend_type_items);
+	RNA_def_property_ui_text(prop, "Blend Modes", "Determine how two Layers are blended into each other.");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "background", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "background");
+	RNA_def_property_enum_items(prop, prop_background_items);
+	RNA_def_property_ui_text(prop, "Type Background", "");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "type", PROP_ENUM, PROP_NONE);
+	//RNA_def_property_ui_text(prop, "", "Defines the type of layer");
+	//RNA_def_property_boolean_sdna(prop, NULL, "type", IMA_LAYER_BASE);
+	RNA_def_property_enum_sdna(prop, NULL, "type");
+	RNA_def_property_enum_items(prop, prop_type_items);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
+static void rna_def_image_layer(BlenderRNA *brna)
+{
+	StructRNA *srna;
+		
+	srna= RNA_def_struct(brna, "ImageLayer", NULL);
+	RNA_def_struct_ui_text(srna, "Image Layer", "Image layer");
+	RNA_def_struct_ui_icon(srna, ICON_TEXTURE_DATA);
+
+	rna_def_image_layer_common(srna);
+}
+
+static void rna_def_image_layers(BlenderRNA *brna, PropertyRNA *cprop)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	FunctionRNA *func;
+	PropertyRNA *parm;
+
+	RNA_def_property_srna(cprop, "ImageLayers");
+	srna= RNA_def_struct(brna, "ImageLayers", NULL);
+	RNA_def_struct_sdna(srna, "Image");
+	RNA_def_struct_ui_text(srna, "Image Layers", "Image layer");
+
+	prop= RNA_def_property(srna, "active_image_layer", PROP_POINTER, PROP_NONE);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_pointer_funcs(prop, "rna_Image_active_image_layer_get", 
+								   "rna_Image_active_image_layer_set", NULL, NULL);
+	RNA_def_property_flag(prop, PROP_EDITABLE|PROP_NEVER_NULL);
+	RNA_def_property_ui_text(prop, "Active Image Layer", "Active image layer");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+ 
+	prop= RNA_def_property(srna, "active_image_layer_index", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Act_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_active_image_layer_index_get", "rna_Image_active_image_layer_index_set", 
+							   "rna_Image_active_image_layer_index_range");
+	RNA_def_property_ui_text(prop, "Active Image Layer Index", "Index of active image layer slot");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "count_image_layers", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Count_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_count_image_layer_get", NULL, NULL);
+	RNA_def_property_ui_text(prop, "Total number of layers", "");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
 static void rna_def_image(BlenderRNA *brna)
 {
 	StructRNA *srna;
@@ -476,6 +663,14 @@
 	RNA_def_property_ui_text(prop, "Field Order", "Order of video fields (select which lines are displayed first)");
 	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
 	
+	/* Image Layers */
+ 	prop= RNA_def_property(srna, "image_layers", PROP_COLLECTION, PROP_NONE);
+	RNA_def_property_collection_sdna(prop, NULL, "imlayers", NULL);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_collection_funcs(prop, "rna_Image_layers_begin", "rna_iterator_listbase_next", "rna_iterator_listbase_end", "rna_iterator_listbase_get", 0, 0, 0, 0);
+	RNA_def_property_ui_text(prop, "Image Layers", "");
+	rna_def_image_layers(brna, prop);
+
 	/* booleans */
 	prop = RNA_def_property(srna, "use_fields", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "flag", IMA_FIELDS);
@@ -624,6 +819,7 @@
 
 void RNA_def_image(BlenderRNA *brna)
 {
+	rna_def_image_layer(brna);
 	rna_def_image(brna);
 	rna_def_imageuser(brna);
 }
Index: source/blender/makesrna/RNA_access.h
===================================================================
--- source/blender/makesrna/RNA_access.h	(revisione 44897)
+++ source/blender/makesrna/RNA_access.h	(copia locale)
@@ -257,6 +257,7 @@
 extern StructRNA RNA_ID;
 extern StructRNA RNA_IKParam;
 extern StructRNA RNA_Image;
+extern StructRNA RNA_ImageLayer;
 extern StructRNA RNA_ImageFormatSettings;
 extern StructRNA RNA_ImagePaint;
 extern StructRNA RNA_ImageSequence;
Index: release/scripts/startup/bl_ui/space_image.py
===================================================================
--- release/scripts/startup/bl_ui/space_image.py	(revisione 45659)
+++ release/scripts/startup/bl_ui/space_image.py	(copia locale)
@@ -117,11 +117,16 @@
         ima = sima.image
 
         layout.operator("image.new")
-        layout.operator("image.open")
+        layout.operator("image.open", text="Open Image").action = 'IMAGE'
+        
 
         show_render = sima.show_render
+        show_paint = sima.show_paint
 
         if ima:
+            if show_paint:
+                layout.operator("image.open", text="Open as Layer").action = 'LAYER'
+
             if not show_render:
                 layout.operator("image.replace")
                 layout.operator("image.reload")
@@ -160,6 +165,85 @@
             layout.separator()
 
 
+class IMAGE_MT_layers(Menu):
+    bl_label = "Layer"
+
+    def draw(self, context):
+        layout = self.layout
+
+        sima = context.space_data
+        ima = sima.image
+
+        layout.menu("IMAGE_MT_layers_new", icon='NEW')
+        # layout.operator("image.open")
+        layout.operator("image.image_layer_duplicate", icon='GHOST')
+        layout.operator("image.image_layer_clean", icon='FILE')
+        layout.menu("IMAGE_MT_layers_remove", icon='CANCEL')
+        layout.menu("IMAGE_MT_layers_merge", icon='LINK_AREA')
+        layout.separator()
+        layout.menu("IMAGE_MT_layers_select", icon='FILE_TICK')
+        layout.menu("IMAGE_MT_layers_order", icon='SORTALPHA')
+
+
+class IMAGE_MT_layers_new(Menu):
+    bl_label = "Add"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_add", icon='NEW')
+        layout.separator()
+        layout.operator("image.image_layer_add_above", icon='TRIA_UP')
+        layout.operator("image.image_layer_add_below", icon='TRIA_DOWN')
+
+
+class IMAGE_MT_layers_select(Menu):
+    bl_label = "Select"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_select", text="Select Previous Layer").action = 'PREVIOUS'
+        layout.operator("image.image_layer_select", text="Select Next Layer" ).action = 'NEXT'
+        layout.operator("image.image_layer_select", text="Select Top Layer").action = 'TOP'
+        layout.operator("image.image_layer_select", text="Select Bottom Layer").action = 'BOTTOM'
+
+
+class IMAGE_MT_layers_order(Menu):
+    bl_label = "Order"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_move", text="Layer the Top").type = 'TOP'
+        layout.operator("image.image_layer_move", text="Raise Layer", icon='TRIA_UP').type = 'UP'
+        layout.operator("image.image_layer_move", text="Lower Layer", icon='TRIA_DOWN').type = 'DOWN'
+        layout.operator("image.image_layer_move", text="Layer the Bottom").type = 'BOTTOM'
+        layout.separator()
+        layout.operator("image.image_layer_move", text="Invert").type = 'INVERT'
+
+
+class IMAGE_MT_layers_remove(Menu):
+    bl_label = "Remove"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_remove", text="Layer").action = 'SELECTED'
+        layout.operator("image.image_layer_remove", text="Hidden Layers" ).action = 'HIDDEN'
+
+
+class IMAGE_MT_layers_merge(Menu):
+    bl_label = "Merge"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_merge", text="Merge Down").type = 'DOWN'
+        layout.operator("image.image_layer_merge", text="Merge Visible" ).type = 'VISIBLE'
+        layout.operator("image.image_layer_merge", text="One Layer" ).type = 'ONE'
+
+
 class IMAGE_MT_image_invert(Menu):
     bl_label = "Invert"
 
@@ -355,7 +439,7 @@
         toolsettings = context.tool_settings
 
         show_render = sima.show_render
-        # show_paint = sima.show_paint
+        show_paint = sima.show_paint
         show_uvedit = sima.show_uvedit
 
         row = layout.row(align=True)
@@ -374,6 +458,9 @@
             else:
                 sub.menu("IMAGE_MT_image", text="Image")
 
+            if show_paint:
+                sub.menu("IMAGE_MT_layers", text="Layer")
+
             if show_uvedit:
                 sub.menu("IMAGE_MT_uvs")
 
@@ -647,6 +734,57 @@
             sub.row().prop(uvedit, "draw_stretch_type", expand=True)
 
 
+class IMAGE_PT_image_layers(Panel, ImagePaintPanel):
+    bl_label = "Image Layers"
+
+    @classmethod
+    def poll(cls, context):
+        sima = context.space_data
+        return sima.show_paint
+
+    def draw(self, context):
+        layout = self.layout
+        sima = context.space_data
+        ima = sima.image
+        layers = ima.image_layers
+
+        if ima:
+            row = layout.row()
+            row.template_list(ima, "image_layers", ima.image_layers, "active_image_layer_index", 
+                              rows=5, maxrows=5)
+
+            col = row.column(align=True)
+            col.operator("image.image_layer_add", text="", icon='NEW')
+            
+            if layers.active_image_layer:
+                col.operator("image.image_layer_duplicate", text="", icon='GHOST')
+                sub = col.column()
+                
+                if (layers.active_image_layer.type == 'BASE'):
+                    sub.enabled = False
+                else:
+                    sub.enabled = True
+                sub.operator("image.image_layer_remove", text="", icon='CANCEL').action = 'SELECTED'
+                col.operator("image.image_layer_move", text="", icon='TRIA_UP').type = 'UP'
+                col.operator("image.image_layer_move", text="", icon='TRIA_DOWN').type = 'DOWN'
+                split = layout.split(percentage=0.35)
+                col = split.column()
+                col.label(text="Name")
+                col.label(text="Opacity:")
+                col.label(text="Blend Modes:")
+                col = split.column()
+                col.prop(layers.active_image_layer, "name", text="")
+                sub = col.column()
+                if (((layers.active_image_layer.background != 'ALPHA') and 
+                    (layers.active_image_layer.type == 'BASE')) or
+                    (not layers.active_image_layer.visible)):
+                    sub.enabled = False
+                else:
+                    sub.enabled = True
+                sub.prop(layers.active_image_layer, "opacity", text="")
+                sub.prop(layers.active_image_layer, "blend_type", text="")
+
+
 class IMAGE_PT_paint(Panel, ImagePaintPanel):
     bl_space_type = 'IMAGE_EDITOR'
     bl_region_type = 'UI'
@@ -668,7 +806,7 @@
 
         if brush:
             col = layout.column()
-            col.template_color_wheel(brush, "color", value_slider=True)
+            col.template_color(brush, "color", value_slider=True)
             col.prop(brush, "color", text="")
 
             row = col.row(align=True)
Index: release/scripts/startup/bl_ui/space_userpref.py
===================================================================
--- release/scripts/startup/bl_ui/space_userpref.py	(revisione 45659)
+++ release/scripts/startup/bl_ui/space_userpref.py	(copia locale)
@@ -752,6 +752,88 @@
                 colsub = padding.column()
                 colsub = padding.column()
                 colsub.row().prop(ui, "show_colored_constraints")
+        elif theme.theme_area == 'IMAGE_EDITOR':
+            def theme_generic_recurse(data):
+                col.label(data.rna_type.name)
+                row = col.row()
+                subsplit = row.split(percentage=0.95)
+
+                padding1 = subsplit.split(percentage=0.15)
+                padding1.column()
+
+                subsplit = row.split(percentage=0.85)
+
+                padding2 = subsplit.split(percentage=0.15)
+                padding2.column()
+
+                colsub_pair = padding1.column(), padding2.column()
+
+                props_type = {}
+
+                for i, prop in enumerate(data.rna_type.properties):
+                    if prop.identifier == "rna_type":
+                        continue
+
+                    props_type.setdefault((prop.type, prop.subtype), []).append(prop)
+
+                for props_type, props_ls in sorted(props_type.items()):
+                    if props_type[0] == 'POINTER':
+                        for i, prop in enumerate(props_ls):
+                            theme_generic_recurse(getattr(data, prop.identifier))
+                    else:
+                        for i, prop in enumerate(props_ls):
+                            colsub_pair[i % 2].row().prop(data, prop.identifier)
+
+            data = getattr(theme, theme.theme_area.lower())
+            col = split.column()
+
+            ui = theme.image_editor
+            col.label(text="Theme Image Editor")
+
+            row = col.row()
+
+            subsplit = row.split(percentage=0.95)
+            padding = subsplit.split(percentage=0.15)
+            colsub = padding.column()
+            colsub = padding.column()
+            colsub.row().prop(ui, "editmesh_active")
+            colsub.row().prop(ui, "face_dot")
+            colsub.row().prop(ui, "scope_back")
+            colsub.row().prop(ui, "preview_stitch_edge")
+            colsub.row().prop(ui, "preview_stitch_stitchable")
+            colsub.row().prop(ui, "preview_stitch_vert")
+            colsub.row().prop(ui, "vertex_select")
+            colsub.row().prop(ui, "facedot_size")
+            colsub.row().prop(ui, "col1_boundary_layer")
+            colsub.row().prop(ui, "show_boundary_layer")
+
+            subsplit = row.split(percentage=0.85)
+            padding = subsplit.split(percentage=0.15)
+            colsub = padding.column()
+            colsub = padding.column()
+            colsub.row().prop(ui, "face")
+            colsub.row().prop(ui, "face_select")
+            colsub.row().prop(ui, "scope_back")
+            colsub.row().prop(ui, "preview_stitch_active")
+            colsub.row().prop(ui, "preview_stitch_face")
+            colsub.row().prop(ui, "preview_stitch_unstitchable")
+            colsub.row().prop(ui, "vertex")
+            colsub.row().prop(ui, "vertex_size")
+            colsub.row().prop(ui, "col2_boundary_layer")
+
+            props_type = {}
+
+            for i, prop in enumerate(data.rna_type.properties):
+                if prop.identifier == "rna_type":
+                    continue
+
+                props_type.setdefault((prop.type, prop.subtype), []).append(prop)
+
+            for props_type, props_ls in sorted(props_type.items()):
+                if props_type[0] == 'POINTER':
+                    for i, prop in enumerate(props_ls):
+                        theme_generic_recurse(getattr(data, prop.identifier))
+
         else:
             self._theme_generic(split, getattr(theme, theme.theme_area.lower()))
 
Index: release/scripts/startup/bl_ui/space_view3d_toolbar.py
===================================================================
--- release/scripts/startup/bl_ui/space_view3d_toolbar.py	(revisione 45659)
+++ release/scripts/startup/bl_ui/space_view3d_toolbar.py	(copia locale)
@@ -621,7 +621,7 @@
 
         elif context.image_paint_object and brush:
             col = layout.column()
-            col.template_color_wheel(brush, "color", value_slider=True)
+            col.template_color(brush, "color", value_slider=True)
             col.prop(brush, "color", text="")
 
             row = col.row(align=True)
@@ -665,7 +665,7 @@
         # Vertex Paint Mode #
         elif context.vertex_paint_object and brush:
             col = layout.column()
-            col.template_color_wheel(brush, "color", value_slider=True)
+            col.template_color(brush, "color", value_slider=True)
             col.prop(brush, "color", text="")
 
             row = col.row(align=True)
Index: source/blender/blenkernel/BKE_image.h
===================================================================
--- source/blender/blenkernel/BKE_image.h	(revisione 45659)
+++ source/blender/blenkernel/BKE_image.h	(copia locale)
@@ -130,6 +130,8 @@
 
 /* returns existing Image when filename/type is same (frame optional) */
 struct Image *BKE_add_image_file(const char *name);
+struct ImageLayer *BKE_add_image_file_as_layer(struct Image *ima, const char *name);
+struct ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4]);
 
 /* adds image, adds ibuf, generates color or pattern */
 struct Image *BKE_add_image_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4]);
Index: source/blender/blenkernel/BKE_layer.h
===================================================================
--- source/blender/blenkernel/BKE_layer.h	(revisione 0)
+++ source/blender/blenkernel/BKE_layer.h	(copia locale)
@@ -0,0 +1,98 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): ruesp83.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+ #ifndef __BKE_LAYER_H__
+#define __BKE_LAYER_H__
+
+/** \file BKE_layer.h
+ *  \ingroup bke
+ *  \since March 2012
+ *  \author ruesp83
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct Image;
+struct ImageLayer;
+struct ImBuf;
+
+/* call from library */
+
+struct ImageLayer *layer_alloc(struct Image *ima, const char *name);
+
+/* Removes all image layers from the image "ima" */
+void image_free_image_layers(struct Image *ima);
+ 
+/* Frees an image layer and associated memory */
+void free_image_layer(struct ImageLayer *layer);
+ 
+/* Removes the currently selected image layer */
+int image_remove_layer(struct Image *ima, const int action);
+
+/* Removes the currently selected image layer */
+struct ImageLayer *image_duplicate_current_image_layer(struct Image *ima);
+
+/* Adds another image layer and selects it */
+struct ImageLayer *image_add_image_layer(struct Image *ima, const char *name, int depth, float color[4], int order);
+
+/* Adds the base layer of images that points Image->ibufs.first */
+void image_add_image_layer_base(struct Image *ima);
+ 
+/* Returns the index of the currently selected image layer */
+short imalayer_get_current_act(struct Image *ima);
+short imalayer_get_index_layer(struct Image *ima, struct ImageLayer *iml);
+
+short imalayer_get_count(struct Image *ima);
+ 
+/* Selects the image layer with the number specified in "value" */
+void imalayer_set_current_act(struct Image *ima, short value);
+ 
+/* Returns the image layer that is currently selected */
+struct ImageLayer *imalayer_get_current(struct Image *ima);
+
+int imalayer_is_locked(struct Image *ima);
+ 
+/* Fills the current selected image layer with the color given */
+void imalayer_fill_color(struct Image *ima, float color[4]);
+
+void imalayer_unique_name(struct ImageLayer *iml, struct Image *ima);
+//void imalayer_unique_name(const struct ListBase *imlayers, struct ImageLayer *newlayer);
+
+struct ImBuf *imalayer_blend(struct ImBuf *base, struct ImBuf *layer, float opacity, short mode);
+
+struct ImageLayer *merge_layers(struct Image *ima, struct ImageLayer *iml, struct ImageLayer *iml_next);
+
+unsigned int IML_blend_color(unsigned int src1, unsigned int src2, int opacity, short mode);
+void IML_blend_color_float(float *dst, float *src1, float *src2, float opacity, short mode);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
Index: source/blender/blenkernel/CMakeLists.txt
===================================================================
--- source/blender/blenkernel/CMakeLists.txt	(revisione 45659)
+++ source/blender/blenkernel/CMakeLists.txt	(copia locale)
@@ -99,6 +99,7 @@
 	intern/key.c
 	intern/lamp.c
 	intern/lattice.c
+	intern/layer.c
 	intern/library.c
 	intern/material.c
 	intern/mball.c
@@ -185,6 +186,7 @@
 	BKE_key.h
 	BKE_lamp.h
 	BKE_lattice.h
+	BKE_layer.h
 	BKE_library.h
 	BKE_main.h
 	BKE_material.h
Index: source/blender/blenkernel/intern/icons.c
===================================================================
--- source/blender/blenkernel/intern/icons.c	(revisione 45659)
+++ source/blender/blenkernel/intern/icons.c	(copia locale)
@@ -193,9 +193,11 @@
 	else if (GS(id->name) == ID_IM) {
 		Image *img  = (Image*)id;
 		BKE_previewimg_free(&img->preview);
+	/*} else if (GS(id->name) == ID_IL) {
+		ImageLayer *iml  = (ImageLayer*)id;
+		BKE_previewimg_free(&iml->preview);*/
 	}
-	else if (GS(id->name) == ID_BR) {
-		Brush *br  = (Brush*)id;
+	else if (GS(id->name) == ID_BR) {		Brush *br  = (Brush*)id;
 		BKE_previewimg_free(&br->preview);
 	}
 }
@@ -228,6 +230,10 @@
 		Image *img  = (Image*)id;
 		if (!img->preview) img->preview = BKE_previewimg_create();
 		prv_img = img->preview;
+	/*} else if (GS(id->name) == ID_IL) {
+		ImageLayer *iml  = (ImageLayer*)id;
+		if (!iml->preview) iml->preview = BKE_previewimg_create();
+		prv_img = iml->preview;*/
 	}
 	else if (GS(id->name) == ID_BR) {
 		Brush *br  = (Brush*)id;
Index: source/blender/blenkernel/intern/image.c
===================================================================
--- source/blender/blenkernel/intern/image.c	(revisione 45659)
+++ source/blender/blenkernel/intern/image.c	(copia locale)
@@ -73,6 +73,7 @@
 #include "BKE_global.h"
 #include "BKE_icons.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
 #include "BKE_packedFile.h"
@@ -202,6 +203,7 @@
 {
 	int a;
 
+	image_free_image_layers(ima);
 	image_free_buffers(ima);
 	if (ima->packedfile) {
 		freePackedFile(ima->packedfile);
@@ -218,6 +220,7 @@
 			ima->renders[a]= NULL;
 		}
 	}
+	
 }
 
 /* only image block itself */
@@ -243,11 +246,21 @@
 /* get the ibuf from an image cache, local use here only */
 static ImBuf *image_get_ibuf(Image *ima, int index, int frame)
 {
+	/* unsigned int totsize= 0; */
+
 	/* this function is intended to be thread safe. with IMA_NO_INDEX this
 	 * should be OK, but when iterating over the list this is more tricky
 	 * */
-	if (index==IMA_NO_INDEX)
+	if (index==IMA_NO_INDEX) {
+		/* TODO: (kwk) This is an ugly hack to return always the active layer's ibuf */
+		ImageLayer *layer= imalayer_get_current(ima);
+		
+		if (layer && layer->ibufs.last)
+			return layer->ibufs.last;
+		
+		/* Only return "normal" image ibuf if no layer ibuf was found. */
 		return ima->ibufs.first;
+	}
 	else {
 		ImBuf *ibuf;
 
@@ -296,6 +309,12 @@
 		/* now we don't want copies? */
 		if (link && ibuf->index==link->index)
 			image_remove_ibuf(ima, link);
+
+		image_add_image_layer_base(ima);
+		if (strlen(ima->name) != 0) {
+			((ImageLayer *)ima->imlayers.last)->background = IMA_LAYER_BG_IMAGE;
+			strcpy(((ImageLayer *)ima->imlayers.last)->file_path, ima->name);
+		}
 	}
 }
 
@@ -560,8 +579,47 @@
 	return ima;
 }
 
-static ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4])
+ImageLayer *BKE_add_image_file_as_layer(Image *ima, const char *name)
 {
+	ImageLayer *iml, *layer_act;
+	int file, len;
+	const char *newname;
+	char str[FILE_MAX], strtest[FILE_MAX];
+	
+	BLI_strncpy(str, name, sizeof(str));
+	
+	/* exists? */
+	file= BLI_open(str, O_BINARY|O_RDONLY, 0);
+	if (file== -1) return NULL;
+	close(file);
+	
+	/* create a short library name */
+	len= strlen(name);
+	
+	while (len > 0 && name[len - 1] != '/' && name[len - 1] != '\\') len--;
+	newname= name+len;
+	
+	//iml = image_add_image_layer(ima, newname, alpha ? 32 : 24, color, 2);
+	
+	layer_act = imalayer_get_current(ima);
+	layer_act->select = !IMA_LAYER_SEL_CURRENT;
+	
+	iml = layer_alloc(ima, newname);
+	if (iml) {
+
+		BLI_addhead(&ima->imlayers, iml);
+		ima->Act_Layers = 0;
+		ima->Count_Layers += 1;
+
+		//if (color[3] == 1.0f)
+		//	im_l->background = IMA_LAYER_BG_RGB;
+		//copy_v4_v4(im_l->default_color, color)
+	}
+	return iml;
+}
+
+ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4])
+{
 	ImBuf *ibuf;
 	unsigned char *rect= NULL;
 	float *rect_float= NULL;
@@ -609,7 +667,7 @@
 		
 		ibuf= add_ibuf_size(width, height, ima->name, depth, floatbuf, uvtestgrid, color);
 		image_assign_ibuf(ima, ibuf, IMA_NO_INDEX, 0);
-		
+
 		ima->ok= IMA_OK_LOADED;
 	}
 
Index: source/blender/blenkernel/intern/layer.c
===================================================================
--- source/blender/blenkernel/intern/layer.c	(revisione 0)
+++ source/blender/blenkernel/intern/layer.c	(copia locale)
@@ -0,0 +1,877 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * Contributor(s): Blender Foundation, 2006, full recode
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/blenkernel/intern/layer.c
+ *  \ingroup bke
+ */
+ 
+#include <stdio.h>
+#include <string.h>
+
+#include "MEM_guardedalloc.h"
+#include "IMB_imbuf_types.h"
+#include "IMB_imbuf.h"
+
+#include "DNA_userdef_types.h"
+
+#include "BLI_blenlib.h"
+#include "BLI_utildefines.h"
+#include "BLI_math_base.h"
+
+//#include "BKE_icons.h"
+//#include "BKE_global.h"
+#include "BKE_image.h"
+#include "BKE_layer.h"
+//#include "BKE_library.h"
+
+ 
+ImageLayer *layer_alloc(Image *ima, const char *name)
+{
+	ImageLayer *im_l;
+	
+	im_l = (ImageLayer*) MEM_callocN(sizeof(ImageLayer), "image_layer");
+	if(im_l) {
+		strcpy(im_l->name, name);
+		imalayer_unique_name(im_l, ima);
+		im_l->next = im_l->prev = NULL;
+
+		im_l->background = IMA_LAYER_BG_ALPHA;
+		im_l->color_space = IMA_LAYER_COL_RGB;
+		im_l->opacity = 1.0f;
+		im_l->mode = IMA_LAYER_NORMAL;
+		im_l->type = IMA_LAYER_LAYER;
+		im_l->visible = IMA_LAYER_VISIBLE;
+		im_l->select = IMA_LAYER_SEL_CURRENT;
+	}
+	return im_l;
+}
+
+void image_free_image_layers(struct Image *ima)
+{
+	ImageLayer *img_lay, *next;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima->imlayers.first == NULL)
+		return;
+
+	ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+	while((img_lay=ima->imlayers.first)) {
+		BLI_remlink(&ima->imlayers, img_lay);
+		free_image_layer(img_lay);
+	}
+
+	ima->Count_Layers = 0;
+	BKE_image_release_ibuf(ima, lock);
+}
+ 
+void free_image_layer(ImageLayer *layer)
+{
+	ImBuf *ibuf, *next;
+ 
+	if (!layer)
+		return;
+
+	while((ibuf = layer->ibufs.first)) {
+		BLI_remlink(&layer->ibufs, ibuf);
+ 
+		if (ibuf->userdata) {
+			MEM_freeN(ibuf->userdata);
+			ibuf->userdata = NULL;
+		}
+ 
+		IMB_freeImBuf(ibuf);
+	}
+
+	MEM_freeN(layer);
+}
+ 
+ImageLayer *imalayer_get_current(Image *ima)
+{
+	ImageLayer *layer;
+	if(ima == NULL)
+		return 0;
+ 
+	for(layer=ima->imlayers.last; layer; layer=layer->prev){
+		if(layer->select & IMA_LAYER_SEL_CURRENT)
+			return layer;
+	}
+ 
+	return NULL;
+}
+
+short imalayer_get_count(Image *ima)
+{
+	if(ima == NULL)
+		return 0;
+ 
+	return ima->Count_Layers;
+}
+
+short imalayer_get_current_act(Image *ima)
+{
+	if(ima == NULL)
+		return 0;
+ 
+	return ima->Act_Layers;
+}
+
+short imalayer_get_index_layer(struct Image *ima, struct ImageLayer *iml)
+{
+	ImageLayer *layer;
+	short i;
+ 
+	if(ima == NULL)
+		return -1;
+
+	for(layer=ima->imlayers.last, i = BLI_countlist(&ima->imlayers)-1; layer; layer=layer->prev, i--)
+		if(layer == iml)
+			return i;
+
+	return -1;
+}
+ 
+void imalayer_set_current_act(Image *ima, short index)
+{
+	ImageLayer *layer;
+	short i;
+ 
+	if(ima == NULL)
+		return;
+
+	for(layer=ima->imlayers.last, i = BLI_countlist(&ima->imlayers)-1; layer; layer=layer->prev, i--) {
+		if(i == index) {
+			layer->select = IMA_LAYER_SEL_CURRENT;
+			ima->Act_Layers = i;
+		}
+		else
+			layer->select = !IMA_LAYER_SEL_CURRENT;
+	}
+}
+
+int imalayer_is_locked(struct Image *ima)
+{
+	ImageLayer *layer= NULL;
+
+	layer = imalayer_get_current(ima);
+
+	return layer->lock;
+}
+
+void imalayer_fill_color(struct Image *ima, float color[4])
+{
+	ImageLayer *layer= NULL;
+	ImBuf *ibuf= NULL;
+	unsigned char *rect= NULL;
+	float *rect_float= NULL;
+	void *lock;
+ 
+	if (ima==NULL)
+		return;
+ 
+	layer = imalayer_get_current(ima);
+	
+	//ibuf = BKE_image_acquire_ibuf(ima, NULL, &lock);
+
+	ibuf = (ImBuf*)((ImageLayer*)layer->ibufs.first);
+	if (ibuf) {
+		if (ibuf->flags & IB_rectfloat) {
+			rect_float= (float*)ibuf->rect_float;
+		}
+		else {
+			rect= (unsigned char*)ibuf->rect;
+		}
+ 
+		BKE_image_buf_fill_color(rect, rect_float, ibuf->x, ibuf->y, color);
+	}
+ 
+	//BKE_image_release_ibuf(ima, lock);
+}
+
+ImageLayer *image_duplicate_current_image_layer(Image *ima)
+{
+	ImageLayer *layer = NULL, *im_l = NULL;
+	char dup_name[sizeof(layer->name)];
+	ImBuf *ibuf, *new_ibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return NULL;
+ 
+	layer = imalayer_get_current(ima);
+
+	if(!strstr(layer->name, "_copy")) {
+		BLI_snprintf(dup_name, sizeof(dup_name), "%s_copy", layer->name);
+	}
+	else {
+		BLI_snprintf(dup_name, sizeof(dup_name), "%s", layer->name);
+	}
+
+	im_l = layer_alloc(ima, dup_name);
+	if (im_l) {
+		ibuf= (ImBuf*)((ImageLayer*)layer->ibufs.first);
+		if (ibuf) {
+			new_ibuf = IMB_dupImBuf(ibuf);
+			BLI_addtail(&im_l->ibufs, new_ibuf);
+
+			im_l->next = im_l->prev = NULL;
+			if (layer) {
+				BLI_insertlinkbefore(&ima->imlayers, layer, im_l);
+			}
+			else {
+				BLI_addhead(&ima->imlayers, layer);
+			}
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+
+			im_l->background = layer->background;
+			im_l->color_space = layer->color_space;
+			copy_v4_v4(im_l->default_color, layer->default_color);
+			strcpy(im_l->file_path, layer->file_path);
+			im_l->lock = layer->lock;
+			im_l->mode = layer->mode;
+			im_l->opacity = layer->opacity;
+			im_l->type = IMA_LAYER_LAYER;
+			im_l->visible = layer->visible;
+		}
+		ima->Count_Layers += 1;
+	}
+	return im_l;
+}
+ 
+int image_remove_layer(Image *ima, const int action)
+{
+	ImageLayer *layer= NULL;
+	 
+	if (ima==NULL)
+		return FALSE;
+ 
+	if (action & IMA_LAYER_DEL_SELECTED) {
+		layer = imalayer_get_current(ima);
+
+		if (layer) {
+			BLI_remlink(&ima->imlayers, layer);
+			free_image_layer(layer);
+		}
+		/* Ensure the first element in list gets selected (if any) */
+		if (ima->imlayers.first) {
+			if (imalayer_get_current_act(ima) != 1)
+				imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+			else
+				imalayer_set_current_act(ima, imalayer_get_current_act(ima)-1);
+		}
+		ima->Count_Layers -= 1;
+	}
+	else {
+		for (layer=ima->imlayers.last; layer; layer=layer->prev){
+			if (!(layer->visible & IMA_LAYER_VISIBLE)) {
+				BLI_remlink(&ima->imlayers, layer);
+				free_image_layer(layer);
+				if (ima->imlayers.first) {
+					if (imalayer_get_current_act(ima) != 1)
+						imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+					else
+						imalayer_set_current_act(ima, imalayer_get_current_act(ima)-1);
+				}
+				ima->Count_Layers -= 1;
+			}
+		}
+	}
+	return TRUE;
+}
+
+static char blend_normal(const char B, const char L, float O)
+{	
+	return (char)(O * (L) + (1.0f - O) * B);
+}
+
+static char blend_lighten(const char B, const char L, float O)
+{	
+	return (char)(O * ((L > B) ? L : B) + (1.0f - O) * B);
+}
+
+static char blend_darken(const char B, const char L, float O)
+{	
+	return (char)(O * ((L > B) ? B : L) + (1.0f - O) * B);
+}
+
+static char blend_multiply(const char B, const char L, float O)
+{	
+	return (char)(O * ((B * L) / 255) + (1.0f - O) * B);
+}
+
+static char blend_average(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L) / 2) + (1.0f - O) * B);
+}
+
+static char blend_add(const char B, const char L, float O)
+{	
+	return (char)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static char blend_subtract(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static char blend_difference(const char B, const char L, float O)
+{	
+	return (char)(O * (abs(B - L)) + (1.0f - O) * B);
+}
+
+static char blend_negation(const char B, const char L, float O)
+{	
+	return (char)(O * (255 - abs(255 - B - L)) + (1.0f - O) * B);
+}
+
+static char blend_screen(const char B, const char L, float O)
+{	
+	return (char)(O * (255 - (((255 - B) * (255 - L)) >> 8)) + (1.0f - O) * B);
+}
+
+static char blend_exclusion(const char B, const char L, float O)
+{	
+	return (char)(O * (B + L - 2 * B * L / 255) + (1.0f - O) * B);
+}
+
+static char blend_overlay(const char B, const char L, float O)
+{	
+	return (char)(O * ((L < 128) ? (2 * B * L / 255) : (255 - 2 * (255 - B) * (255 - L) / 255)) + (1.0f - O) * B);
+}
+
+static char blend_soft_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((L < 128) ? (2 * ((B >> 1) + 64)) * ((float)L / 255) : (255 - (2 * (255 - ((B >> 1) + 64)) * (float)(255 - L) / 255))) + (1.0f - O) * B);
+}
+
+static char blend_hard_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((B < 128) ? (2 * L * B / 255) : (255 - 2 * (255 - L) * (255 - B) / 255)) + (1.0f - O) * B);
+}
+
+static char blend_color_dodge(const char B, const char L, float O)
+{	
+	return (char)(O * ((L == 255) ? L : MIN2(255, ((B << 8 ) / (255 - L)))) + (1.0f - O) * B);
+}
+
+static char blend_color_burn(const char B, const char L, float O)
+{	
+	return (char)(O * ((L == 0) ? L : MAX2(0, (255 - ((255 - B) << 8 ) / L))) + (1.0f - O) * B);
+}
+
+static char blend_linear_dodge(const char B, const char L, float O)
+{	
+	return (char)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static char blend_linear_burn(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static char blend_linear_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((2 * L) < 128) ? ((B + (2 * L) < 255) ? 0 : (B + (2 * L) - 255)) : (MIN2(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static char blend_vivid_light(const char B, const char L, float O)
+{	
+	return (char)(O * (L < 128) ? (((2 * L) == 0) ? (2 * L) : MAX2(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (MIN2(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static char blend_pin_light(const char B, const char L, float O)
+{	
+	return (char)(O * (L < 128) ? (((2 * L) > B) ? B : (2 * L)) : (((2 * (L - 128)) > B) ? (2 * (L - 128)) : B) + (1.0f - O) * B);
+}
+
+static char blend_hard_mix(const char B, const char L, float O)
+{	
+	return (char)(O * (((L < 128) ? (((2 * L) == 0) ? (2 * L) : MAX2(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (MIN2(255, (B + (2 * (L - 128))))) < 128) ? 0 : 255) + (1.0f - O) * B);
+}
+
+/*static float blend_normal_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L) + (1.0f - O) * B);
+}
+
+static float blend_lighten_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L > B) ? L : B) + (1.0f - O) * B);
+}
+
+static float blend_darken_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L > B) ? B : L) + (1.0f - O) * B);
+}
+
+static float blend_multiply_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B * L) / 255) + (1.0f - O) * B);
+}
+
+static float blend_average_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L) / 2) + (1.0f - O) * B);
+}
+
+static float blend_add_f(const float B, const float L, float O)
+{	
+	return (float)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static float blend_subtract_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_difference_f(const float B, const float L, float O)
+{	
+	return (float)(O * (abs(B - L)) + (1.0f - O) * B);
+}
+
+static float blend_negation_f(const float B, const float L, float O)
+{	
+	return (float)(O * (255 - abs(255 - B - L)) + (1.0f - O) * B);
+}
+
+static float blend_screen_f(const float B, const float L, float O)
+{	
+	return (float)(O * (255 - (FTOCHAR((255 - B) * (255 - L)) >> 8)) + (1.0f - O) * B);
+}
+
+static float blend_exclusion_f(const float B, const float L, float O)
+{	
+	return (float)(O * (B + L - 2 * B * L / 255) + (1.0f - O) * B);
+}
+
+static float blend_overlay_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L < 128) ? (2 * B * L / 255) : (255 - 2 * (255 - B) * (255 - L) / 255)) + (1.0f - O) * B);
+}
+
+static float blend_soft_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L < 128) ? (2 * ((B >> 1) + 64)) * ((float)L / 255) : (255 - (2 * (255 - ((B >> 1) + 64)) * (float)(255 - L) / 255))) + (1.0f - O) * B);
+}
+
+static float blend_hard_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B < 128) ? (2 * L * B / 255) : (255 - 2 * (255 - L) * (255 - B) / 255)) + (1.0f - O) * B);
+}
+
+static float blend_color_dodge_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L == 255) ? L : minf(255, ((B << 8 ) / (255 - L)))) + (1.0f - O) * B);
+}
+
+static float blend_color_burn_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L == 0) ? L : maxf(0, (255 - ((255 - B) << 8 ) / L))) + (1.0f - O) * B);
+}
+
+static float blend_linear_dodge_f(const float B, const float L, float O)
+{	
+	return (float)(O * (minf(255, (B + L))) + (1.0f - O) * B);
+}
+
+static float blend_linear_burn_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_linear_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((2 * L) < 128) ? ((B + (2 * L) < 255) ? 0 : (B + (2 * L) - 255)) : (minf(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static float blend_vivid_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L < 128) ? (((2 * L) == 0) ? (2 * L) : maxf(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (minf(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static float blend_pin_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L < 128) ? (((2 * L) > B) ? B : (2 * L)) : (((2 * (L - 128)) > B) ? (2 * (L - 128)) : B) + (1.0f - O) * B);
+}
+
+static float blend_hard_mix_f(const float B, const float L, float O)
+{	
+	return (float)(O * (((L < 128) ? (((2 * L) == 0) ? (2 * L) : maxf(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (minf(255, (B + (2 * (L - 128))))) < 128) ? 0 : 255) + (1.0f - O) * B);
+}*/
+
+/*static float blend_normal_f(const float B, const float L, const float O)
+{	
+	return (char)(O * (L) + (1.0f - O) * B);
+}
+
+static float blend_multiply_f(const float B, const float L, const float O)
+{	
+	return (float)(O * ((B * L) / 1.0f) + (1.0f - O) * B);
+}
+
+static float blend_subtract_f(const float B, const float L, const float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_difference_f(const float B, const float L, const float O)
+{	
+	return (float)(O * (fabs(B - L)) + (1.0f - O) * B);
+}
+
+static float blend_overlay_f(float B, float L, float O)
+{	
+	return (float)(O * ((L < 0.5f) ? (2 * B * L / 1.0f) : (1.0f - 2 * (1.0f - B) * (1.0f - L) / 1.0f)) + (1.0f - O) * B);
+}*/
+
+static char pixel_is_transparent(const char pix[4])
+{	
+	if ((pix[0] == 0) && (pix[1] == 0) && (pix[2] == 0) && (pix[3] == 0))
+		return 1;
+	return 0;
+}
+
+ImBuf *imalayer_blend(ImBuf *base, ImBuf *layer, float opacity, short mode)
+{
+	ImBuf *dest;
+	int i, y;
+	int bg_x, bg_y, diff_x;
+	//float (*blend_callback_f)(const float B, const float L, const float O) = NULL;	//Mode callback
+	char (*blend_callback)(const char B, const char L, const float O) = NULL;		//Mode callback
+	
+	if (!base)
+		return IMB_dupImBuf(layer);
+
+	dest = IMB_dupImBuf(base);
+
+	if (opacity == 0.0f)
+		return dest;
+
+	bg_x = base->x;
+	bg_y = base->y;
+	if (base->x > layer->x)
+		bg_x = layer->x;
+	if (base->y > layer->y)
+		bg_y = layer->y;
+	
+	diff_x = abs(base->x - layer->x);
+
+	switch(mode) {
+	case IMA_LAYER_NORMAL:
+		blend_callback = blend_normal;
+		break;
+
+	case IMA_LAYER_MULTIPLY:
+		blend_callback = blend_multiply;
+		break;
+
+	case IMA_LAYER_SCREEN:
+		blend_callback = blend_screen;
+		break;
+
+	case IMA_LAYER_OVERLAY:
+		blend_callback = blend_overlay;
+		break;
+
+	case IMA_LAYER_SOFT_LIGHT:
+		blend_callback = blend_soft_light;
+		break;
+
+	case IMA_LAYER_HARD_LIGHT:
+		blend_callback = blend_hard_light;
+		break;
+
+	case IMA_LAYER_COLOR_DODGE:
+		blend_callback = blend_color_dodge;
+		break;
+
+	case IMA_LAYER_LINEAR_DODGE:
+		blend_callback = blend_linear_dodge;
+		break;
+		
+	case IMA_LAYER_COLOR_BURN:
+		blend_callback = blend_color_burn;
+		break;
+
+	case IMA_LAYER_LINEAR_BURN:
+		blend_callback = blend_linear_burn;
+		break;
+
+	case IMA_LAYER_AVERAGE: 
+		blend_callback = blend_average;
+		break;       
+
+	case IMA_LAYER_ADD: 
+		blend_callback = blend_add;
+		break;
+
+	case IMA_LAYER_SUBTRACT: 
+		blend_callback = blend_subtract;
+		break;       
+
+	case IMA_LAYER_DIFFERENCE: 
+		blend_callback = blend_difference;
+		break;
+	
+	case IMA_LAYER_LIGHTEN: 
+		blend_callback = blend_lighten;
+		break;       
+
+	case IMA_LAYER_DARKEN: 
+		blend_callback = blend_darken;
+		break;
+	
+	case IMA_LAYER_NEGATION: 
+		blend_callback = blend_negation;
+		break;       
+
+	case IMA_LAYER_EXCLUSION: 
+		blend_callback = blend_exclusion;
+		break;
+	
+	case IMA_LAYER_LINEAR_LIGHT: 
+		blend_callback = blend_linear_light;
+		break;       
+
+	case IMA_LAYER_VIVID_LIGHT: 
+		blend_callback = blend_vivid_light;
+		break;
+	
+	case IMA_LAYER_PIN_LIGHT: 
+		blend_callback = blend_pin_light;
+		break;       
+
+	case IMA_LAYER_HARD_MIX: 
+		blend_callback = blend_hard_mix;
+		break;
+	}
+
+	if (base->rect_float) {
+		
+		float *fp_b = (float *) base->rect_float;
+		float *fp_l = (float *) layer->rect_float;
+		float *fp_d = (float *) dest->rect_float;
+		for( i = bg_x * bg_y; i > 0; i--, fp_b+=4, fp_l+=4, fp_d+=4 ) {
+			if (fp_l[3] != 0.0f) {
+				fp_d[0] = (float) blend_callback(FTOCHAR(fp_b[0]), FTOCHAR(fp_l[0]), opacity) / 255.0f;
+				fp_d[1] = (float) blend_callback(FTOCHAR(fp_b[1]), FTOCHAR(fp_l[1]), opacity) / 255.0f;
+				fp_d[2] = (float) blend_callback(FTOCHAR(fp_b[2]), FTOCHAR(fp_l[2]), opacity) / 255.0f;
+			}
+		}
+
+		if(base->rect) {
+			IMB_rect_from_float(base);
+		}
+	}
+	else if(base->rect) {
+		
+		char *cp_b = (char *) base->rect;
+		char *cp_l = (char *) layer->rect;
+		char *cp_d = (char *) dest->rect;
+		for( i = bg_x * bg_y; i > 0; i--) {
+			if ((!(pixel_is_transparent(cp_b))) && (!(pixel_is_transparent(cp_l)))) {
+				if ((cp_l[3] == 255) && (cp_b[3] == 255)) {
+					cp_d[0] = blend_callback(cp_b[0], cp_l[0], opacity);
+					cp_d[1] = blend_callback(cp_b[1], cp_l[1], opacity);
+					cp_d[2] = blend_callback(cp_b[2], cp_l[2], opacity);
+				}
+				else if ((cp_l[3] != 255) || (cp_b[3] != 255)) {
+					cp_d[0] = blend_callback(cp_b[0], cp_l[0], opacity);
+					cp_d[1] = blend_callback(cp_b[1], cp_l[1], opacity);
+					cp_d[2] = blend_callback(cp_b[2], cp_l[2], opacity);
+					/*if ((cp_b[3] != 0) && (cp_l[3] != 0))*/
+						cp_d[3] = blend_callback(cp_b[3], cp_l[3], opacity);
+				}
+				else if (cp_l[3] != 0) {
+					cp_d[0] = cp_l[0];
+					cp_d[1] = cp_l[1];
+					cp_d[2] = cp_l[2];
+					cp_d[3] = cp_l[3];
+				}
+				else {
+					cp_d[0] = cp_b[0];
+					cp_d[1] = cp_b[1];
+					cp_d[2] = cp_b[2];
+					cp_d[3] = cp_b[3];
+				}
+			}
+			if (((i % bg_x) == 0) && (i != (bg_x * bg_y))) {
+				if (base->x > layer->x) {
+					cp_b = cp_b + diff_x*4;
+					cp_d = cp_d + diff_x*4;
+				}
+				else
+					cp_l = cp_l + diff_x*4;
+			}
+			cp_b+=4;
+			cp_l+=4; 
+			cp_d+=4;
+		}
+	}
+
+	return dest;
+}
+
+struct ImageLayer *merge_layers(Image *ima, ImageLayer *iml, ImageLayer *iml_next)
+{
+	ImBuf *ibuf, *result_ibuf;
+	 /* merge layers */
+	result_ibuf = imalayer_blend((ImBuf*)((ImageLayer*)iml_next->ibufs.first), (ImBuf*)((ImageLayer*)iml->ibufs.first), iml->opacity, iml->mode);
+	
+	iml_next->background = IMA_LAYER_BG_RGB;
+	iml_next->file_path[0] = '\0';
+	iml_next->default_color[0] = -1;
+	iml_next->default_color[1] = -1;
+	iml_next->default_color[2] = -1;
+	iml_next->default_color[3] = -1;
+
+	/* Delete old ibuf*/
+	ibuf = (ImBuf *)iml_next->ibufs.first;
+	BLI_remlink(&iml_next->ibufs, ibuf);
+ 
+	if (ibuf->userdata) {
+		MEM_freeN(ibuf->userdata);
+		ibuf->userdata = NULL;
+	}
+ 	IMB_freeImBuf(ibuf);
+
+	/* add new ibuf */
+	BLI_addtail(&iml_next->ibufs, result_ibuf);
+
+	/* delete the layer merge */
+	BLI_remlink(&ima->imlayers, iml);
+	free_image_layer(iml);
+	
+	return iml_next;
+}
+
+static int imlayer_find_name_dupe(const char *name, ImageLayer *iml, Image *ima)
+{
+	ImageLayer *layer;
+
+	for (layer = ima->imlayers.last; layer; layer=layer->prev) {
+		if (iml!=layer) {
+			if (!strcmp(layer->name, name)) {
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int imlayer_unique_check(void *arg, const char *name)
+{
+	struct {Image *ima; void *iml;} *data= arg;
+	return imlayer_find_name_dupe(name, data->iml, data->ima);
+}
+
+void imalayer_unique_name(ImageLayer *iml, Image *ima)
+{
+	struct {Image *ima; void *iml;} data;
+	data.ima = ima;
+	data.iml = iml;
+
+	BLI_uniquename_cb(imlayer_unique_check, &data, "Layer", '.', iml->name, sizeof(iml->name));
+}
+
+ImageLayer *image_add_image_layer(Image *ima, const char *name, int depth, float color[4], int order)
+{
+	ImageLayer *layer, *layer_act, *im_l = NULL;
+	ImBuf *ibuf, *imaibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return NULL;
+
+ 	layer_act = imalayer_get_current(ima);
+
+	/* Deselect other layers */
+	/*for(layer = ima->imlayers.first; layer; layer=layer->next)
+		layer->select = !IMA_LAYER_SEL_CURRENT;*/
+	layer_act->select = !IMA_LAYER_SEL_CURRENT;
+	
+	im_l = layer_alloc(ima, name);
+	if (im_l) {
+		ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 
+		imaibuf = (ImBuf*)ima->ibufs.first;
+		ibuf = add_ibuf_size(imaibuf->x, imaibuf->y, im_l->name, depth, ima->gen_flag, 0, color);
+		BLI_addtail(&im_l->ibufs, ibuf);
+		if (order == 2) { /*Head*/
+			BLI_addhead(&ima->imlayers, im_l);
+			ima->Act_Layers = 0;
+		}
+		else if (order == -1) { /*Before*/
+			/* Layer Act
+			 * --> Add Layer
+			 */
+			BLI_insertlinkafter(&ima->imlayers, layer_act , im_l);
+			ima->Act_Layers += 1;
+			imalayer_set_current_act(ima, ima->Act_Layers);
+		}
+		else { /*After*/
+			/* --> Add Layer
+			 * Layer Act
+			 */
+			BLI_insertlinkbefore(&ima->imlayers, layer_act , im_l);
+			//ima->Act_Layers -= 1;
+			imalayer_set_current_act(ima, ima->Act_Layers);
+		}
+		ima->Count_Layers += 1;
+
+		if (color[3] == 1.0f)
+			im_l->background = IMA_LAYER_BG_RGB;
+		copy_v4_v4(im_l->default_color, color);
+		BKE_image_release_ibuf(ima, lock);
+	}
+ 
+	return im_l;
+}
+ 
+/* TODO: (kwk) Base image layer needs proper locking... */
+void image_add_image_layer_base(Image *ima)
+{
+	ImageLayer *im_l = NULL;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima) {
+		im_l = layer_alloc(ima, "Background");
+		if (im_l) {	
+			ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 			im_l->type = IMA_LAYER_BASE; /* BASE causes no free on deletion of layer */
+			ima->Act_Layers = 0;
+			ima->Count_Layers = 1;
+			/* Get ImBuf from ima */
+			ibuf = IMB_dupImBuf((ImBuf*)ima->ibufs.first);
+			BLI_addtail(&im_l->ibufs, ibuf);
+			BLI_addhead(&ima->imlayers, im_l);
+ 
+			BKE_image_release_ibuf(ima, lock);
+		}
+	}
+}
+
Index: source/blender/blenkernel/intern/library.c
===================================================================
--- source/blender/blenkernel/intern/library.c	(revisione 45659)
+++ source/blender/blenkernel/intern/library.c	(copia locale)
@@ -617,6 +617,9 @@
 		case ID_IM:
 			id= MEM_callocN(sizeof(Image), "image");
 			break;
+		/*case ID_IL:
+			id= MEM_callocN(sizeof(ImageLayer), "imagelayer");
+			break;*/
 		case ID_LT:
 			id= MEM_callocN(sizeof(Lattice), "latt");
 			break;
Index: source/blender/blenloader/intern/readfile.c
===================================================================
--- source/blender/blenloader/intern/readfile.c	(revisione 45659)
+++ source/blender/blenloader/intern/readfile.c	(copia locale)
@@ -3002,13 +3002,45 @@
 	lb->last= prev;
 }
 
+static void link_imalayers_list(FileData *fd, ListBase *lb)
+{
+	Link *ln, *prev;
+	ImageLayer *layer;
+	
+	if(lb->first==NULL) return;
+	
+	lb->first = newimaadr(fd, lb->first);
+	printf("1\n");
+	ln = lb->first;
+	printf("2\n");
+	layer = (ImageLayer*)ln;
+	printf("3\n");
+	if (layer->name)
+		printf("Name=%s\n", layer->name);
+	else{
+		printf("4\n");
+		printf("Opacity=%d\n", layer->opacity);
+	}
+	prev= NULL;
+	while(ln) {
+		ln->next = newimaadr(fd, ln->next);
+		ln->prev = prev;
+		prev = ln;
+		layer = (ImageLayer*)ln;
+		printf("Name=%s\n", layer->name);
+		link_ibuf_list(fd, &layer->ibufs);
+		ln = ln->next;
+	}
+	lb->last= prev;
+}
+
 static void direct_link_image(FileData *fd, Image *ima)
 {
 	/* for undo system, pointers could be restored */
 	if (fd->imamap)
 		link_ibuf_list(fd, &ima->ibufs);
 	else
-		ima->ibufs.first= ima->ibufs.last= NULL;
+		ima->ibufs.first = ima->ibufs.last = NULL;
 	
 	/* if not restored, we keep the binded opengl index */
 	if (ima->ibufs.first==NULL) {
@@ -3016,6 +3048,7 @@
 		ima->gputexture= NULL;
 	}
 	
+	
 	ima->anim= NULL;
 	ima->rr= NULL;
 	ima->repbind= NULL;
@@ -3035,6 +3068,10 @@
 	ima->packedfile = direct_link_packedfile(fd, ima->packedfile);
 	ima->preview = direct_link_preview_image(fd, ima->preview);
 	ima->ok= 1;
+	if (ima->imlayers.first)
+		link_imalayers_list(fd, &ima->imlayers);
+	else
+		ima->imlayers.first = ima->imlayers.last = NULL;
 }
 
 
Index: source/blender/blenloader/intern/writefile.c
===================================================================
--- source/blender/blenloader/intern/writefile.c	(revisione 45659)
+++ source/blender/blenloader/intern/writefile.c	(copia locale)
@@ -1887,8 +1887,8 @@
 {
 	Image *ima;
 	PackedFile * pf;
+	ImageLayer *iml;
 
-
 	ima= idbase->first;
 	while (ima) {
 		if (ima->id.us>0 || wd->current) {
@@ -1902,6 +1902,13 @@
 				writedata(wd, DATA, pf->size, pf->data);
 			}
 
+			if (ima->imlayers.first) {
+				iml = ima->imlayers.first;
+				while(iml) {
+					writestruct(wd, DATA, "ImageLayer", 1, iml);
+					iml= iml->next;
+				}
+			}
 			write_previews(wd, ima->preview);
 		}
 		ima= ima->id.next;
Index: source/blender/editors/include/BIF_glutil.h
===================================================================
--- source/blender/editors/include/BIF_glutil.h	(revisione 45659)
+++ source/blender/editors/include/BIF_glutil.h	(copia locale)
@@ -39,7 +39,7 @@
 void sdrawline(short x1, short y1, short x2, short y2);
 void sdrawtri(short x1, short y1, short x2, short y2);
 void sdrawtrifill(short x1, short y1, short x2, short y2);
-void sdrawbox(short x1, short y1, short x2, short y2);
+void sdrawbox(int x1, int y1, int x2, int y2);
 
 void sdrawXORline(int x0, int y0, int x1, int y1);
 void sdrawXORline4(int nr, int x0, int y0, int x1, int y1);
Index: source/blender/editors/include/ED_image.h
===================================================================
--- source/blender/editors/include/ED_image.h	(revisione 45659)
+++ source/blender/editors/include/ED_image.h	(copia locale)
@@ -68,7 +68,7 @@
 void ED_image_update_frame(const struct Main *mainp, int cfra);
 
 void ED_image_draw_info(struct ARegion *ar, int color_manage, int channels, int x, int y,
-                        const unsigned char cp[4], const float fp[4], int *zp, float *zpf);
+                        const unsigned char cp[4], const float fp[4], int *zp, float *zpf, const char type);
 
 #endif /* __ED_IMAGE_H__ */
 
Index: source/blender/editors/include/UI_interface.h
===================================================================
--- source/blender/editors/include/UI_interface.h	(revisione 45659)
+++ source/blender/editors/include/UI_interface.h	(copia locale)
@@ -752,6 +752,7 @@
 void uiTemplateVectorscope(uiLayout *layout, struct PointerRNA *ptr, const char *propname);
 void uiTemplateCurveMapping(uiLayout *layout, struct PointerRNA *ptr, const char *propname, int type, int levels, int brush);
 void uiTemplateColorWheel(uiLayout *layout, struct PointerRNA *ptr, const char *propname, int value_slider, int lock, int lock_luminosity, int cubic);
+void uiTemplateColor(uiLayout *layout, struct PointerRNA *ptr, const char *propname, int value_slider, int lock, int lock_luminosity, int cubic);
 void uiTemplateLayers(uiLayout *layout, struct PointerRNA *ptr, const char *propname,
                       PointerRNA *used_ptr, const char *used_propname, int active_layer);
 void uiTemplateImage(uiLayout *layout, struct bContext *C, struct PointerRNA *ptr, const char *propname, struct PointerRNA *userptr, int compact);
Index: source/blender/editors/include/UI_resources.h
===================================================================
--- source/blender/editors/include/UI_resources.h	(revisione 45659)
+++ source/blender/editors/include/UI_resources.h	(copia locale)
@@ -198,6 +198,10 @@
 	TH_STITCH_PREVIEW_UNSTITCHABLE,
 	TH_STITCH_PREVIEW_ACTIVE,
 
+	TH_SHOW_BOUNDARY_LAYER,
+	TH_COL1_BOUNDARY_LAYER,
+	TH_COL2_BOUNDARY_LAYER,
+
 	TH_MATCH,			/* highlight color for search matches */
 	TH_SELECT_HIGHLIGHT	/* highlight color for selected outliner item */
 };
Index: source/blender/editors/interface/interface_icons.c
===================================================================
--- source/blender/editors/interface/interface_icons.c	(revisione 45659)
+++ source/blender/editors/interface/interface_icons.c	(copia locale)
@@ -1130,6 +1130,9 @@
 			/* checks if not exists, or changed */
 			ui_id_icon_render(C, id, big);
 			break;
+		/*case ID_IL: 
+			iconid= BKE_icon_getid(id);
+			break;*/
 		default:
 			break;
 	}
Index: source/blender/editors/interface/interface_templates.c
===================================================================
--- source/blender/editors/interface/interface_templates.c	(revisione 45659)
+++ source/blender/editors/interface/interface_templates.c	(copia locale)
@@ -1919,7 +1919,13 @@
 /********************* ColorWheel Template ************************/
 
 #define WHEEL_SIZE  100
+#define PICKER_H	100 //150
+#define PICKER_W	100 //150
+#define PICKER_SPACE	6
+#define PICKER_BAR		14
 
+#define PICKER_TOTAL_W	(PICKER_W+PICKER_SPACE+PICKER_BAR)
+
 void uiTemplateColorWheel(uiLayout *layout, PointerRNA *ptr, const char *propname, int value_slider, int lock, int lock_luminosity, int cubic)
 {
 	PropertyRNA *prop = RNA_struct_find_property(ptr, propname);
@@ -1937,9 +1943,10 @@
 	
 	col = uiLayoutColumn(layout, 0);
 	row = uiLayoutRow(col, 1);
-	
-	but = uiDefButR_prop(block, HSVCIRCLE, 0, "",   0, 0, WHEEL_SIZE, WHEEL_SIZE, ptr, prop, -1, 0.0, 0.0, 0, 0, "");
+	but = uiDefButR_prop(block, HSVCIRCLE, 0, "", 0, 0, WHEEL_SIZE, WHEEL_SIZE, ptr, prop, -1, 0.0, 0.0, 0, 0, "");
 
+	but = uiDefButR_prop(block, HSVCIRCLE, 0, "", 0, 0, WHEEL_SIZE, WHEEL_SIZE, ptr, prop, -1, 0.0, 0.0, 0, 0, "");
+		
 	if (lock) {
 		but->flag |= UI_BUT_COLOR_LOCK;
 	}
@@ -1956,10 +1963,80 @@
 
 	uiItemS(row);
 	
-	if (value_slider)
+	if (value_slider) 
 		uiDefButR_prop(block, HSVCUBE, 0, "", WHEEL_SIZE + 6, 0, 14, WHEEL_SIZE, ptr, prop, -1, softmin, softmax, UI_GRAD_V_ALT, 0, "");
 }
 
+void uiTemplateColor(uiLayout *layout, PointerRNA *ptr, const char *propname, int value_slider, int lock, int lock_luminosity, int cubic)
+{
+	PropertyRNA *prop= RNA_struct_find_property(ptr, propname);
+	uiBlock *block= uiLayoutGetBlock(layout);
+	uiLayout *col, *row;
+	uiBut *but;
+	float softmin, softmax, step, precision;
+
+	if (!prop) {
+		RNA_warning("property not found: %s.%s", RNA_struct_identifier(ptr->type), propname);
+		return;
+	}
+
+	RNA_property_float_ui_range(ptr, prop, &softmin, &softmax, &step, &precision);
+	
+	col = uiLayoutColumn(layout, 0);
+	row= uiLayoutRow(col, 1);
+
+	switch (U.color_picker_type) {
+		case USER_CP_CIRCLE:
+			but = uiDefButR_prop(block, HSVCIRCLE, 0, "", 0, 0, WHEEL_SIZE, WHEEL_SIZE, ptr, prop, -1, 0.0, 0.0, 0, 0, "");
+			break;
+		case USER_CP_SQUARE_SV:
+			but= uiDefButR_prop(block, HSVCUBE, 0, "",	0, PICKER_BAR+PICKER_SPACE, PICKER_TOTAL_W, PICKER_H, ptr, prop, 0, 0.0, 0.0, UI_GRAD_SV, 0, "");
+			break;
+		case USER_CP_SQUARE_HS:
+			but= uiDefButR_prop(block, HSVCUBE, 0, "",	0, PICKER_BAR+PICKER_SPACE, PICKER_TOTAL_W, PICKER_H, ptr, prop, 0, 0.0, 0.0, UI_GRAD_HS, 0, "");
+			break;
+		case USER_CP_SQUARE_HV:
+			but= uiDefButR_prop(block, HSVCUBE, 0, "",	0, PICKER_BAR+PICKER_SPACE, PICKER_TOTAL_W, PICKER_H, ptr, prop, 0, 0.0, 0.0, UI_GRAD_HV, 0, "");
+			break;
+	}
+
+	
+	if (lock) {
+		but->flag |= UI_BUT_COLOR_LOCK;
+	}
+
+	if (lock_luminosity) {
+		float color[4]; /* in case of alpha */
+		but->flag |= UI_BUT_VEC_SIZE_LOCK;
+		RNA_property_float_get_array(ptr, prop, color);
+		but->a2= len_v3(color);
+	}
+
+	if (cubic)
+		but->flag |= UI_BUT_COLOR_CUBIC;
+		
+	if (value_slider) {
+		switch (U.color_picker_type) {
+			case USER_CP_CIRCLE:
+				uiItemS(row);
+				uiDefButR_prop(block, HSVCUBE, 0, "", WHEEL_SIZE+6, 0, 14, WHEEL_SIZE, ptr, prop, -1, softmin, softmax, UI_GRAD_V_ALT, 0, "");
+				break;
+			case USER_CP_SQUARE_SV:
+				uiItemS(col);
+				uiDefButR_prop(block, HSVCUBE, 0, "", 0, 0, PICKER_TOTAL_W, PICKER_BAR, ptr, prop, -1, 0, 0, UI_GRAD_SV + 3, 0, "");
+				break;
+			case USER_CP_SQUARE_HS:
+				uiItemS(col);
+				uiDefButR_prop(block, HSVCUBE, 0, "", 0, 0, PICKER_TOTAL_W, PICKER_BAR, ptr, prop, -1, 0, 0, UI_GRAD_HS + 3, 0, "");
+				break;
+			case USER_CP_SQUARE_HV:
+				uiItemS(col);
+				uiDefButR_prop(block, HSVCUBE, 0, "", 0, 0, PICKER_TOTAL_W, PICKER_BAR, ptr, prop, -1, 0, 0, UI_GRAD_HV + 3, 0, "");
+				break;
+		}
+	}
+}
+
 /********************* Layer Buttons Template ************************/
 
 static void handle_layer_buttons(bContext *C, void *arg1, void *arg2)
@@ -2076,6 +2153,10 @@
 	else if (RNA_struct_is_a(itemptr->type, &RNA_TextureSlot)) {
 		id = RNA_pointer_get(itemptr, "texture").data;
 	}
+	/*else if (RNA_struct_is_a(itemptr->type, &RNA_ImageLayer)) {
+		//id= RNA_pointer_get(itemptr, "imagelayer").data;
+
+	}*/
 	else if (RNA_struct_is_a(itemptr->type, &RNA_DynamicPaintSurface)) {
 		DynamicPaintSurface *surface = (DynamicPaintSurface *)itemptr->data;
 
@@ -2139,6 +2220,18 @@
 		uiBlockSetEmboss(block, UI_EMBOSS);
 		uiDefButR(block, OPTION, 0, "", 0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "use", 0, 0, 0, 0, 0,  NULL);
 	}
+	else if (RNA_struct_is_a(itemptr->type, &RNA_ImageLayer)) {
+		ImageLayer *layer = (ImageLayer*)itemptr->data;
+		uiItemL(sub, name, icon);
+		uiBlockSetEmboss(block, UI_EMBOSSN);
+		//uiDefButR(block, OPTION, 0, "", 0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "visible", 0, 0, 0, 0, 0,  NULL);
+		uiDefIconButR(block, OPTION, 0, (layer->lock & IMA_LAYER_LOCK) ? ICON_LOCKED : ICON_UNLOCKED,
+				0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "lock", 0, 0, 0, 0, 0, NULL);
+		uiDefIconButR(block, OPTION, 0, (layer->visible & IMA_LAYER_VISIBLE) ? ICON_RESTRICT_VIEW_OFF : ICON_RESTRICT_VIEW_ON,
+				0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "visible", 0, 0, 0, 0, 0, NULL);
+		uiBlockSetEmboss(block, UI_EMBOSS);
+
+	}
 	else if (RNA_struct_is_a(itemptr->type, &RNA_MaterialSlot)) {
 		/* provision to draw active node name */
 		Material *ma, *manode;
Index: source/blender/editors/interface/resources.c
===================================================================
--- source/blender/editors/interface/resources.c	(revisione 45659)
+++ source/blender/editors/interface/resources.c	(copia locale)
@@ -441,6 +441,15 @@
 				case TH_STITCH_PREVIEW_ACTIVE:
 					cp = ts->preview_stitch_active;
 					break;
+				case TH_SHOW_BOUNDARY_LAYER:
+					cp = &ts->show_boundary_layer;
+					break;
+				case TH_COL1_BOUNDARY_LAYER:
+					cp = ts->col1_boundary_layer;
+					break;
+				case TH_COL2_BOUNDARY_LAYER:
+					cp = ts->col2_boundary_layer;
+					break;
 				case TH_MARKER_OUTLINE:
 					cp = ts->marker_outline; break;
 				case TH_MARKER:
@@ -790,6 +799,9 @@
 	rgba_char_args_set_fl(btheme->tima.preview_stitch_vert, 0.0, 0.0, 1.0, 0.2);
 	rgba_char_args_set_fl(btheme->tima.preview_stitch_stitchable, 0.0, 1.0, 0.0, 1.0);
 	rgba_char_args_set_fl(btheme->tima.preview_stitch_unstitchable, 1.0, 0.0, 0.0, 1.0);
+	btheme->tima.show_boundary_layer = TH_IMAGE_LAYER_BOUNDARY;
+	rgba_char_args_set(btheme->tima.col1_boundary_layer, 255, 255, 0, 255);
+	rgba_char_args_set(btheme->tima.col2_boundary_layer, 255, 0, 255, 255);
 
 	/* space text */
 	btheme->text = btheme->tv3d;
@@ -1752,6 +1764,7 @@
 		for (btheme = U.themes.first; btheme; btheme = btheme->next) {
 			if (btheme->tui.wcol_menu_item.item[3] == 255)
 				rgba_char_args_set(btheme->tui.wcol_menu_item.item, 172, 172, 172, 128);
+			
 		}
 	}
 
@@ -1773,6 +1786,9 @@
 			if (btheme->tseq.movieclip[0] == 0) {
 				rgba_char_args_set(btheme->tseq.movieclip,  32, 32, 143, 255);
 			}
+			btheme->tima.show_boundary_layer = TH_IMAGE_LAYER_BOUNDARY;
+			rgba_char_args_set_fl(btheme->tima.col1_boundary_layer, 1.0, 1.0, 0.0, 1.0);
+			rgba_char_args_set_fl(btheme->tima.col2_boundary_layer, 0.94, 0.34, 1.0, 1.0);
 		}
 	}
 
Index: source/blender/editors/screen/glutil.c
===================================================================
--- source/blender/editors/screen/glutil.c	(revisione 45659)
+++ source/blender/editors/screen/glutil.c	(copia locale)
@@ -261,22 +261,22 @@
 	glEnd();
 }
 
-void sdrawbox(short x1, short y1, short x2, short y2)
+void sdrawbox(int x1, int y1, int x2, int y2)
 {
-	short v[2];
+	int v[2];
 	
 	glBegin(GL_LINE_STRIP);
 	
 	v[0] = x1; v[1] = y1;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	v[0] = x1; v[1] = y2;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	v[0] = x2; v[1] = y2;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	v[0] = x2; v[1] = y1;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	v[0] = x1; v[1] = y1;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	
 	glEnd();
 }
Index: source/blender/editors/sculpt_paint/paint_image.c
===================================================================
--- source/blender/editors/sculpt_paint/paint_image.c	(revisione 45659)
+++ source/blender/editors/sculpt_paint/paint_image.c	(copia locale)
@@ -33,9 +33,11 @@
  */
 
 
+#include <stddef.h>
 #include <float.h>
 #include <string.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <math.h>
 
 #include "MEM_guardedalloc.h"
@@ -64,15 +66,18 @@
 #include "DNA_node_types.h"
 #include "DNA_object_types.h"
 #include "DNA_scene_types.h"
+#include "DNA_screen_types.h"
 #include "DNA_texture_types.h"
 
 #include "BKE_camera.h"
+#include "BKE_colortools.h"
 #include "BKE_context.h"
 #include "BKE_depsgraph.h"
 #include "BKE_DerivedMesh.h"
 #include "BKE_idprop.h"
 #include "BKE_brush.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
 #include "BKE_mesh.h"
@@ -83,6 +88,7 @@
 #include "BKE_scene.h"
 #include "BKE_global.h"
 #include "BKE_deform.h"
+#include "BKE_screen.h"
 
 #include "BKE_tessmesh.h"
 
@@ -94,6 +100,7 @@
 #include "ED_image.h"
 #include "ED_screen.h"
 #include "ED_sculpt.h"
+#include "ED_space_api.h"
 #include "ED_uvedit.h"
 #include "ED_view3d.h"
 #include "ED_mesh.h"
@@ -4642,6 +4649,7 @@
 static int image_paint_poll(bContext *C)
 {
 	Object *obact = CTX_data_active_object(C);
+	wmWindow *win= CTX_wm_window(C);
 
 	if (!image_paint_brush(C))
 		return 0;
@@ -4655,9 +4663,13 @@
 		if (sima) {
 			ARegion *ar = CTX_wm_region(C);
 
-			if ((sima->flag & SI_DRAWTOOL) && ar->regiontype == RGN_TYPE_WINDOW)
+			if ((sima->flag & SI_DRAWTOOL) && (ar->regiontype==RGN_TYPE_WINDOW) && (!(imalayer_is_locked(sima->image) & IMA_LAYER_LOCK))) {
+				if ((!(win->modalcursor & BC_NSEW_SCROLLCURSOR)) || (!(win->modalcursor & BC_EYEDROPPER_CURSOR)))
+					WM_cursor_modal(win, BC_PAINTBRUSHCURSOR);
 				return 1;
+			}
 		}
+		WM_cursor_restore(CTX_wm_window(C));
 	}
 
 	return 0;
@@ -5407,24 +5419,166 @@
 
 /******************** sample color operator ********************/
 
+typedef struct SampleColorInfo {
+	ARegionType *art;
+	void *draw_handle;
+	int x, y;
+	int channels;
+
+	unsigned char col[4];
+	float colf[4];
+	int z;
+	float zf;
+
+	unsigned char *colp;
+	float *colfp;
+	int *zp;
+	float *zfp;
+
+	int draw;
+} SampleColorInfo;
+
+static void sample_color_draw(const bContext *UNUSED(C), ARegion *ar, void *arg_info)
+{
+	SampleColorInfo *info= arg_info;
+	if(info->draw) {
+		/* no color management needed for images (color_manage=0) */
+		ED_image_draw_info(ar, 0, info->channels, info->x, info->y, info->colp, info->colfp, info->zp, info->zfp, 2);
+	}
+}
+
 static int sample_color_exec(bContext *C, wmOperator *op)
 {
 	Scene *scene = CTX_data_scene(C);
+	SpaceImage *sima = CTX_wm_space_image(C);
 	Brush *brush = image_paint_brush(C);
 	ARegion *ar = CTX_wm_region(C);
+	//wmWindow *win= CTX_wm_window(C);
+	void *lock;
+	ImBuf *ibuf= ED_space_image_acquire_buffer(sima, &lock);
+	SampleColorInfo *info= op->customdata;
 	int location[2];
+	float fx, fy;
 
+	if(ibuf == NULL) {
+		ED_space_image_release_buffer(sima, lock);
+		return OPERATOR_CANCELLED;
+	}
+
+	//WM_cursor_modal(win, BC_EYEDROPPER_CURSOR);
 	RNA_int_get_array(op->ptr, "location", location);
 	paint_sample_color(scene, ar, location[0], location[1]);
 
+
+	UI_view2d_region_to_view(&ar->v2d, location[0], location[1], &fx, &fy);
+
+	if(fx>=0.0f && fy>=0.0f && fx<1.0f && fy<1.0f) {
+		float *fp;
+		unsigned char *cp;
+		int x= (int)(fx*ibuf->x), y= (int)(fy*ibuf->y);
+
+		CLAMP(x, 0, ibuf->x-1);
+		CLAMP(y, 0, ibuf->y-1);
+
+		info->x= x;
+		info->y= y;
+		info->draw= 1;
+		info->channels= ibuf->channels;
+
+		info->colp= NULL;
+		info->colfp= NULL;
+		info->zp= NULL;
+		info->zfp= NULL;
+		
+		if(ibuf->rect) {
+			cp= (unsigned char *)(ibuf->rect + y*ibuf->x + x);
+
+			info->col[0]= cp[0];
+			info->col[1]= cp[1];
+			info->col[2]= cp[2];
+			info->col[3]= cp[3];
+			info->colp= info->col;
+
+			info->colf[0]= (float)cp[0]/255.0f;
+			info->colf[1]= (float)cp[1]/255.0f;
+			info->colf[2]= (float)cp[2]/255.0f;
+			info->colf[3]= (float)cp[3]/255.0f;
+			info->colfp= info->colf;
+		}
+		if(ibuf->rect_float) {
+			fp= (ibuf->rect_float + (ibuf->channels)*(y*ibuf->x + x));
+
+			info->colf[0]= fp[0];
+			info->colf[1]= fp[1];
+			info->colf[2]= fp[2];
+			info->colf[3]= fp[3];
+			info->colfp= info->colf;
+		}
+
+		if(ibuf->zbuf) {
+			info->z= ibuf->zbuf[y*ibuf->x + x];
+			info->zp= &info->z;
+		}
+		if(ibuf->zbuf_float) {
+			info->zf= ibuf->zbuf_float[y*ibuf->x + x];
+			info->zfp= &info->zf;
+		}
+		
+		if(sima->cumap && ibuf->channels==4) {
+			/* we reuse this callback for set curves point operators */
+			if(RNA_struct_find_property(op->ptr, "point")) {
+				int point= RNA_enum_get(op->ptr, "point");
+
+				if(point == 1) {
+					curvemapping_set_black_white(sima->cumap, NULL, info->colfp);
+					if(ibuf->rect_float)
+						curvemapping_do_ibuf(sima->cumap, ibuf);
+				}
+				else if(point == 0) {
+					curvemapping_set_black_white(sima->cumap, info->colfp, NULL);
+					if(ibuf->rect_float)
+						curvemapping_do_ibuf(sima->cumap, ibuf);
+				}
+			}
+		}
+	}
+	else
+		info->draw= 0;
+
+	ED_space_image_release_buffer(sima, lock);
+	ED_area_tag_redraw(CTX_wm_area(C));
+
+
 	WM_event_add_notifier(C, NC_BRUSH | NA_EDITED, brush);
 	
 	return OPERATOR_FINISHED;
 }
 
+static void sample_color_exit(bContext *C, wmOperator *op)
+{
+	SampleColorInfo *info= op->customdata;
+
+	ED_region_draw_cb_exit(info->art, info->draw_handle);
+	ED_area_tag_redraw(CTX_wm_area(C));
+	MEM_freeN(info);
+}
+
 static int sample_color_invoke(bContext *C, wmOperator *op, wmEvent *event)
 {
+	SpaceImage *sima= CTX_wm_space_image(C);
+	ARegion *ar= CTX_wm_region(C);
+	SampleColorInfo *info;
+
+	if(!ED_space_image_has_buffer(sima))
+		return OPERATOR_CANCELLED;
+
+	info= MEM_callocN(sizeof(SampleColorInfo), "ImageSampleInfo");
+	info->art= ar->type;
+	info->draw_handle = ED_region_draw_cb_activate(ar->type, sample_color_draw, info, REGION_DRAW_POST_PIXEL);
+	op->customdata= info;
+
 	RNA_int_set_array(op->ptr, "location", event->mval);
+
 	sample_color_exec(C, op);
 
 	WM_event_add_modal_handler(C, op);
@@ -5437,6 +5591,7 @@
 	switch (event->type) {
 		case LEFTMOUSE:
 		case RIGHTMOUSE: // XXX hardcoded
+			sample_color_exit(C, op);
 			return OPERATOR_FINISHED;
 		case MOUSEMOVE:
 			RNA_int_set_array(op->ptr, "location", event->mval);
Index: source/blender/editors/space_image/image_draw.c
===================================================================
--- source/blender/editors/space_image/image_draw.c	(revisione 45659)
+++ source/blender/editors/space_image/image_draw.c	(copia locale)
@@ -54,6 +54,7 @@
 #include "BKE_context.h"
 #include "BKE_global.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_paint.h"
 
 #include "BIF_gl.h"
@@ -112,7 +113,7 @@
 
 /* used by node view too */
 void ED_image_draw_info(ARegion *ar, int color_manage, int channels, int x, int y,
-                        const unsigned char cp[4], const float fp[4], int *zp, float *zpf)
+                        const unsigned char cp[4], const float fp[4], int *zp, float *zpf, const char type)
 {
 	char str[256];
 	float dx = 6;
@@ -134,82 +135,89 @@
 	glEnable(GL_BLEND);
 
 	/* noisy, high contrast make impossible to read if lower alpha is used. */
-	glColor4ub(0, 0, 0, 190);
-	glRecti(0.0, 0.0, ar->winrct.xmax - ar->winrct.xmin + 1, 20);
+	if (type == 1) {
+		glColor4ub(0, 0, 0, 190);
+		glRecti(0.0, 0.0, ar->winrct.xmax - ar->winrct.xmin + 1, 20);
+	}
+	else {
+		glColor4ub(0, 0, 0, 150);
+		glRecti(0.0, 0.0, 70, 70);
+	}
 	glDisable(GL_BLEND);
 
-	BLF_size(blf_mono_font, 11, 72);
+	if (type == 1) {
+		BLF_size(blf_mono_font, 11, 72);
 
-	glColor3ub(255, 255, 255);
-	BLI_snprintf(str, sizeof(str), "X:%-4d  Y:%-4d |", x, y);
-	// UI_DrawString(6, 6, str); // works ok but fixed width is nicer.
-	BLF_position(blf_mono_font, dx, 6, 0);
-	BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-	dx += BLF_width(blf_mono_font, str);
+		glColor3ub(255, 255, 255);
+		BLI_snprintf(str, sizeof(str), "X:%-4d  Y:%-4d |", x, y);
 
-	if (zp) {
-		glColor3ub(255, 255, 255);
-		BLI_snprintf(str, sizeof(str), " Z:%-.4f |", 0.5f + 0.5f * (((float)*zp) / (float)0x7fffffff));
 		BLF_position(blf_mono_font, dx, 6, 0);
 		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
 		dx += BLF_width(blf_mono_font, str);
-	}
-	if (zpf) {
-		glColor3ub(255, 255, 255);
-		BLI_snprintf(str, sizeof(str), " Z:%-.3f |", *zpf);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
-	}
 
-	if (channels >= 3) {
-		glColor3ubv(red);
-		if (fp)
-			BLI_snprintf(str, sizeof(str), "  R:%-.4f", fp[0]);
-		else if (cp)
-			BLI_snprintf(str, sizeof(str), "  R:%-3d", cp[0]);
-		else
-			BLI_snprintf(str, sizeof(str), "  R:-");
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+		if (zp) {
+			glColor3ub(255, 255, 255);
+			BLI_snprintf(str, sizeof(str), " Z:%-.4f |", 0.5f + 0.5f * (((float)*zp) / (float)0x7fffffff));
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
+		}
+		if (zpf) {
+			glColor3ub(255, 255, 255);
+			BLI_snprintf(str, sizeof(str), " Z:%-.3f |", *zpf);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
+		}
+
+		if (channels >= 3) {
+			glColor3ubv(red);
+			if (fp)
+				BLI_snprintf(str, sizeof(str), "  R:%-.4f", fp[0]);
+			else if (cp)
+				BLI_snprintf(str, sizeof(str), "  R:%-3d", cp[0]);
+			else
+				BLI_snprintf(str, sizeof(str), "  R:-");
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 		
-		glColor3ubv(green);
-		if (fp)
-			BLI_snprintf(str, sizeof(str), "  G:%-.4f", fp[1]);
-		else if (cp)
-			BLI_snprintf(str, sizeof(str), "  G:%-3d", cp[1]);
-		else
-			BLI_snprintf(str, sizeof(str), "  G:-");
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			glColor3ubv(green);
+			if (fp)
+				BLI_snprintf(str, sizeof(str), "  G:%-.4f", fp[1]);
+			else if (cp)
+				BLI_snprintf(str, sizeof(str), "  G:%-3d", cp[1]);
+			else
+				BLI_snprintf(str, sizeof(str), "  G:-");
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 		
-		glColor3ubv(blue);
-		if (fp)
-			BLI_snprintf(str, sizeof(str), "  B:%-.4f", fp[2]);
-		else if (cp)
-			BLI_snprintf(str, sizeof(str), "  B:%-3d", cp[2]);
-		else
-			BLI_snprintf(str, sizeof(str), "  B:-");
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
-		
-		if (channels == 4) {
-			glColor3ub(255, 255, 255);
+			glColor3ubv(blue);
 			if (fp)
-				BLI_snprintf(str, sizeof(str), "  A:%-.4f", fp[3]);
+				BLI_snprintf(str, sizeof(str), "  B:%-.4f", fp[2]);
 			else if (cp)
-				BLI_snprintf(str, sizeof(str), "  A:%-3d", cp[3]);
+				BLI_snprintf(str, sizeof(str), "  B:%-3d", cp[2]);
 			else
-				BLI_snprintf(str, sizeof(str), "- ");
+				BLI_snprintf(str, sizeof(str), "  B:-");
 			BLF_position(blf_mono_font, dx, 6, 0);
 			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
 			dx += BLF_width(blf_mono_font, str);
+		
+			if(channels == 4) {
+				glColor3ub(255, 255, 255);
+				if (fp)
+					BLI_snprintf(str, sizeof(str), "  A:%-.4f", fp[3]);
+				else if (cp)
+					BLI_snprintf(str, sizeof(str), "  A:%-3d", cp[3]);
+				else
+					BLI_snprintf(str, sizeof(str), "- ");
+				BLF_position(blf_mono_font, dx, 6, 0);
+				BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+				dx += BLF_width(blf_mono_font, str);
+			}
 		}
 	}
-	
 	/* color rectangle */
 	if (channels == 1) {
 		if (fp) {
@@ -258,80 +266,99 @@
 	}
 	glDisable(GL_BLEND);
 	glColor3fv(finalcol);
-	dx += 5;
+	if (type == 1)
+		dx += 5;
+	else
+		dx = 5;
 	glBegin(GL_QUADS);
-	glVertex2f(dx, 3);
-	glVertex2f(dx, 17);
-	glVertex2f(dx + 30, 17);
-	glVertex2f(dx + 30, 3);
+	if (type == 1) {
+		glVertex2f(dx, 3);
+		glVertex2f(dx, 17);
+		glVertex2f(dx + 30, 17);
+		glVertex2f(dx + 30, 3);
+	}
+	else {
+		glVertex2f(5, 5);
+		glVertex2f(5, 65);
+		glVertex2f(65, 65);
+		glVertex2f(65, 5);
+	}
 	glEnd();
 
 	/* draw outline */
 	glColor3ub(128, 128, 128);
 	glBegin(GL_LINE_LOOP);
-	glVertex2f(dx, 3);
-	glVertex2f(dx, 17);
-	glVertex2f(dx + 30, 17);
-	glVertex2f(dx + 30, 3);
+	if (type == 1) {
+		glVertex2f(dx, 3);
+		glVertex2f(dx, 17);
+		glVertex2f(dx + 30, 17);
+		glVertex2f(dx + 30, 3);
+	}
+	else {
+		glVertex2f(5, 5);
+		glVertex2f(5, 65);
+		glVertex2f(65, 65);
+		glVertex2f(65, 5);
+	}
 	glEnd();
 
-	dx += 35;
+	if (type == 1) {
+		dx += 35;
 
-	glColor3ub(255, 255, 255);
-	if (channels == 1) {
-		if (fp) {
-			rgb_to_hsv(fp[0], fp[0], fp[0], &hue, &sat, &val);
-			rgb_to_yuv(fp[0], fp[0], fp[0], &lum, &u, &v);
-		}
-		else if (cp) {
-			rgb_to_hsv((float)cp[0] / 255.0f, (float)cp[0] / 255.0f, (float)cp[0] / 255.0f, &hue, &sat, &val);
-			rgb_to_yuv((float)cp[0] / 255.0f, (float)cp[0] / 255.0f, (float)cp[0] / 255.0f, &lum, &u, &v);
-		}
+		glColor3ub(255, 255, 255);
+		if (channels == 1) {
+			if (fp) {
+				rgb_to_hsv(fp[0], fp[0], fp[0], &hue, &sat, &val);
+				rgb_to_yuv(fp[0], fp[0], fp[0], &lum, &u, &v);
+			}
+			else if (cp) {
+				rgb_to_hsv((float)cp[0] / 255.0f, (float)cp[0] / 255.0f, (float)cp[0]/255.0f, &hue, &sat, &val);
+				rgb_to_yuv((float)cp[0] / 255.0f, (float)cp[0] / 255.0f, (float)cp[0]/255.0f, &lum, &u, &v);
+			}
 		
-		BLI_snprintf(str, sizeof(str), "V:%-.4f", val);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "V:%-.4f", val);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 
-		BLI_snprintf(str, sizeof(str), "   L:%-.4f", lum);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
-	}
-	else if (channels >= 3) {
-		if (fp) {
-			rgb_to_hsv(fp[0], fp[1], fp[2], &hue, &sat, &val);
-			rgb_to_yuv(fp[0], fp[1], fp[2], &lum, &u, &v);
+			BLI_snprintf(str, sizeof(str), "   L:%-.4f", lum);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 		}
-		else if (cp) {
-			rgb_to_hsv((float)cp[0] / 255.0f, (float)cp[1] / 255.0f, (float)cp[2] / 255.0f, &hue, &sat, &val);
-			rgb_to_yuv((float)cp[0] / 255.0f, (float)cp[1] / 255.0f, (float)cp[2] / 255.0f, &lum, &u, &v);
-		}
+		else if (channels >= 3) {
+			if (fp) {
+				rgb_to_hsv(fp[0], fp[1], fp[2], &hue, &sat, &val);
+				rgb_to_yuv(fp[0], fp[1], fp[2], &lum, &u, &v);
+			}
+			else if (cp) {
+				rgb_to_hsv((float)cp[0]/255.0f, (float)cp[1]/255.0f, (float)cp[2]/255.0f, &hue, &sat, &val);
+				rgb_to_yuv((float)cp[0]/255.0f, (float)cp[1]/255.0f, (float)cp[2]/255.0f, &lum, &u, &v);
+			}
 
-		BLI_snprintf(str, sizeof(str), "H:%-.4f", hue);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "H:%-.4f", hue);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 
-		BLI_snprintf(str, sizeof(str), "  S:%-.4f", sat);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "  S:%-.4f", sat);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 
-		BLI_snprintf(str, sizeof(str), "  V:%-.4f", val);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "  V:%-.4f", val);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 
-		BLI_snprintf(str, sizeof(str), "   L:%-.4f", lum);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "   L:%-.4f", lum);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
+		}
 	}
-
 	(void)dx;
 }
-
 /* image drawing */
 
 static void draw_image_grid(ARegion *ar, float zoomx, float zoomy)
@@ -476,6 +503,53 @@
 	MEM_freeN(rectf);
 }
 
+static void draw_layer_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
+{
+	int x, y;
+	int color_manage = scene->r.color_mgt_flag & R_COLOR_MANAGEMENT;
+
+	/* set zoom */
+	glPixelZoom(zoomx, zoomy);
+
+	/* find window pixel coordinates of origin */
+	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
+	
+	/* this part is generic image display */
+	if(sima->flag & SI_SHOW_ALPHA) {
+		if(ibuf->rect)
+			sima_draw_alpha_pixels(x, y, ibuf->x, ibuf->y, ibuf->rect);
+		else if(ibuf->rect_float && ibuf->channels==4)
+			sima_draw_alpha_pixelsf(x, y, ibuf->x, ibuf->y, ibuf->rect_float);
+	}
+	else if(sima->flag & SI_SHOW_ZBUF && (ibuf->zbuf || ibuf->zbuf_float || (ibuf->channels==1))) {
+		if(ibuf->zbuf)
+			sima_draw_zbuf_pixels(x, y, ibuf->x, ibuf->y, ibuf->zbuf);
+		else if(ibuf->zbuf_float)
+			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->zbuf_float);
+		else if(ibuf->channels==1)
+			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->rect_float);
+	}
+	else {
+		
+		/* we don't draw floats buffers directly but
+		 * convert them, and optionally apply curves */
+		image_verify_buffer_float(ima, ibuf, color_manage);
+		
+		if(ibuf->rect)
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
+			glaDrawPixelsTexScaled(x, y, ibuf->x, ibuf->y, GL_RGBA, ibuf->rect, 1.0f, 1.0f);
+		//else
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_FLOAT, ibuf->rect_float);
+		
+		if(sima->flag & SI_USE_ALPHA)
+			glDisable(GL_BLEND);
+	}
+	
+	/* reset zoom */
+	glPixelZoom(1.0f, 1.0f);
+}
+
+
 static void draw_image_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
 {
 	int x, y;
@@ -486,7 +560,7 @@
 
 	/* find window pixel coordinates of origin */
 	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
-
+	
 	/* this part is generic image display */
 	if (sima->flag & SI_SHOW_ALPHA) {
 		if (ibuf->rect)
@@ -509,11 +583,11 @@
 			glEnable(GL_BLEND);
 			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 		}
-
+		
 		/* we don't draw floats buffers directly but
 		 * convert them, and optionally apply curves */
 		image_verify_buffer_float(ima, ibuf, color_manage);
-
+		
 		if (ibuf->rect)
 			glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
 #if 0
@@ -524,7 +598,7 @@
 		if (sima->flag & SI_USE_ALPHA)
 			glDisable(GL_BLEND);
 	}
-
+	
 	/* reset zoom */
 	glPixelZoom(1.0f, 1.0f);
 }
@@ -741,15 +815,40 @@
 	}
 }
 
+static void layer_draw_boundary(int xmin, int ymin, int xsize, int ysize, float zoomx, float zoomy) 
+{
+	unsigned char col1[4], col2[4];
+	UI_GetThemeColor3ubv(TH_COL1_BOUNDARY_LAYER, col1);
+	UI_GetThemeColor3ubv(TH_COL2_BOUNDARY_LAYER, col2);
+
+	glEnable(GL_LINE_STIPPLE);
+	glColor3ub(col1[0], col1[1], col1[2]);//col1
+	glLineStipple(2, 0x0F0F);
+	sdrawbox(xmin, ymin, xmin+zoomx*xsize, ymin+zoomy*ysize);
+	glDisable(GL_LINE_STIPPLE);
+
+	glEnable(GL_LINE_STIPPLE);
+	glColor3ub(col2[0], col2[1], col2[2]);//col2
+	glLineStipple(2, 0xF0F0);
+	sdrawbox(xmin, ymin, xmin+zoomx*xsize, ymin+zoomy*ysize);
+	glDisable(GL_LINE_STIPPLE);
+}
+
+
 /* draw main image area */
 
 void draw_image_main(SpaceImage *sima, ARegion *ar, Scene *scene)
 {
 	Image *ima;
+	ImageLayer *layer;
 	ImBuf *ibuf;
-	float zoomx, zoomy;
+	ImBuf *next_ibuf, *result_ibuf;
+	float zoomx, zoomy, sp_x, sp_y;
 	int show_viewer, show_render;
+	int first = 0;
+	int x, y, b_x, b_y, bg_x, bg_y;
 	void *lock;
+	char background=0;
 
 	/* XXX can we do this in refresh? */
 #if 0
@@ -778,7 +877,7 @@
 
 	show_viewer = (ima && ima->source == IMA_SRC_VIEWER);
 	show_render = (show_viewer && ima->type == IMA_TYPE_R_RESULT);
-
+	
 	/* draw the image or grid */
 	if (ibuf == NULL)
 		draw_image_grid(ar, zoomx, zoomy);
@@ -786,8 +885,89 @@
 		draw_image_buffer_repeated(sima, ar, scene, ima, ibuf, zoomx, zoomy);
 	else if (ima && (ima->tpageflag & IMA_TILES))
 		draw_image_buffer_tiled(sima, ar, scene, ima, ibuf, 0.0f, 0.0, zoomx, zoomy);
-	else
+	else if (ima && !show_render && (sima->flag & SI_DRAWTOOL)) {
+		next_ibuf = NULL;
+		ibuf = BKE_image_acquire_ibuf(ima, NULL, &lock);
+		layer = ima->imlayers.last;
+		
+		bg_x = ((ImBuf*)((ImageLayer*)layer->ibufs.first))->x;
+		bg_y = ((ImBuf*)((ImageLayer*)layer->ibufs.first))->y;
+		
+		if (layer->background & IMA_LAYER_BG_ALPHA) //Alpha
+			background = 1;
+
+		for(layer=ima->imlayers.last; layer; layer=layer->prev) {
+			if (!first) {
+				if ((layer->opacity!=1.0f) || (ibuf->channels==4) || (background==1)) {
+					UI_view2d_to_region_no_clip(&ar->v2d, 0.0f, 0.0f, &x, &y);
+					fdrawcheckerboard(x, y, x + ibuf->x * zoomx, y + ibuf->y * zoomy);
+					first = 1;
+				}
+			}
+
+			if (layer->visible & IMA_LAYER_VISIBLE) {
+				ibuf = (ImBuf*)((ImageLayer*)layer->ibufs.first);
+				
+				if (ibuf) {
+					result_ibuf = imalayer_blend(next_ibuf, ibuf, layer->opacity, layer->mode);
+					if (next_ibuf)
+						IMB_freeImBuf(next_ibuf);
+					
+					next_ibuf = IMB_dupImBuf(result_ibuf);
+
+					if (layer->background & IMA_LAYER_BG_IMAGE) {
+						/*sp_x = 1 / ((float)(bg_x - ibuf->x) / 2);
+						sp_y = 1 / ((float)(bg_y - ibuf->y) / 2);
+						*/
+						sp_x = 0.0f;
+						sp_y = 0.0f;
+					}
+					else {
+						sp_x = 0.0f;
+						sp_y = 0.0f;
+					}
+					
+					glEnable(GL_BLEND);
+					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+					glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					draw_layer_buffer(sima, ar, scene, ima, result_ibuf, sp_x, sp_y, zoomx, zoomy);
+					glDisable(GL_BLEND);
+
+					if (result_ibuf)
+						IMB_freeImBuf(result_ibuf);
+				}
+			}
+
+			if (UI_GetThemeValue(TH_SHOW_BOUNDARY_LAYER)) {
+				if (layer->select & IMA_LAYER_SEL_CURRENT) {
+					b_x = ibuf->x;
+					b_y = ibuf->y;
+				}
+			}
+		}
+
+		glDisable(GL_BLEND);
+		if (UI_GetThemeValue(TH_SHOW_BOUNDARY_LAYER))
+			layer_draw_boundary(x, y, b_x, b_y, zoomx, zoomy);
+
+		if (next_ibuf)
+			IMB_freeImBuf(next_ibuf);
+		BKE_image_release_ibuf(ima, lock);
+	}
+	else {
+		layer = ima->imlayers.last;
+		if (layer->background & IMA_LAYER_BG_ALPHA) {
+			int x, y;
+			UI_view2d_to_region_no_clip(&ar->v2d, 0.0f, 0.0f, &x, &y);
+			fdrawcheckerboard(x, y, x + ibuf->x * zoomx, y + ibuf->y * zoomy);
+		}
+
 		draw_image_buffer(sima, ar, scene, ima, ibuf, 0.0f, 0.0f, zoomx, zoomy);
+		
+		if (layer->background & IMA_LAYER_BG_ALPHA)
+			glDisable(GL_BLEND);
+	}
 
 	/* paint helpers */
 	if (sima->flag & SI_DRAWTOOL)
Index: source/blender/editors/space_image/image_intern.h
===================================================================
--- source/blender/editors/space_image/image_intern.h	(revisione 45659)
+++ source/blender/editors/space_image/image_intern.h	(copia locale)
@@ -93,5 +93,17 @@
 void IMAGE_OT_properties(struct wmOperatorType *ot);
 void IMAGE_OT_scopes(struct wmOperatorType *ot);
 
+/* image layers */
+void IMAGE_OT_image_layer_move(struct wmOperatorType *ot);
+//void IMAGE_OT_image_layer_fill_color(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_remove(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add_below(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add_above(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_duplicate(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_select(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_clean(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_merge(struct wmOperatorType *ot);
+
+
 #endif /* __IMAGE_INTERN_H__ */
-
Index: source/blender/editors/space_image/image_ops.c
===================================================================
--- source/blender/editors/space_image/image_ops.c	(revisione 45659)
+++ source/blender/editors/space_image/image_ops.c	(copia locale)
@@ -47,6 +47,7 @@
 #include "BKE_colortools.h"
 #include "BKE_context.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_global.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
@@ -818,61 +819,87 @@
 	PointerRNA idptr;
 	Image *ima = NULL;
 	char str[FILE_MAX];
+	int action = RNA_enum_get(op->ptr, "action");
 
 	RNA_string_get(op->ptr, "filepath", str);
 	/* default to frame 1 if there's no scene in context */
+	if ((sima->image == NULL) || (action & IMA_LAYER_OPEN_IMAGE)) {
+		errno = 0;
 
-	errno = 0;
+		ima = BKE_add_image_file(str);
+		if (!ima) {
+			if (op->customdata) MEM_freeN(op->customdata);
+			BKE_reportf(op->reports, RPT_ERROR, "Can't read: \"%s\", %s", str, errno ? strerror(errno) : "Unsupported image format");
+			return OPERATOR_CANCELLED;
+		}
 
-	ima = BKE_add_image_file(str);
+		if (!op->customdata)
+			image_open_init(C, op);
 
-	if (!ima) {
-		if (op->customdata) MEM_freeN(op->customdata);
-		BKE_reportf(op->reports, RPT_ERROR, "Can't read: \"%s\", %s", str, errno ? strerror(errno) : "Unsupported image format");
-		return OPERATOR_CANCELLED;
-	}
+		/* hook into UI */
+		pprop = op->customdata;
+
+		if (pprop->prop) {
+			/* when creating new ID blocks, use is already 1, but RNA
+			 * pointer se also increases user, so this compensates it */
+			ima->id.us--;
+
+			RNA_id_pointer_create(&ima->id, &idptr);
+			RNA_property_pointer_set(&pprop->ptr, pprop->prop, idptr);
+			RNA_property_update(C, &pprop->ptr, pprop->prop);
+		}
+		else if (sima) {
+			ED_space_image_set(sima, scene, obedit, ima);
+			iuser = &sima->iuser;
+		}
+		else {
+			Tex *tex = CTX_data_pointer_get_type(C, "texture", &RNA_Texture).data;
+			if (tex && tex->type == TEX_IMAGE)
+				iuser = &tex->iuser;
+		
+		}
+		
+		/* initialize because of new image */
+		if (iuser) {
+			iuser->sfra = 1;
+			iuser->offset = 0;
+			iuser->fie_ima = 2;
+		}
+
+		/* XXX unpackImage frees image buffers */
+		ED_preview_kill_jobs(C);
 	
-	if (!op->customdata)
-		image_open_init(C, op);
+		BKE_image_signal(ima, iuser, IMA_SIGNAL_RELOAD);
+		WM_event_add_notifier(C, NC_IMAGE | NA_EDITED | ND_DRAW, ima);
 
-	/* hook into UI */
-	pprop = op->customdata;
+		MEM_freeN(op->customdata);
+	} else if ((action & IMA_LAYER_OPEN_LAYER)) {
+		if (sima) {
+			ima = sima->image;
+		}
 
-	if (pprop->prop) {
-		/* when creating new ID blocks, use is already 1, but RNA
-		 * pointer se also increases user, so this compensates it */
-		ima->id.us--;
+		if (ima) {
+			ImageLayer *iml;
+			struct ImBuf *ibuf;
+			int flag;
 
-		RNA_id_pointer_create(&ima->id, &idptr);
-		RNA_property_pointer_set(&pprop->ptr, pprop->prop, idptr);
-		RNA_property_update(C, &pprop->ptr, pprop->prop);
-	}
-	else if (sima) {
-		ED_space_image_set(sima, scene, obedit, ima);
-		iuser = &sima->iuser;
-	}
-	else {
-		Tex *tex = CTX_data_pointer_get_type(C, "texture", &RNA_Texture).data;
-		if (tex && tex->type == TEX_IMAGE)
-			iuser = &tex->iuser;
+			iml = BKE_add_image_file_as_layer(ima, str);
+			iml->background = IMA_LAYER_BG_IMAGE;
+			strcpy(iml->file_path, str);
+			flag= IB_rect|IB_multilayer|IB_metadata;
+			if (ima->flag & IMA_DO_PREMUL)
+				flag |= IB_premul;
 		
+			/* read ibuf */
+			ibuf = IMB_loadiffname(str, flag);
+			BLI_addtail(&iml->ibufs, ibuf);
+			if(!iml)
+				return OPERATOR_CANCELLED;
+
+			WM_event_add_notifier(C, NC_IMAGE | ND_DRAW, ima);
+			MEM_freeN(op->customdata);
+		}
 	}
-	
-	/* initialize because of new image */
-	if (iuser) {
-		iuser->sfra = 1;
-		iuser->offset = 0;
-		iuser->fie_ima = 2;
-	}
-
-	/* XXX unpackImage frees image buffers */
-	ED_preview_kill_jobs(C);
-	
-	BKE_image_signal(ima, iuser, IMA_SIGNAL_RELOAD);
-	WM_event_add_notifier(C, NC_IMAGE | NA_EDITED, ima);
-	
-	MEM_freeN(op->customdata);
-
 	return OPERATOR_FINISHED;
 }
 
@@ -908,6 +935,13 @@
 /* called by other space types too */
 void IMAGE_OT_open(wmOperatorType *ot)
 {
+	PropertyRNA *prop;
+	static EnumPropertyItem open_actions[] = {
+			{IMA_LAYER_OPEN_IMAGE, "IMAGE", 0, "Image", "Open Image"},
+			{IMA_LAYER_OPEN_LAYER, "LAYER", 0, "Layer", "Open image as layer"},
+			{0, NULL, 0, NULL, NULL}
+	};
+
 	/* identifiers */
 	ot->name = "Open Image";
 	ot->description = "Open image";
@@ -921,6 +955,8 @@
 	/* flags */
 	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
 
+	prop = RNA_def_enum(ot->srna, "action", open_actions, IMA_LAYER_DEL_SELECTED, "Action", "Selection action to execute");
+	RNA_def_property_flag(prop, PROP_HIDDEN);
 	/* properties */
 	WM_operator_properties_filesel(ot, FOLDERFILE | IMAGEFILE | MOVIEFILE, FILE_SPECIAL, FILE_OPENFILE, WM_FILESEL_FILEPATH | WM_FILESEL_RELPATH, FILE_DEFAULTDISPLAY);
 }
@@ -1504,6 +1540,7 @@
 	char name[MAX_ID_NAME - 2];
 	float color[4];
 	int width, height, floatbuf, uvtestgrid, alpha;
+	short background;
 
 	/* retrieve state */
 	sima = CTX_wm_space_image(C);
@@ -1517,7 +1554,21 @@
 	uvtestgrid = RNA_boolean_get(op->ptr, "uv_test_grid");
 	RNA_float_get_array(op->ptr, "color", color);
 	alpha = RNA_boolean_get(op->ptr, "alpha");
-	
+	background = RNA_enum_get(op->ptr, "background");
+
+	if (background & IMA_LAYER_BG_WHITE) {
+		color[0] = 1.0f;
+		color[1] = 1.0f;
+		color[2] = 1.0f;
+		color[3] = 1.0f;
+	}
+	else if (background & IMA_LAYER_BG_ALPHA) {
+		color[0] = 0.0f;
+		color[1] = 0.0f;
+		color[2] = 0.0f;
+		color[3] = 0.0f;
+	}
+
 	if (!floatbuf && scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
 		linearrgb_to_srgb_v3_v3(color, color);
 
@@ -1525,7 +1576,8 @@
 		color[3] = 1.0f;
 
 	ima = BKE_add_image_size(width, height, name, alpha ? 32 : 24, floatbuf, uvtestgrid, color);
-
+	((ImageLayer *)ima->imlayers.last)->background = background;
+	copy_v4_v4(((ImageLayer *)ima->imlayers.first)->default_color, color);
 	if (!ima)
 		return OPERATOR_CANCELLED;
 
@@ -1560,8 +1612,17 @@
 void IMAGE_OT_new(wmOperatorType *ot)
 {
 	PropertyRNA *prop;
-	static float default_color[4] = {0.0f, 0.0f, 0.0f, 1.0f};
+	short background;
 	
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 1.0f};
+
+	static EnumPropertyItem prop_background_items[] = {
+		{IMA_LAYER_BG_RGB, "RGB", 0, "RGB", ""},
+		{IMA_LAYER_BG_WHITE, "WHITE", 0, "White", ""},
+		{IMA_LAYER_BG_ALPHA, "ALPHA", 0, "Transparent", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	
 	/* identifiers */
 	ot->name = "New Image";
 	ot->description = "Create a new image";
@@ -1570,7 +1631,7 @@
 	/* api callbacks */
 	ot->exec = image_new_exec;
 	ot->invoke = image_new_invoke;
-	
+		
 	/* flags */
 	ot->flag = OPTYPE_UNDO;
 
@@ -1578,11 +1639,14 @@
 	RNA_def_string(ot->srna, "name", "untitled", MAX_ID_NAME - 2, "Name", "Image datablock name");
 	RNA_def_int(ot->srna, "width", 1024, 1, INT_MAX, "Width", "Image width", 1, 16384);
 	RNA_def_int(ot->srna, "height", 1024, 1, INT_MAX, "Height", "Image height", 1, 16384);
-	prop = RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Color", "Default fill color", 0.0f, 1.0f);
+	RNA_def_enum(ot->srna, "background", prop_background_items, 0, "Background", "");
+
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Color", "Default fill color", 0.0f, 1.0f);
 	RNA_def_property_float_array_default(prop, default_color);
 	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel");
+	RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth");
 	RNA_def_boolean(ot->srna, "uv_test_grid", 0, "UV Test Grid", "Fill the image with a grid for UV map testing");
-	RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth");
+	
 }
 
 /********************* invert operators *********************/
@@ -1670,6 +1734,613 @@
 	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
 }
 
+/********************** new image layer operators *********************/
+
+int image_layer_poll(bContext *C)
+{	
+	SpaceImage *sima= CTX_wm_space_image(C);
+	return ED_space_image_show_paint(sima);
+}
+ 
+static int image_layer_add_exec(bContext *C, wmOperator *op)
+{	
+	char name[22];
+	float color[4];
+	int alpha, order;
+	Scene *scene;
+	Image *ima = CTX_data_edit_image(C);
+	ImageLayer *iml;
+	
+	scene= (Scene*)CTX_data_scene(C);
+
+	RNA_string_get(op->ptr, "name", name);
+	RNA_float_get_array(op->ptr, "color", color);
+	alpha = RNA_boolean_get(op->ptr, "alpha");
+
+	order = 2;
+	if (strcmp(op->idname, "IMAGE_OT_image_layer_add_above") == 0)
+		order = 1;
+	else if (strcmp(op->idname, "IMAGE_OT_image_layer_add_below") == 0)
+		order = -1;
+
+	if (scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
+		linearrgb_to_srgb_v3_v3(color, color);
+
+	if(!alpha) 
+		color[3] = 1.0f;
+	
+	iml = image_add_image_layer(ima, name, alpha ? 32 : 24, color, order);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_add(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "New Layer";
+	ot->idname= "IMAGE_OT_image_layer_add";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec = image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke = image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+void IMAGE_OT_image_layer_add_above(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "Above active layer";
+	ot->idname= "IMAGE_OT_image_layer_add_above";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke= image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+void IMAGE_OT_image_layer_add_below(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "Below active layer";
+	ot->idname= "IMAGE_OT_image_layer_add_below";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke= image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+static int image_layer_duplicate_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *iml;
+
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	iml = image_duplicate_current_image_layer(ima);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_duplicate(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name= "Duplicate Layer";
+	ot->idname= "IMAGE_OT_image_layer_duplicate";
+	ot->description="Duplicate the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_duplicate_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
+
+
+static int image_layer_remove_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	int action = RNA_enum_get(op->ptr, "action");
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	image_remove_layer(ima, action);
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_remove(wmOperatorType *ot)
+{
+	static EnumPropertyItem select_all_actions[] = {
+			{IMA_LAYER_DEL_SELECTED, "SELECTED", 0, "Selected", "Remove the selected layer"},
+			{IMA_LAYER_DEL_HIDDEN, "HIDDEN", 0, "Hidden", "Removes the hidden layers"},
+			{0, NULL, 0, NULL, NULL}
+	};
+
+	/* identifiers */
+	ot->name= "Remove Layer";
+	ot->idname= "IMAGE_OT_image_layer_remove";
+	ot->description="Remove the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_remove_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_enum(ot->srna, "action", select_all_actions, IMA_LAYER_DEL_SELECTED, "Action", "Selection action to execute");
+}
+
+static int image_layer_move_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer, *tmp;
+	int type, layerID;
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	layer = imalayer_get_current(ima);
+ 
+	if (!layer)
+		return OPERATOR_CANCELLED;
+ 
+	type = RNA_enum_get(op->ptr, "type");
+	layerID = imalayer_get_current_act(ima);
+	
+	if (!(layer->type & IMA_LAYER_BASE)) {
+		if (type == -1) { /* Move direction: Up */
+			if (layerID > 0) {
+				tmp = layer->prev;
+				BLI_remlink(&ima->imlayers, layer);
+				layer->next = layer->prev = NULL;
+				if (tmp) {
+					BLI_insertlinkbefore(&ima->imlayers, tmp, layer);
+				}
+				else {
+					BLI_addhead(&ima->imlayers, layer);
+				}
+				imalayer_set_current_act(ima, layerID-1);
+			}
+		}
+		else if (type == 1){ /* Move direction: Down */
+			if (layerID < (ima->Count_Layers - 1)) {
+				tmp = layer->next;
+				if (!(tmp->type & IMA_LAYER_BASE)) {
+					BLI_remlink(&ima->imlayers, layer);
+					layer->next = layer->prev = NULL;
+					if (tmp) {
+						BLI_insertlinkafter(&ima->imlayers, tmp, layer);
+					}
+					else {
+						BLI_addtail(&ima->imlayers, layer);
+					}	
+					imalayer_set_current_act(ima, layerID+1);
+				}
+			}
+		}
+		else if (type == -2) {  /* Move direction: Top */
+			BLI_remlink(&ima->imlayers, layer);
+			layer->next = layer->prev = NULL;
+			BLI_addhead(&ima->imlayers, layer);
+			ima->Act_Layers = 0;
+		}
+		else if (type == 2) {  /* Move direction: Bottom */
+			BLI_remlink(&ima->imlayers, layer);
+			layer->next = layer->prev = NULL;
+			if (((ImageLayer *)ima->imlayers.last)->type & IMA_LAYER_BASE) {
+				BLI_insertlink(&ima->imlayers,((ImageLayer *)ima->imlayers.last)->prev, layer);
+				ima->Act_Layers = ima->Count_Layers - 2;
+			}
+			else {
+				BLI_addtail(&ima->imlayers, layer);
+				ima->Act_Layers = ima->Count_Layers - 1;
+			}
+		}
+		else if (type == 3) {  /* Move direction: Invert */
+			int i = 0, lim;
+			ImageLayer *tmp1, *tmp2, *next, *prev, *tmp_up, *tmp_down;
+			if (ima->Count_Layers > 2) {
+				if (ima->Count_Layers % 2 == 0)
+					lim = (ima->Count_Layers / 2);
+				else
+					lim = (ima->Count_Layers / 2) + 1;
+
+				tmp_up = (ImageLayer *)ima->imlayers.first;
+				tmp_down = ((ImageLayer *)ima->imlayers.last)->prev;
+				while ((i<lim) && (tmp_up != tmp_down)) {
+					tmp1 = tmp_down;
+					tmp2 = tmp_up;
+
+					next = tmp_down->next;
+					prev = tmp_down->prev;
+					
+					tmp_down->next = tmp2->next;
+					tmp_down->prev = tmp2->prev;
+					if (tmp2->prev)
+						tmp2->prev->next = tmp_down;
+					else
+						ima->imlayers.first = tmp_down;
+					tmp2->next->prev = tmp_down;
+
+					tmp_up->next = next;
+					tmp_up->prev = prev;
+					if (prev)
+						prev->next = tmp_up;
+					next->prev = tmp_up;
+
+					prev = tmp_up->prev;
+					tmp_up = tmp_down->next;
+					tmp_down = prev;
+					i++;
+				}
+			}
+		}
+	}
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_move(wmOperatorType *ot)
+{
+	static EnumPropertyItem slot_move[] = {
+		{-2, "TOP", 0, "Top", ""},
+		{-1, "UP", 0, "Up", ""},
+		{1, "DOWN", 0, "Down", ""},
+		{2, "BOTTOM", 0, "Bottom", ""},
+		{3, "INVERT", 0, "Invert", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Move Layer";
+	ot->idname= "IMAGE_OT_image_layer_move";
+	ot->description="Move image layers up and down";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_move_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "type", slot_move, 0, "Type", "");
+}
+
+static int image_layer_select_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer;
+	int action = RNA_enum_get(op->ptr, "action");
+
+	layer = imalayer_get_current(ima);
+	
+	switch (action) {
+		case IMA_LAYER_SEL_PREVIOUS:
+			if (ima->Act_Layers >= 1) {
+				layer->select = !IMA_LAYER_SEL_CURRENT;
+				layer->prev->select = IMA_LAYER_SEL_CURRENT;
+				ima->Act_Layers--;
+			}
+			//else
+			//	layer->select = IMA_LAYER_SEL_CURRENT;
+			break;
+		case IMA_LAYER_SEL_NEXT:
+			if (ima->Act_Layers < (ima->Count_Layers-1)) {
+				layer->select = !IMA_LAYER_SEL_CURRENT;
+				layer->next->select = IMA_LAYER_SEL_CURRENT;
+				ima->Act_Layers++;
+			}
+			//else
+			//	layer->select = IMA_LAYER_SEL_CURRENT;
+			break;
+		case IMA_LAYER_SEL_TOP:
+			((ImageLayer *)ima->imlayers.first)->select = IMA_LAYER_SEL_CURRENT;
+			ima->Act_Layers = 0;
+			break;
+		case IMA_LAYER_SEL_BOTTOM:
+			((ImageLayer *)ima->imlayers.last)->select = IMA_LAYER_SEL_CURRENT;
+			ima->Act_Layers = ima->Count_Layers - 1;
+			break;
+	}
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_select(wmOperatorType *ot)
+{
+	static EnumPropertyItem select_all_actions[] = {
+			{IMA_LAYER_SEL_PREVIOUS, "PREVIOUS", 0, "Previous", "Select the previous layer"},
+			{IMA_LAYER_SEL_NEXT, "NEXT", 0, "Next", "Select the next layer"},
+			{IMA_LAYER_SEL_TOP, "TOP", 0, "Top", "Select the top layer"},
+			{IMA_LAYER_SEL_BOTTOM, "BOTTOM", 0, "Select the bottom layer"},
+			{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Select Layers";
+	ot->idname= "IMAGE_OT_image_layer_select";
+	ot->description="Select layers";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_select_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "action", select_all_actions, IMA_LAYER_SEL_NEXT, "Action", "Selection action to execute");
+}
+
+static int image_layer_merge_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer;
+	int type;
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+  
+	type = RNA_enum_get(op->ptr, "type");
+	
+	if (type == 1) { /* Merge Layers */
+		layer = imalayer_get_current(ima);
+		if (!layer)
+				return OPERATOR_CANCELLED;
+		
+		if (!(layer->type & IMA_LAYER_BASE)) {
+			ImageLayer *next;
+			
+			next = layer->next;
+			if ((next->visible & IMA_LAYER_VISIBLE) && (!(next->lock & IMA_LAYER_LOCK))) {
+				merge_layers(ima, layer, next);
+
+				imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+				ima->Count_Layers--;
+			}
+			else
+				if (!(next->visible & IMA_LAYER_VISIBLE))
+					BKE_report(op->reports, RPT_INFO, "It can not merge the layers, because the next layer is hidden");
+				else
+					BKE_report(op->reports, RPT_INFO, "It can not merge the layers, because the next layer is locked");
+		}
+	}
+	else if (type == 2) { /* Merge Visible */
+		int i=0;
+		ImageLayer *next;
+		for (layer = (ImageLayer *)ima->imlayers.first; layer; layer = layer->next) {
+			if (layer->visible & IMA_LAYER_VISIBLE) {
+				i = 1;
+				break;
+			}
+		}
+		if (i == 1) {
+			next = layer;
+			while ((next != NULL) && (layer->type != IMA_LAYER_BASE)) {
+				next = layer->next;
+				while ((next != NULL) && (!(next->visible & IMA_LAYER_VISIBLE)))
+					next = next->next;
+
+				if (next) {
+					layer = merge_layers(ima, layer, next);
+					ima->Count_Layers--;
+				}
+			}
+			imalayer_set_current_act(ima,imalayer_get_current_act(ima));
+		}
+		else
+			BKE_report(op->reports, RPT_INFO, "It can not merge the layers, because the layers are hidden");
+	}
+	else if (type == 3) {  /* Merge One */
+		ImageLayer *next, *app;
+		for (layer = (ImageLayer *)ima->imlayers.first; layer; layer = layer->next) {
+			if (layer->visible & IMA_LAYER_VISIBLE) {
+				break;
+			}
+			else {
+				BLI_remlink(&ima->imlayers, layer);
+				free_image_layer(layer);
+				ima->Count_Layers--;
+			}
+		}
+		if (ima->imlayers.first) {
+			next = layer;
+			while ((next != NULL) && (layer->type != IMA_LAYER_BASE)) {
+				next = layer->next;
+				while ((next != NULL) && (!(next->visible & IMA_LAYER_VISIBLE))) {
+					app = next;
+					next = next->next;
+
+					BLI_remlink(&ima->imlayers, app);
+					free_image_layer(app);
+					ima->Count_Layers--;
+				}
+				if (next) {
+					layer = merge_layers(ima, layer, next);
+					ima->Count_Layers--;
+				}
+			}
+			//imalayer_set_current_act(ima, 1);
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+			layer = (ImageLayer *)ima->imlayers.last;
+			if (!(layer->type & IMA_LAYER_BASE)) {
+				ImBuf *base;
+				int i;
+				
+				base = (ImBuf *)layer->ibufs.first;
+				if (base->rect_float) {
+					float *fp_b = (float *) base->rect_float;
+					for( i = base->x * base->y; i > 0; i--, fp_b+=4) {
+						if (fp_b[3] != 1.0f) {
+							if (fp_b[3] == 0.0f) {
+								fp_b[0] = 1.0f;
+								fp_b[1] = 1.0f;
+								fp_b[2] = 1.0f;
+							}
+							fp_b[3] = 1.0f;
+						}
+					}
+				} else if(base->rect) {
+					char *cp_b = (char *) base->rect;
+					for( i = base->x * base->y; i > 0; i--, cp_b+=4) {
+						if (cp_b[3] != 255) {
+							if (cp_b[3] == 0) {
+								cp_b[0] = 255;
+								cp_b[1] = 255;
+								cp_b[2] = 255;
+							}
+							cp_b[3] = 255;
+						}
+					}
+				}
+			}
+		}
+		else {
+			static float white_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};
+			image_add_image_layer_base(ima);
+			imalayer_fill_color(ima, white_color);
+		}
+	}
+	
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+ 
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_merge(wmOperatorType *ot)
+{
+	static EnumPropertyItem slot_merge[] = {
+		{1, "DOWN", 0, "Down", ""},
+		{2, "VISIBLE", 0, "Visible", ""},
+		{3, "ONE", 0, "One", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Merge Layer";
+	ot->idname= "IMAGE_OT_image_layer_merge";
+	ot->description="Layers merge into one";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_merge_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "type", slot_merge, 0, "Type", "");
+}
+
+static int image_layer_clean_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer;
+	static float alpha_color[4] = {0.0f, 0.0f, 0.0f, 0.0f};
+	static float white_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};
+
+	layer = imalayer_get_current(ima);
+
+	if (layer->background & IMA_LAYER_BG_IMAGE) {
+		int flag;
+		struct ImBuf *ibuf;
+
+		ibuf = layer->ibufs.first;
+		BLI_remlink(&layer->ibufs, ibuf);
+		IMB_freeImBuf(ibuf);
+
+		flag= IB_rect|IB_multilayer|IB_metadata;
+		if (ima->flag & IMA_DO_PREMUL)
+			flag |= IB_premul;
+
+		ibuf = IMB_loadiffname(layer->file_path, flag);
+		
+		BLI_addtail(&layer->ibufs, ibuf);
+	}
+	else if (layer->background & IMA_LAYER_BG_WHITE)
+		imalayer_fill_color(ima, white_color);
+	else if (layer->background & IMA_LAYER_BG_ALPHA)
+		imalayer_fill_color(ima, alpha_color);
+	else {
+		if (layer->default_color[0] != -1)
+			imalayer_fill_color(ima, layer->default_color);
+	}
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_clean(wmOperatorType *ot)
+{
+ 
+	/* identifiers */
+	ot->name= "Clean Layer";
+	ot->idname= "IMAGE_OT_image_layer_clean";
+	ot->description="Clean image layers";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_clean_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
 /********************* pack operator *********************/
 
 static int image_pack_test(bContext *C, wmOperator *op)
@@ -1860,7 +2531,7 @@
 	ImageSampleInfo *info = arg_info;
 	if (info->draw) {
 		/* no color management needed for images (color_manage=0) */
-		ED_image_draw_info(ar, 0, info->channels, info->x, info->y, info->colp, info->colfp, info->zp, info->zfp);
+		ED_image_draw_info(ar, 0, info->channels, info->x, info->y, info->colp, info->colfp, info->zp, info->zfp, 1);
 	}
 }
 
@@ -1872,12 +2543,14 @@
 	ImBuf *ibuf = ED_space_image_acquire_buffer(sima, &lock);
 	ImageSampleInfo *info = op->customdata;
 	float fx, fy;
+	//wmWindow *win= CTX_wm_window(C);
 	
 	if (ibuf == NULL) {
 		ED_space_image_release_buffer(sima, lock);
 		return;
 	}
 
+	//WM_cursor_modal(win, BC_EYEDROPPER_CURSOR);
 	UI_view2d_region_to_view(&ar->v2d, event->mval[0], event->mval[1], &fx, &fy);
 
 	if (fx >= 0.0f && fy >= 0.0f && fx < 1.0f && fy < 1.0f) {
@@ -1991,7 +2664,7 @@
 
 	if (!ED_space_image_has_buffer(sima))
 		return OPERATOR_CANCELLED;
-	
+
 	info = MEM_callocN(sizeof(ImageSampleInfo), "ImageSampleInfo");
 	info->art = ar->type;
 	info->draw_handle = ED_region_draw_cb_activate(ar->type, image_sample_draw, info, REGION_DRAW_POST_PIXEL);
@@ -2005,7 +2678,7 @@
 }
 
 static int image_sample_modal(bContext *C, wmOperator *op, wmEvent *event)
-{
+{	
 	switch (event->type) {
 		case LEFTMOUSE:
 		case RIGHTMOUSE: // XXX hardcoded
Index: source/blender/editors/space_image/space_image.c
===================================================================
--- source/blender/editors/space_image/space_image.c	(revisione 45659)
+++ source/blender/editors/space_image/space_image.c	(copia locale)
@@ -420,7 +420,7 @@
 	
 	BLI_addtail(&simage->regionbase, ar);
 	ar->regiontype = RGN_TYPE_WINDOW;
-	
+
 	return (SpaceLink *)simage;
 }
 
@@ -491,6 +491,17 @@
 
 	WM_operatortype_append(IMAGE_OT_properties);
 	WM_operatortype_append(IMAGE_OT_scopes);
+
+	WM_operatortype_append(IMAGE_OT_image_layer_move);
+	//WM_operatortype_append(IMAGE_OT_image_layer_fill_color);
+	WM_operatortype_append(IMAGE_OT_image_layer_remove);
+	WM_operatortype_append(IMAGE_OT_image_layer_add);
+	WM_operatortype_append(IMAGE_OT_image_layer_add_below);
+	WM_operatortype_append(IMAGE_OT_image_layer_add_above);
+	WM_operatortype_append(IMAGE_OT_image_layer_duplicate);
+	WM_operatortype_append(IMAGE_OT_image_layer_select);
+	WM_operatortype_append(IMAGE_OT_image_layer_clean);
+	WM_operatortype_append(IMAGE_OT_image_layer_merge);
 }
 
 static void image_keymap(struct wmKeyConfig *keyconf)
@@ -500,13 +511,32 @@
 	int i;
 	
 	WM_keymap_add_item(keymap, "IMAGE_OT_new", NKEY, KM_PRESS, KM_ALT, 0);
-	WM_keymap_add_item(keymap, "IMAGE_OT_open", OKEY, KM_PRESS, KM_ALT, 0);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_open", OKEY, KM_PRESS, KM_ALT, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_OPEN_IMAGE);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_open", OKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_OPEN_LAYER);
 	WM_keymap_add_item(keymap, "IMAGE_OT_reload", RKEY, KM_PRESS, KM_ALT, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_save", SKEY, KM_PRESS, KM_ALT, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_save_as", F3KEY, KM_PRESS, 0, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_properties", NKEY, KM_PRESS, 0, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_scopes", TKEY, KM_PRESS, 0, 0);
 
+	/*Layers*/
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add", NKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add_above", UPARROWKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add_below", DOWNARROWKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_select", PAGEUPKEY, KM_PRESS, 0, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_SEL_PREVIOUS);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_select", PAGEDOWNKEY, KM_PRESS, 0, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_SEL_NEXT);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_select", HOMEKEY, KM_PRESS, 0, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_SEL_TOP);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_select", ENDKEY, KM_PRESS, 0, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_SEL_BOTTOM);
+
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_clean", DELKEY, KM_PRESS, 0, 0);
+
 	WM_keymap_add_item(keymap, "IMAGE_OT_cycle_render_slot", JKEY, KM_PRESS, 0, 0);
 	RNA_boolean_set(WM_keymap_add_item(keymap, "IMAGE_OT_cycle_render_slot", JKEY, KM_PRESS, KM_ALT, 0)->ptr, "reverse", TRUE);
 	
@@ -850,6 +880,7 @@
 	}
 }
 
+
 /* *********************** buttons region ************************ */
 
 /* add handlers, stuff you only do once or on area/region changes */
Index: source/blender/editors/space_node/node_edit.c
===================================================================
--- source/blender/editors/space_node/node_edit.c	(revisione 45659)
+++ source/blender/editors/space_node/node_edit.c	(copia locale)
@@ -1348,8 +1348,8 @@
 
 	ED_image_draw_info(ar, (scene->r.color_mgt_flag & R_COLOR_MANAGEMENT), info->channels,
 	                   info->x, info->y, info->col, info->colf,
-	                   NULL, NULL /* zbuf - unused for nodes */
-	                   );
+	                   NULL, NULL, /* zbuf - unused for nodes */
+	                   1);
 }
 
 static void sample_apply(bContext *C, wmOperator *op, wmEvent *event)
Index: source/blender/makesdna/DNA_ID.h
===================================================================
--- source/blender/makesdna/DNA_ID.h	(revisione 45659)
+++ source/blender/makesdna/DNA_ID.h	(copia locale)
@@ -184,6 +184,7 @@
 #define ID_MA		MAKE_ID2('M', 'A') /* Material */
 #define ID_TE		MAKE_ID2('T', 'E') /* Texture */
 #define ID_IM		MAKE_ID2('I', 'M') /* Image */
+//#define ID_IL		MAKE_ID2('I', 'L') /* ImageLayer */
 #define ID_LT		MAKE_ID2('L', 'T') /* Lattice */
 #define ID_LA		MAKE_ID2('L', 'A') /* Lamp */
 #define ID_CA		MAKE_ID2('C', 'A') /* Camera */
Index: source/blender/makesdna/DNA_image_types.h
===================================================================
--- source/blender/makesdna/DNA_image_types.h	(revisione 45659)
+++ source/blender/makesdna/DNA_image_types.h	(copia locale)
@@ -34,6 +34,10 @@
 
 #include "DNA_ID.h"
 
+#ifndef MAX_LIMA
+#define MAX_LIMA	18
+#endif
+
 struct PackedFile;
 struct Scene;
 struct anim;
@@ -66,6 +70,209 @@
 #define IMA_ANIM_REFRESHED	2
 /* #define IMA_DO_PREMUL	4 */
 
+
+typedef struct ImageLayer {
+	struct ImageLayer *next, *prev;
+	//ID id;
+	//struct PreviewImage * preview;
+	char name[64];
+	char file_path[1024];
+	short background;
+	short color_space;
+	float opacity;
+	short mode;
+	short type;
+	short visible;
+	short select;
+	short lock;
+	short pad1;
+	int pad2;
+	//int icon_id;
+	float default_color[4];
+	ListBase ibufs;
+}ImageLayer;
+
+/* **************** IMAGE LAYER********************* */
+#define IMA_LAYER_MAX_LEN	64
+
+/* ImageLayer.background */
+#define IMA_LAYER_BG_RGB		(1<<0)
+#define IMA_LAYER_BG_WHITE		(1<<1)
+#define IMA_LAYER_BG_ALPHA		(1<<2)
+#define IMA_LAYER_BG_IMAGE		(1<<3)
+
+/* ImageLayer.color_space */
+#define IMA_LAYER_COL_RGB		(1<<0)
+#define IMA_LAYER_COL_GRAY		(1<<1)
+
+/* ImageLayer.mode */
+#define IMA_LAYER_NORMAL 		0
+
+#define IMA_LAYER_MULTIPLY		1
+#define IMA_LAYER_SCREEN		2
+#define IMA_LAYER_OVERLAY		3
+#define IMA_LAYER_SOFT_LIGHT	4
+#define IMA_LAYER_HARD_LIGHT	5
+
+#define IMA_LAYER_COLOR_DODGE	6
+#define IMA_LAYER_LINEAR_DODGE	7
+#define IMA_LAYER_COLOR_BURN	8
+#define IMA_LAYER_LINEAR_BURN	9
+
+#define IMA_LAYER_AVERAGE		10
+#define IMA_LAYER_ADD			11
+#define IMA_LAYER_SUBTRACT		12
+#define IMA_LAYER_DIFFERENCE	13
+#define IMA_LAYER_LIGHTEN		14
+#define IMA_LAYER_DARKEN		15
+
+#define IMA_LAYER_NEGATION		16
+#define IMA_LAYER_EXCLUSION		17
+
+#define IMA_LAYER_LINEAR_LIGHT	18
+#define IMA_LAYER_VIVID_LIGHT	19
+#define IMA_LAYER_PIN_LIGHT		20
+#define IMA_LAYER_HARD_MIX		21
+
+/*#define ChannelBlend_Reflect(A,B)    ((uint8)((B == 255) ? B:min(255, (A * A / (255 - B)))))
+#define ChannelBlend_Glow(A,B)       (ChannelBlend_Reflect(B,A))
+#define ChannelBlend_Phoenix(A,B)    ((uint8)(min(A,B) - max(A,B) + 255))
+#define ChannelBlend_Alpha(A,B,O)    ((uint8)(O * A + (1 - O) * B))
+#define ChannelBlend_AlphaF(A,B,F,O) (ChannelBlend_Alpha(F(A,B),A,O))
+
+#define ColorBlend_Hue(T,A,B)            ColorBlend_Hls(T,A,B,HueB,LuminationA,SaturationA)
+#define ColorBlend_Saturation(T,A,B)     ColorBlend_Hls(T,A,B,HueA,LuminationA,SaturationB)
+#define ColorBlend_Color(T,A,B)          ColorBlend_Hls(T,A,B,HueB,LuminationA,SaturationB)
+#define ColorBlend_Luminosity(T,A,B)     ColorBlend_Hls(T,A,B,HueA,LuminationB,SaturationA)
+
+#define ColorBlend_Hls(T,A,B,O1,O2,O3) {
+    float64 HueA, LuminationA, SaturationA;
+    float64 HueB, LuminationB, SaturationL;
+    Color_RgbToHls((A)[2],(A)[1],(A)[0], &HueA, &LuminationA, &SaturationA);
+    Color_RgbToHls((B)[2],(B)[1],(B)[0], &HueB, &LuminationB, &SaturationB);
+    Color_HlsToRgb(O1,O2,O3,&(T)[2],&(T)[1],&(T)[0]);
+    }
+
+int32 Color_HueToRgb(float64 M1, float64 M2, float64 Hue, float64 *Channel)
+{
+    if (Hue < 0.0)
+        Hue += 1.0;
+    else if (Hue > 1.0)
+        Hue -= 1.0;
+
+    if ((6.0 * Hue) < 1.0)
+        *Channel = (M1 + (M2 - M1) * Hue * 6.0);
+    else if ((2.0 * Hue) < 1.0)
+        *Channel = (M2);
+    else if ((3.0 * Hue) < 2.0)
+        *Channel = (M1 + (M2 - M1) * ((2.0F / 3.0F) - Hue) * 6.0);
+    else
+        *Channel = (M1);
+
+    return TRUE;
+}
+
+int32 Color_RgbToHls(uint8 Red, uint8 Green, uint8 Blue, float64 *Hue, float64 *Lumination, float64 *Saturation)
+{
+    float64 Delta;
+    float64 Max, Min;
+    float64 Redf, Greenf, Bluef;
+
+    Redf    = ((float64)Red   / 255.0F);
+    Greenf  = ((float64)Green / 255.0F);
+    Bluef   = ((float64)Blue  / 255.0F); 
+
+    Max     = max(max(Redf, Greenf), Bluef);
+    Min     = min(min(Redf, Greenf), Bluef);
+
+    *Hue        = 0;
+    *Lumination = (Max + Min) / 2.0F;
+    *Saturation = 0;
+
+    if (Max == Min)
+        return TRUE;
+
+    Delta = (Max - Min);
+
+    if (*Lumination < 0.5)
+        *Saturation = Delta / (Max + Min);
+    else
+        *Saturation = Delta / (2.0 - Max - Min);
+
+    if (Redf == Max)
+        *Hue = (Greenf - Bluef) / Delta;
+    else if (Greenf == Max)
+        *Hue = 2.0 + (Bluef - Redf) / Delta;
+    else
+        *Hue = 4.0 + (Redf - Greenf) / Delta;
+
+    *Hue /= 6.0; 
+
+    if (*Hue < 0.0)
+        *Hue += 1.0;       
+
+    return TRUE;
+}
+
+int32 Color_HlsToRgb(float64 Hue, float64 Lumination, float64 Saturation, uint8 *Red, uint8 *Green, uint8 *Blue)
+{
+    float64 M1, M2;
+    float64 Redf, Greenf, Bluef;
+
+    if (Saturation == 0)
+        {
+        Redf    = Lumination;
+        Greenf  = Lumination;
+        Bluef   = Lumination;
+        }
+    else
+        {
+        if (Lumination <= 0.5)
+            M2 = Lumination * (1.0 + Saturation);
+        else
+            M2 = Lumination + Saturation - Lumination * Saturation;
+
+        M1 = (2.0 * Lumination - M2);
+
+        Color_HueToRgb(M1, M2, Hue + (1.0F / 3.0F), &Redf);
+        Color_HueToRgb(M1, M2, Hue, &Greenf);
+        Color_HueToRgb(M1, M2, Hue - (1.0F / 3.0F), &Bluef);
+        }
+
+    *Red    = (uint8)(Redf * 255);
+    *Blue   = (uint8)(Bluef * 255);
+    *Green  = (uint8)(Greenf * 255);
+
+    return TRUE;
+}
+
+*/
+
+/* ImageLayer.type */
+#define IMA_LAYER_BASE		(1<<0)
+#define IMA_LAYER_LAYER		(1<<1)
+
+/* ImageLayer.visible */
+#define IMA_LAYER_VISIBLE	(1<<0)
+
+/* ImageLayer.select */
+#define IMA_LAYER_SEL_CURRENT	(1<<0)
+#define	IMA_LAYER_SEL_PREVIOUS	(1<<1)
+#define	IMA_LAYER_SEL_NEXT		(1<<2)
+#define IMA_LAYER_SEL_TOP		(1<<3)
+#define IMA_LAYER_SEL_BOTTOM	(1<<4)
+
+/* ImageLayer.lock */
+#define IMA_LAYER_LOCK		(1<<0)
+
+/* Option for delete the layer*/
+#define IMA_LAYER_DEL_SELECTED	(1<<0)
+#define IMA_LAYER_DEL_HIDDEN	(1<<1)
+
+/* Option for open a image*/
+#define IMA_LAYER_OPEN_IMAGE	(1<<0)
+#define IMA_LAYER_OPEN_LAYER	(1<<1)
+
 typedef struct Image {
 	ID id;
 	
@@ -106,6 +313,9 @@
 	
 	/* display aspect - for UV editing images resized for faster openGL display */
 	float aspx, aspy;
+	int Act_Layers;
+	int Count_Layers;
+	ListBase imlayers;
 } Image;
 
 
Index: source/blender/makesdna/DNA_userdef_types.h
===================================================================
--- source/blender/makesdna/DNA_userdef_types.h	(revisione 45659)
+++ source/blender/makesdna/DNA_userdef_types.h	(copia locale)
@@ -258,9 +258,16 @@
 	char preview_stitch_stitchable[4];
 	char preview_stitch_unstitchable[4];
 	char preview_stitch_active[4];
+
+	char b_pad[3];
+	char show_boundary_layer;
+	char col1_boundary_layer[4];
+	char col2_boundary_layer[4];
 	
+
 	char match[4];				/* outliner - filter match */
 	char selected_highlight[4];	/* outliner - selected item */
+	char pad1[4];
 } ThemeSpace;
 
 
@@ -611,6 +618,9 @@
 #define TH_OLDSKOOL 	3
 #define TH_SHADED   	4
 
+/* Active boundarie_layer */
+#define TH_IMAGE_LAYER_BOUNDARY (1<<0)
+
 /* ndof_flag (3D mouse options) */
 #define NDOF_SHOW_GUIDE     (1 << 0)
 #define NDOF_FLY_HELICOPTER (1 << 1)
Index: source/blender/makesrna/intern/rna_image.c
===================================================================
--- source/blender/makesrna/intern/rna_image.c	(revisione 45659)
+++ source/blender/makesrna/intern/rna_image.c	(copia locale)
@@ -38,6 +38,7 @@
 #include "BKE_context.h"
 #include "BKE_depsgraph.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 
 #include "WM_types.h"
 #include "WM_api.h"
@@ -286,6 +287,62 @@
 	return planes;
 }
 
+static PointerRNA rna_Image_active_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= imalayer_get_current(ima);
+ 
+	return rna_pointer_inherit_refine(ptr, &RNA_ImageLayer, layer);
+}
+
+static void rna_Image_active_image_layer_set(PointerRNA *ptr, PointerRNA value)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= (ImageLayer*)value.data;
+	const int index= BLI_findindex(&ima->imlayers, layer);
+	if (index != -1) ima->Act_Layers= index;
+}
+
+static void rna_Image_layers_begin(CollectionPropertyIterator *iter, PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	rna_iterator_listbase_begin(iter, &ima->imlayers, NULL);
+}
+
+static int rna_Image_count_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_count(ima);
+}
+
+static int rna_Image_active_image_layer_index_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_current_act(ima);
+}
+ 
+static void rna_Image_active_image_layer_index_set(PointerRNA *ptr, int value)
+{
+	Image *ima= (Image*)ptr->data;
+	imalayer_set_current_act(ima, value);
+}
+ 
+static void rna_Image_active_image_layer_index_range(PointerRNA *ptr, int *min, int *max)
+{
+	Image *im= (Image*)ptr->data;
+	void *lock;
+	ImBuf *ibuf= BKE_image_acquire_ibuf(im, NULL, &lock);
+
+	/**min= 0;
+	*max= BLI_countlist(&im->imlayers)-1;
+	*max= MAX2(0, *max);*/
+	*min= BLI_countlist(&im->imlayers)-1;
+	*max= 0;
+	*min= MAX2(0, *min);
+
+	BKE_image_release_ibuf(im, lock);
+}
+
 static int rna_Image_pixels_get_length(PointerRNA *ptr, int length[RNA_MAX_ARRAY_DIMENSION])
 {
 	Image *ima = ptr->id.data;
@@ -413,6 +470,136 @@
 	RNA_def_property_ui_text(prop, "Pass", "Pass in multilayer image");
 }
 
+static void rna_def_image_layer_common(StructRNA *srna)
+{
+	PropertyRNA *prop;
+
+	static EnumPropertyItem prop_type_items[] = {
+		{IMA_LAYER_BASE, "BASE", 0, "Base", ""},
+		{IMA_LAYER_LAYER, "LAYER", 0, "Layer", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	static EnumPropertyItem prop_background_items[] = {
+		{IMA_LAYER_BG_RGB, "RGB", 0, "RGB", ""},
+		{IMA_LAYER_BG_WHITE, "WHITE", 0, "White", ""},
+		{IMA_LAYER_BG_ALPHA, "ALPHA", 0, "Transparent", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	static EnumPropertyItem prop_blend_type_items[] = {
+		{IMA_LAYER_NORMAL, "NORMAL", 0, "Normal", ""},
+		{IMA_LAYER_MULTIPLY, "MULTIPLY", 0, "Multiply", ""},
+		{IMA_LAYER_SCREEN, "SCREEN", 0, "Screen", ""},
+		{IMA_LAYER_OVERLAY, "OVERLAY", 0, "Overlay", ""},
+		{IMA_LAYER_SOFT_LIGHT, "SOFT_LIGHT", 0, "Soft Light", ""},
+		{IMA_LAYER_HARD_LIGHT, "HARD_LIGHT", 0, "Hard Light", ""},
+		{IMA_LAYER_COLOR_DODGE, "COLOR_DODGE", 0, "Color Dodge", ""},
+		{IMA_LAYER_LINEAR_DODGE, "LINEAR_DODGE", 0, "Linear Dodge", ""},
+		{IMA_LAYER_COLOR_BURN, "COLOR_BURN", 0, "Color Burn", ""},
+		{IMA_LAYER_LINEAR_BURN, "LINEAR_BURN", 0, "Linear Burn", ""},
+		{IMA_LAYER_AVERAGE, "AVERAGE", 0, "Average", ""},
+		{IMA_LAYER_ADD, "ADD", 0, "Add", ""},
+		{IMA_LAYER_SUBTRACT, "SUBTRACT", 0, "Subtract", ""},
+		{IMA_LAYER_DIFFERENCE, "DIFFERENCE", 0, "Difference", ""},
+		{IMA_LAYER_LIGHTEN, "LIGHTEN", 0, "Lighten", ""}, 
+		{IMA_LAYER_DARKEN, "DARKEN", 0, "Darken", ""}, 
+		{IMA_LAYER_NEGATION, "NEGATION", 0, "Negation", ""},
+		{IMA_LAYER_EXCLUSION, "EXCLUSION", 0, "Exclusion", ""},
+		{IMA_LAYER_LINEAR_LIGHT, "LINEAR_LIGHT", 0, "Linear Light", ""},
+		{IMA_LAYER_VIVID_LIGHT, "VIVID_LIGHT", 0, "Vivid Light", ""},
+		{IMA_LAYER_PIN_LIGHT, "PIN_LIGHT", 0, "Pin Light", ""}, 
+		{IMA_LAYER_HARD_MIX, "HARD_LIGHT", 0, "Hard Light", ""},
+		{0, NULL, 0, NULL, NULL}};
+	
+	prop= RNA_def_property(srna, "name", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_default(prop, "ImageLayer");
+	RNA_def_property_string_maxlength(prop, IMA_LAYER_MAX_LEN);
+	RNA_def_property_update(prop, NC_OBJECT|ND_MODIFIER|NA_RENAME, NULL);
+	RNA_def_property_ui_text(prop, "Name", "The name of the image layer.");
+	RNA_def_struct_name_property(srna, prop);
+
+ 	prop= RNA_def_property(srna, "visible", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_ui_text(prop, "", "Hides the layer in the UV/Image Editor");
+	RNA_def_property_boolean_sdna(prop, NULL, "visible", IMA_LAYER_VISIBLE);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "lock", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_ui_text(prop, "", "Blocks the layer in the UV/Image Editor");
+	RNA_def_property_boolean_sdna(prop, NULL, "lock", IMA_LAYER_LOCK);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "opacity", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "opacity");
+	RNA_def_property_range(prop, 0.0, 1.0);
+	RNA_def_property_ui_range(prop, 0, 1.0, 1, 3);
+	RNA_def_property_ui_text(prop, "Opacity", "The opacity of the image layer when blended.");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "blend_type", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "mode");
+	RNA_def_property_enum_items(prop, prop_blend_type_items);
+	RNA_def_property_ui_text(prop, "Blend Modes", "Determine how two Layers are blended into each other.");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "background", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "background");
+	RNA_def_property_enum_items(prop, prop_background_items);
+	RNA_def_property_ui_text(prop, "Type Background", "");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "type", PROP_ENUM, PROP_NONE);
+	//RNA_def_property_ui_text(prop, "", "Defines the type of layer");
+	//RNA_def_property_boolean_sdna(prop, NULL, "type", IMA_LAYER_BASE);
+	RNA_def_property_enum_sdna(prop, NULL, "type");
+	RNA_def_property_enum_items(prop, prop_type_items);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
+static void rna_def_image_layer(BlenderRNA *brna)
+{
+	StructRNA *srna;
+		
+	srna= RNA_def_struct(brna, "ImageLayer", NULL);
+	RNA_def_struct_ui_text(srna, "Image Layer", "Image layer");
+	RNA_def_struct_ui_icon(srna, ICON_TEXTURE_DATA);
+
+	rna_def_image_layer_common(srna);
+}
+
+static void rna_def_image_layers(BlenderRNA *brna, PropertyRNA *cprop)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	FunctionRNA *func;
+	PropertyRNA *parm;
+
+	RNA_def_property_srna(cprop, "ImageLayers");
+	srna= RNA_def_struct(brna, "ImageLayers", NULL);
+	RNA_def_struct_sdna(srna, "Image");
+	RNA_def_struct_ui_text(srna, "Image Layers", "Image layer");
+
+	prop= RNA_def_property(srna, "active_image_layer", PROP_POINTER, PROP_NONE);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_pointer_funcs(prop, "rna_Image_active_image_layer_get", 
+								   "rna_Image_active_image_layer_set", NULL, NULL);
+	RNA_def_property_flag(prop, PROP_EDITABLE|PROP_NEVER_NULL);
+	RNA_def_property_ui_text(prop, "Active Image Layer", "Active image layer");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+ 
+	prop= RNA_def_property(srna, "active_image_layer_index", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Act_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_active_image_layer_index_get", "rna_Image_active_image_layer_index_set", 
+							   "rna_Image_active_image_layer_index_range");
+	RNA_def_property_ui_text(prop, "Active Image Layer Index", "Index of active image layer slot");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "count_image_layers", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Count_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_count_image_layer_get", NULL, NULL);
+	RNA_def_property_ui_text(prop, "Total number of layers", "");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
 static void rna_def_image(BlenderRNA *brna)
 {
 	StructRNA *srna;
@@ -479,6 +666,14 @@
 	RNA_def_property_ui_text(prop, "Field Order", "Order of video fields (select which lines are displayed first)");
 	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
 	
+	/* Image Layers */
+ 	prop= RNA_def_property(srna, "image_layers", PROP_COLLECTION, PROP_NONE);
+	RNA_def_property_collection_sdna(prop, NULL, "imlayers", NULL);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_collection_funcs(prop, "rna_Image_layers_begin", "rna_iterator_listbase_next", "rna_iterator_listbase_end", "rna_iterator_listbase_get", 0, 0, 0, 0);
+	RNA_def_property_ui_text(prop, "Image Layers", "");
+	rna_def_image_layers(brna, prop);
+
 	/* booleans */
 	prop = RNA_def_property(srna, "use_fields", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "flag", IMA_FIELDS);
@@ -636,6 +831,7 @@
 
 void RNA_def_image(BlenderRNA *brna)
 {
+	rna_def_image_layer(brna);
 	rna_def_image(brna);
 	rna_def_imageuser(brna);
 }
Index: source/blender/makesrna/intern/rna_ui_api.c
===================================================================
--- source/blender/makesrna/intern/rna_ui_api.c	(revisione 45659)
+++ source/blender/makesrna/intern/rna_ui_api.c	(copia locale)
@@ -388,6 +388,14 @@
 	RNA_def_boolean(func, "lock_luminosity", 0, "", "Keep the color at its original vector length");
 	RNA_def_boolean(func, "cubic", 1, "", "Cubic saturation for picking values close to white");
 
+	func = RNA_def_function(srna, "template_color", "uiTemplateColor");
+	RNA_def_function_ui_description(func, "Item. A color widget to pick colors");
+	api_ui_item_rna_common(func);
+	RNA_def_boolean(func, "value_slider", 0, "", "Display the value slider to the bottom of the color wheel");
+	RNA_def_boolean(func, "lock", 0, "", "Lock the color wheel display to value 1.0 regardless of actual color");
+	RNA_def_boolean(func, "lock_luminosity", 0, "", "Keep the color at its original vector length");
+	RNA_def_boolean(func, "cubic", 1, "", "Cubic saturation for picking values close to white");
+
 	func = RNA_def_function(srna, "template_image_layers", "uiTemplateImageLayers");
 	RNA_def_function_flag(func, FUNC_USE_CONTEXT);
 	parm = RNA_def_pointer(func, "image", "Image", "", "");
Index: source/blender/makesrna/intern/rna_userdef.c
===================================================================
--- source/blender/makesrna/intern/rna_userdef.c	(revisione 45659)
+++ source/blender/makesrna/intern/rna_userdef.c	(copia locale)
@@ -1705,6 +1705,24 @@
 	RNA_def_property_array(prop, 4);
 	RNA_def_property_ui_text(prop, "Stitch preview active island", "");
 	RNA_def_property_update(prop, 0, "rna_userdef_update");
+
+	prop= RNA_def_property(srna, "show_boundary_layer", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "show_boundary_layer", TH_IMAGE_LAYER_BOUNDARY);
+	RNA_def_property_ui_text(prop, "Show Layer Boundary", "When enabled, the layer boundary is visible by default");
+	RNA_def_property_update(prop, 0, "rna_userdef_update");
+
+	prop = RNA_def_property(srna, "col1_boundary_layer", PROP_FLOAT, PROP_COLOR_GAMMA);
+	RNA_def_property_float_sdna(prop, NULL, "col1_boundary_layer");
+	RNA_def_property_array(prop, 4);
+	RNA_def_property_ui_text(prop, "Color 1 Boundary Layer", "");
+	RNA_def_property_update(prop, 0, "rna_userdef_update");
+
+	prop = RNA_def_property(srna, "col2_boundary_layer", PROP_FLOAT, PROP_COLOR_GAMMA);
+	RNA_def_property_float_sdna(prop, NULL, "col2_boundary_layer");
+	RNA_def_property_array(prop, 4);
+	RNA_def_property_ui_text(prop, "Color 2 Boundary Layer", "");
+	RNA_def_property_update(prop, 0, "rna_userdef_update");
+
 }
 
 static void rna_def_userdef_theme_space_seq(BlenderRNA *brna)
Index: source/blender/makesrna/RNA_access.h
===================================================================
--- source/blender/makesrna/RNA_access.h	(revisione 45659)
+++ source/blender/makesrna/RNA_access.h	(copia locale)
@@ -257,6 +257,7 @@
 extern StructRNA RNA_ID;
 extern StructRNA RNA_IKParam;
 extern StructRNA RNA_Image;
+extern StructRNA RNA_ImageLayer;
 extern StructRNA RNA_ImageFormatSettings;
 extern StructRNA RNA_ImagePaint;
 extern StructRNA RNA_ImageSequence;
Index: source/blenderplayer/bad_level_call_stubs/stubs.c
===================================================================
--- source/blenderplayer/bad_level_call_stubs/stubs.c	(revisione 45659)
+++ source/blenderplayer/bad_level_call_stubs/stubs.c	(copia locale)
@@ -414,6 +414,7 @@
 void uiTemplateImage(struct uiLayout *layout, struct bContext *C, struct PointerRNA *ptr, char *propname, struct PointerRNA *userptr, int compact){}
 void uiTemplateDopeSheetFilter(struct uiLayout *layout, struct bContext *C, struct PointerRNA *ptr){}
 void uiTemplateColorWheel(struct uiLayout *layout, struct PointerRNA *ptr, char *propname, int value_slider){}
+void uiTemplateColor(struct uiLayout *layout, struct PointerRNA *ptr, char *propname, int value_slider){}
 void uiTemplateHistogram(struct uiLayout *layout, struct PointerRNA *ptr, char *propname, int expand){}
 void uiTemplateReportsBanner(struct uiLayout *layout, struct bContext *C, struct wmOperator *op){}
 void uiTemplateWaveform(struct uiLayout *layout, struct PointerRNA *ptr, char *propname, int expand){}
Index: release/scripts/startup/bl_ui/space_image.py
===================================================================
--- release/scripts/startup/bl_ui/space_image.py	(revisione 45704)
+++ release/scripts/startup/bl_ui/space_image.py	(copia locale)
@@ -117,11 +117,16 @@
         ima = sima.image
 
         layout.operator("image.new")
-        layout.operator("image.open")
+        layout.operator("image.open", text="Open Image").action = 'IMAGE'
+        
 
         show_render = sima.show_render
+        show_paint = sima.show_paint
 
         if ima:
+            if show_paint:
+                layout.operator("image.open", text="Open as Layer").action = 'LAYER'
+
             if not show_render:
                 layout.operator("image.replace")
                 layout.operator("image.reload")
@@ -160,6 +165,85 @@
             layout.separator()
 
 
+class IMAGE_MT_layers(Menu):
+    bl_label = "Layer"
+
+    def draw(self, context):
+        layout = self.layout
+
+        sima = context.space_data
+        ima = sima.image
+
+        layout.menu("IMAGE_MT_layers_new", icon='NEW')
+        # layout.operator("image.open")
+        layout.operator("image.image_layer_duplicate", icon='GHOST')
+        layout.operator("image.image_layer_clean", icon='FILE')
+        layout.menu("IMAGE_MT_layers_remove", icon='CANCEL')
+        layout.menu("IMAGE_MT_layers_merge", icon='LINK_AREA')
+        layout.separator()
+        layout.menu("IMAGE_MT_layers_select", icon='FILE_TICK')
+        layout.menu("IMAGE_MT_layers_order", icon='SORTALPHA')
+
+
+class IMAGE_MT_layers_new(Menu):
+    bl_label = "Add"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_add", icon='NEW')
+        layout.separator()
+        layout.operator("image.image_layer_add_above", icon='TRIA_UP')
+        layout.operator("image.image_layer_add_below", icon='TRIA_DOWN')
+
+
+class IMAGE_MT_layers_select(Menu):
+    bl_label = "Select"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_select", text="Select Previous Layer").action = 'PREVIOUS'
+        layout.operator("image.image_layer_select", text="Select Next Layer" ).action = 'NEXT'
+        layout.operator("image.image_layer_select", text="Select Top Layer").action = 'TOP'
+        layout.operator("image.image_layer_select", text="Select Bottom Layer").action = 'BOTTOM'
+
+
+class IMAGE_MT_layers_order(Menu):
+    bl_label = "Order"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_move", text="Layer the Top").type = 'TOP'
+        layout.operator("image.image_layer_move", text="Raise Layer", icon='TRIA_UP').type = 'UP'
+        layout.operator("image.image_layer_move", text="Lower Layer", icon='TRIA_DOWN').type = 'DOWN'
+        layout.operator("image.image_layer_move", text="Layer the Bottom").type = 'BOTTOM'
+        layout.separator()
+        layout.operator("image.image_layer_move", text="Invert").type = 'INVERT'
+
+
+class IMAGE_MT_layers_remove(Menu):
+    bl_label = "Remove"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_remove", text="Layer").action = 'SELECTED'
+        layout.operator("image.image_layer_remove", text="Hidden Layers" ).action = 'HIDDEN'
+
+
+class IMAGE_MT_layers_merge(Menu):
+    bl_label = "Merge"
+
+    def draw(self, context):
+        layout = self.layout
+
+        layout.operator("image.image_layer_merge", text="Merge Down").type = 'DOWN'
+        layout.operator("image.image_layer_merge", text="Merge Visible" ).type = 'VISIBLE'
+        layout.operator("image.image_layer_merge", text="Merge All" ).type = 'ONE'
+
+
 class IMAGE_MT_image_invert(Menu):
     bl_label = "Invert"
 
@@ -355,7 +439,7 @@
         toolsettings = context.tool_settings
 
         show_render = sima.show_render
-        # show_paint = sima.show_paint
+        show_paint = sima.show_paint
         show_uvedit = sima.show_uvedit
 
         row = layout.row(align=True)
@@ -374,6 +458,9 @@
             else:
                 sub.menu("IMAGE_MT_image", text="Image")
 
+            if show_paint:
+                sub.menu("IMAGE_MT_layers", text="Layer")
+
             if show_uvedit:
                 sub.menu("IMAGE_MT_uvs")
 
@@ -647,6 +734,57 @@
             sub.row().prop(uvedit, "draw_stretch_type", expand=True)
 
 
+class IMAGE_PT_image_layers(Panel, ImagePaintPanel):
+    bl_label = "Image Layers"
+
+    @classmethod
+    def poll(cls, context):
+        sima = context.space_data
+        return sima.show_paint
+
+    def draw(self, context):
+        layout = self.layout
+        sima = context.space_data
+        ima = sima.image
+        layers = ima.image_layers
+
+        if ima:
+            row = layout.row()
+            row.template_list(ima, "image_layers", ima.image_layers, "active_image_layer_index", 
+                              rows=5, maxrows=5)
+
+            col = row.column(align=True)
+            col.operator("image.image_layer_add", text="", icon='NEW')
+            
+            if layers.active_image_layer:
+                col.operator("image.image_layer_duplicate", text="", icon='GHOST')
+                sub = col.column()
+                
+                if (layers.active_image_layer.type == 'BASE'):
+                    sub.enabled = False
+                else:
+                    sub.enabled = True
+                sub.operator("image.image_layer_remove", text="", icon='CANCEL').action = 'SELECTED'
+                col.operator("image.image_layer_move", text="", icon='TRIA_UP').type = 'UP'
+                col.operator("image.image_layer_move", text="", icon='TRIA_DOWN').type = 'DOWN'
+                split = layout.split(percentage=0.35)
+                col = split.column()
+                col.label(text="Name")
+                col.label(text="Opacity:")
+                col.label(text="Blend Modes:")
+                col = split.column()
+                col.prop(layers.active_image_layer, "name", text="")
+                sub = col.column()
+                if (((layers.active_image_layer.background != 'ALPHA') and 
+                    (layers.active_image_layer.type == 'BASE')) or
+                    (not layers.active_image_layer.visible)):
+                    sub.enabled = False
+                else:
+                    sub.enabled = True
+                sub.prop(layers.active_image_layer, "opacity", text="")
+                sub.prop(layers.active_image_layer, "blend_type", text="")
+
+
 class IMAGE_PT_paint(Panel, ImagePaintPanel):
     bl_space_type = 'IMAGE_EDITOR'
     bl_region_type = 'UI'
@@ -668,7 +806,7 @@
 
         if brush:
             col = layout.column()
-            col.template_color_wheel(brush, "color", value_slider=True)
+            col.template_color(brush, "color", value_slider=True)
             col.prop(brush, "color", text="")
 
             row = col.row(align=True)
Index: release/scripts/startup/bl_ui/space_userpref.py
===================================================================
--- release/scripts/startup/bl_ui/space_userpref.py	(revisione 45704)
+++ release/scripts/startup/bl_ui/space_userpref.py	(copia locale)
@@ -752,6 +752,88 @@
                 colsub = padding.column()
                 colsub = padding.column()
                 colsub.row().prop(ui, "show_colored_constraints")
+        elif theme.theme_area == 'IMAGE_EDITOR':
+            def theme_generic_recurse(data):
+                col.label(data.rna_type.name)
+                row = col.row()
+                subsplit = row.split(percentage=0.95)
+
+                padding1 = subsplit.split(percentage=0.15)
+                padding1.column()
+
+                subsplit = row.split(percentage=0.85)
+
+                padding2 = subsplit.split(percentage=0.15)
+                padding2.column()
+
+                colsub_pair = padding1.column(), padding2.column()
+
+                props_type = {}
+
+                for i, prop in enumerate(data.rna_type.properties):
+                    if prop.identifier == "rna_type":
+                        continue
+
+                    props_type.setdefault((prop.type, prop.subtype), []).append(prop)
+
+                for props_type, props_ls in sorted(props_type.items()):
+                    if props_type[0] == 'POINTER':
+                        for i, prop in enumerate(props_ls):
+                            theme_generic_recurse(getattr(data, prop.identifier))
+                    else:
+                        for i, prop in enumerate(props_ls):
+                            colsub_pair[i % 2].row().prop(data, prop.identifier)
+
+            data = getattr(theme, theme.theme_area.lower())
+            col = split.column()
+
+            ui = theme.image_editor
+            col.label(text="Theme Image Editor")
+
+            row = col.row()
+
+            subsplit = row.split(percentage=0.95)
+            padding = subsplit.split(percentage=0.15)
+            colsub = padding.column()
+            colsub = padding.column()
+            colsub.row().prop(ui, "editmesh_active")
+            colsub.row().prop(ui, "face_dot")
+            colsub.row().prop(ui, "scope_back")
+            colsub.row().prop(ui, "preview_stitch_edge")
+            colsub.row().prop(ui, "preview_stitch_stitchable")
+            colsub.row().prop(ui, "preview_stitch_vert")
+            colsub.row().prop(ui, "vertex_select")
+            colsub.row().prop(ui, "facedot_size")
+            colsub.row().prop(ui, "col1_boundary_layer")
+            colsub.row().prop(ui, "show_boundary_layer")
+
+            subsplit = row.split(percentage=0.85)
+            padding = subsplit.split(percentage=0.15)
+            colsub = padding.column()
+            colsub = padding.column()
+            colsub.row().prop(ui, "face")
+            colsub.row().prop(ui, "face_select")
+            colsub.row().prop(ui, "scope_back")
+            colsub.row().prop(ui, "preview_stitch_active")
+            colsub.row().prop(ui, "preview_stitch_face")
+            colsub.row().prop(ui, "preview_stitch_unstitchable")
+            colsub.row().prop(ui, "vertex")
+            colsub.row().prop(ui, "vertex_size")
+            colsub.row().prop(ui, "col2_boundary_layer")
+
+            props_type = {}
+
+            for i, prop in enumerate(data.rna_type.properties):
+                if prop.identifier == "rna_type":
+                    continue
+
+                props_type.setdefault((prop.type, prop.subtype), []).append(prop)
+
+            for props_type, props_ls in sorted(props_type.items()):
+                if props_type[0] == 'POINTER':
+                    for i, prop in enumerate(props_ls):
+                        theme_generic_recurse(getattr(data, prop.identifier))
+
         else:
             self._theme_generic(split, getattr(theme, theme.theme_area.lower()))
 
Index: release/scripts/startup/bl_ui/space_view3d_toolbar.py
===================================================================
--- release/scripts/startup/bl_ui/space_view3d_toolbar.py	(revisione 45704)
+++ release/scripts/startup/bl_ui/space_view3d_toolbar.py	(copia locale)
@@ -621,7 +621,7 @@
 
         elif context.image_paint_object and brush:
             col = layout.column()
-            col.template_color_wheel(brush, "color", value_slider=True)
+            col.template_color(brush, "color", value_slider=True)
             col.prop(brush, "color", text="")
 
             row = col.row(align=True)
@@ -665,7 +665,7 @@
         # Vertex Paint Mode #
         elif context.vertex_paint_object and brush:
             col = layout.column()
-            col.template_color_wheel(brush, "color", value_slider=True)
+            col.template_color(brush, "color", value_slider=True)
             col.prop(brush, "color", text="")
 
             row = col.row(align=True)
Index: source/blender/blenkernel/BKE_image.h
===================================================================
--- source/blender/blenkernel/BKE_image.h	(revisione 45704)
+++ source/blender/blenkernel/BKE_image.h	(copia locale)
@@ -130,6 +130,8 @@
 
 /* returns existing Image when filename/type is same (frame optional) */
 struct Image *BKE_add_image_file(const char *name);
+struct ImageLayer *BKE_add_image_file_as_layer(struct Image *ima, const char *name);
+struct ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4]);
 
 /* adds image, adds ibuf, generates color or pattern */
 struct Image *BKE_add_image_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4]);
Index: source/blender/blenkernel/BKE_layer.h
===================================================================
--- source/blender/blenkernel/BKE_layer.h	(revisione 0)
+++ source/blender/blenkernel/BKE_layer.h	(copia locale)
@@ -0,0 +1,98 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): ruesp83.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+ #ifndef __BKE_LAYER_H__
+#define __BKE_LAYER_H__
+
+/** \file BKE_layer.h
+ *  \ingroup bke
+ *  \since March 2012
+ *  \author ruesp83
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct Image;
+struct ImageLayer;
+struct ImBuf;
+
+/* call from library */
+
+struct ImageLayer *layer_alloc(struct Image *ima, const char *name);
+
+/* Removes all image layers from the image "ima" */
+void image_free_image_layers(struct Image *ima);
+ 
+/* Frees an image layer and associated memory */
+void free_image_layer(struct ImageLayer *layer);
+ 
+/* Removes the currently selected image layer */
+int image_remove_layer(struct Image *ima, const int action);
+
+/* Removes the currently selected image layer */
+struct ImageLayer *image_duplicate_current_image_layer(struct Image *ima);
+
+/* Adds another image layer and selects it */
+struct ImageLayer *image_add_image_layer(struct Image *ima, const char *name, int depth, float color[4], int order);
+
+/* Adds the base layer of images that points Image->ibufs.first */
+void image_add_image_layer_base(struct Image *ima);
+ 
+/* Returns the index of the currently selected image layer */
+short imalayer_get_current_act(struct Image *ima);
+short imalayer_get_index_layer(struct Image *ima, struct ImageLayer *iml);
+
+short imalayer_get_count(struct Image *ima);
+ 
+/* Selects the image layer with the number specified in "value" */
+void imalayer_set_current_act(struct Image *ima, short value);
+ 
+/* Returns the image layer that is currently selected */
+struct ImageLayer *imalayer_get_current(struct Image *ima);
+
+int imalayer_is_locked(struct Image *ima);
+ 
+/* Fills the current selected image layer with the color given */
+void imalayer_fill_color(struct Image *ima, float color[4]);
+
+void imalayer_unique_name(struct ImageLayer *iml, struct Image *ima);
+//void imalayer_unique_name(const struct ListBase *imlayers, struct ImageLayer *newlayer);
+
+struct ImBuf *imalayer_blend(struct ImBuf *base, struct ImBuf *layer, float opacity, short mode);
+
+struct ImageLayer *merge_layers(struct Image *ima, struct ImageLayer *iml, struct ImageLayer *iml_next);
+
+unsigned int IML_blend_color(unsigned int src1, unsigned int src2, int opacity, short mode);
+void IML_blend_color_float(float *dst, float *src1, float *src2, float opacity, short mode);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
Index: source/blender/blenkernel/CMakeLists.txt
===================================================================
--- source/blender/blenkernel/CMakeLists.txt	(revisione 45704)
+++ source/blender/blenkernel/CMakeLists.txt	(copia locale)
@@ -99,6 +99,7 @@
 	intern/key.c
 	intern/lamp.c
 	intern/lattice.c
+	intern/layer.c
 	intern/library.c
 	intern/material.c
 	intern/mball.c
@@ -185,6 +186,7 @@
 	BKE_key.h
 	BKE_lamp.h
 	BKE_lattice.h
+	BKE_layer.h
 	BKE_library.h
 	BKE_main.h
 	BKE_material.h
Index: source/blender/blenkernel/intern/icons.c
===================================================================
--- source/blender/blenkernel/intern/icons.c	(revisione 45704)
+++ source/blender/blenkernel/intern/icons.c	(copia locale)
@@ -193,9 +193,11 @@
 	else if (GS(id->name) == ID_IM) {
 		Image *img  = (Image*)id;
 		BKE_previewimg_free(&img->preview);
+	/*} else if (GS(id->name) == ID_IL) {
+		ImageLayer *iml  = (ImageLayer*)id;
+		BKE_previewimg_free(&iml->preview);*/
 	}
-	else if (GS(id->name) == ID_BR) {
-		Brush *br  = (Brush*)id;
+	else if (GS(id->name) == ID_BR) {		Brush *br  = (Brush*)id;
 		BKE_previewimg_free(&br->preview);
 	}
 }
@@ -228,6 +230,10 @@
 		Image *img  = (Image*)id;
 		if (!img->preview) img->preview = BKE_previewimg_create();
 		prv_img = img->preview;
+	/*} else if (GS(id->name) == ID_IL) {
+		ImageLayer *iml  = (ImageLayer*)id;
+		if (!iml->preview) iml->preview = BKE_previewimg_create();
+		prv_img = iml->preview;*/
 	}
 	else if (GS(id->name) == ID_BR) {
 		Brush *br  = (Brush*)id;
Index: source/blender/blenkernel/intern/image.c
===================================================================
--- source/blender/blenkernel/intern/image.c	(revisione 45704)
+++ source/blender/blenkernel/intern/image.c	(copia locale)
@@ -73,6 +73,7 @@
 #include "BKE_global.h"
 #include "BKE_icons.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
 #include "BKE_packedFile.h"
@@ -202,6 +203,7 @@
 {
 	int a;
 
+	image_free_image_layers(ima);
 	image_free_buffers(ima);
 	if (ima->packedfile) {
 		freePackedFile(ima->packedfile);
@@ -218,6 +220,7 @@
 			ima->renders[a]= NULL;
 		}
 	}
+	
 }
 
 /* only image block itself */
@@ -243,11 +246,21 @@
 /* get the ibuf from an image cache, local use here only */
 static ImBuf *image_get_ibuf(Image *ima, int index, int frame)
 {
+	/* unsigned int totsize= 0; */
+
 	/* this function is intended to be thread safe. with IMA_NO_INDEX this
 	 * should be OK, but when iterating over the list this is more tricky
 	 * */
-	if (index==IMA_NO_INDEX)
+	if (index==IMA_NO_INDEX) {
+		/* TODO: (kwk) This is an ugly hack to return always the active layer's ibuf */
+		ImageLayer *layer= imalayer_get_current(ima);
+		
+		if (layer && layer->ibufs.last)
+			return layer->ibufs.last;
+		
+		/* Only return "normal" image ibuf if no layer ibuf was found. */
 		return ima->ibufs.first;
+	}
 	else {
 		ImBuf *ibuf;
 
@@ -296,6 +309,12 @@
 		/* now we don't want copies? */
 		if (link && ibuf->index==link->index)
 			image_remove_ibuf(ima, link);
+
+		image_add_image_layer_base(ima);
+		if (strlen(ima->name) != 0) {
+			((ImageLayer *)ima->imlayers.last)->background = IMA_LAYER_BG_IMAGE;
+			strcpy(((ImageLayer *)ima->imlayers.last)->file_path, ima->name);
+		}
 	}
 }
 
@@ -560,8 +579,47 @@
 	return ima;
 }
 
-static ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4])
+ImageLayer *BKE_add_image_file_as_layer(Image *ima, const char *name)
 {
+	ImageLayer *iml, *layer_act;
+	int file, len;
+	const char *newname;
+	char str[FILE_MAX], strtest[FILE_MAX];
+	
+	BLI_strncpy(str, name, sizeof(str));
+	
+	/* exists? */
+	file= BLI_open(str, O_BINARY|O_RDONLY, 0);
+	if (file== -1) return NULL;
+	close(file);
+	
+	/* create a short library name */
+	len= strlen(name);
+	
+	while (len > 0 && name[len - 1] != '/' && name[len - 1] != '\\') len--;
+	newname= name+len;
+	
+	//iml = image_add_image_layer(ima, newname, alpha ? 32 : 24, color, 2);
+	
+	layer_act = imalayer_get_current(ima);
+	layer_act->select = !IMA_LAYER_SEL_CURRENT;
+	
+	iml = layer_alloc(ima, newname);
+	if (iml) {
+
+		BLI_addhead(&ima->imlayers, iml);
+		ima->Act_Layers = 0;
+		ima->Count_Layers += 1;
+
+		//if (color[3] == 1.0f)
+		//	im_l->background = IMA_LAYER_BG_RGB;
+		//copy_v4_v4(im_l->default_color, color)
+	}
+	return iml;
+}
+
+ImBuf *add_ibuf_size(unsigned int width, unsigned int height, const char *name, int depth, int floatbuf, short uvtestgrid, float color[4])
+{
 	ImBuf *ibuf;
 	unsigned char *rect= NULL;
 	float *rect_float= NULL;
@@ -609,7 +667,7 @@
 		
 		ibuf= add_ibuf_size(width, height, ima->name, depth, floatbuf, uvtestgrid, color);
 		image_assign_ibuf(ima, ibuf, IMA_NO_INDEX, 0);
-		
+
 		ima->ok= IMA_OK_LOADED;
 	}
 
Index: source/blender/blenkernel/intern/layer.c
===================================================================
--- source/blender/blenkernel/intern/layer.c	(revisione 0)
+++ source/blender/blenkernel/intern/layer.c	(copia locale)
@@ -0,0 +1,877 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2001-2002 by NaN Holding BV.
+ * All rights reserved.
+ *
+ * Contributor(s): Blender Foundation, 2006, full recode
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/blenkernel/intern/layer.c
+ *  \ingroup bke
+ */
+ 
+#include <stdio.h>
+#include <string.h>
+
+#include "MEM_guardedalloc.h"
+#include "IMB_imbuf_types.h"
+#include "IMB_imbuf.h"
+
+#include "DNA_userdef_types.h"
+
+#include "BLI_blenlib.h"
+#include "BLI_utildefines.h"
+#include "BLI_math_base.h"
+
+//#include "BKE_icons.h"
+//#include "BKE_global.h"
+#include "BKE_image.h"
+#include "BKE_layer.h"
+//#include "BKE_library.h"
+
+ 
+ImageLayer *layer_alloc(Image *ima, const char *name)
+{
+	ImageLayer *im_l;
+	
+	im_l = (ImageLayer*) MEM_callocN(sizeof(ImageLayer), "image_layer");
+	if(im_l) {
+		strcpy(im_l->name, name);
+		imalayer_unique_name(im_l, ima);
+		im_l->next = im_l->prev = NULL;
+
+		im_l->background = IMA_LAYER_BG_ALPHA;
+		im_l->color_space = IMA_LAYER_COL_RGB;
+		im_l->opacity = 1.0f;
+		im_l->mode = IMA_LAYER_NORMAL;
+		im_l->type = IMA_LAYER_LAYER;
+		im_l->visible = IMA_LAYER_VISIBLE;
+		im_l->select = IMA_LAYER_SEL_CURRENT;
+	}
+	return im_l;
+}
+
+void image_free_image_layers(struct Image *ima)
+{
+	ImageLayer *img_lay, *next;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima->imlayers.first == NULL)
+		return;
+
+	ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+	while((img_lay=ima->imlayers.first)) {
+		BLI_remlink(&ima->imlayers, img_lay);
+		free_image_layer(img_lay);
+	}
+
+	ima->Count_Layers = 0;
+	BKE_image_release_ibuf(ima, lock);
+}
+ 
+void free_image_layer(ImageLayer *layer)
+{
+	ImBuf *ibuf, *next;
+ 
+	if (!layer)
+		return;
+
+	while((ibuf = layer->ibufs.first)) {
+		BLI_remlink(&layer->ibufs, ibuf);
+ 
+		if (ibuf->userdata) {
+			MEM_freeN(ibuf->userdata);
+			ibuf->userdata = NULL;
+		}
+ 
+		IMB_freeImBuf(ibuf);
+	}
+
+	MEM_freeN(layer);
+}
+ 
+ImageLayer *imalayer_get_current(Image *ima)
+{
+	ImageLayer *layer;
+	if(ima == NULL)
+		return 0;
+ 
+	for(layer=ima->imlayers.last; layer; layer=layer->prev){
+		if(layer->select & IMA_LAYER_SEL_CURRENT)
+			return layer;
+	}
+ 
+	return NULL;
+}
+
+short imalayer_get_count(Image *ima)
+{
+	if(ima == NULL)
+		return 0;
+ 
+	return ima->Count_Layers;
+}
+
+short imalayer_get_current_act(Image *ima)
+{
+	if(ima == NULL)
+		return 0;
+ 
+	return ima->Act_Layers;
+}
+
+short imalayer_get_index_layer(struct Image *ima, struct ImageLayer *iml)
+{
+	ImageLayer *layer;
+	short i;
+ 
+	if(ima == NULL)
+		return -1;
+
+	for(layer=ima->imlayers.last, i = BLI_countlist(&ima->imlayers)-1; layer; layer=layer->prev, i--)
+		if(layer == iml)
+			return i;
+
+	return -1;
+}
+ 
+void imalayer_set_current_act(Image *ima, short index)
+{
+	ImageLayer *layer;
+	short i;
+ 
+	if(ima == NULL)
+		return;
+
+	for(layer=ima->imlayers.last, i = BLI_countlist(&ima->imlayers)-1; layer; layer=layer->prev, i--) {
+		if(i == index) {
+			layer->select = IMA_LAYER_SEL_CURRENT;
+			ima->Act_Layers = i;
+		}
+		else
+			layer->select = !IMA_LAYER_SEL_CURRENT;
+	}
+}
+
+int imalayer_is_locked(struct Image *ima)
+{
+	ImageLayer *layer= NULL;
+
+	layer = imalayer_get_current(ima);
+
+	return layer->lock;
+}
+
+void imalayer_fill_color(struct Image *ima, float color[4])
+{
+	ImageLayer *layer= NULL;
+	ImBuf *ibuf= NULL;
+	unsigned char *rect= NULL;
+	float *rect_float= NULL;
+	void *lock;
+ 
+	if (ima==NULL)
+		return;
+ 
+	layer = imalayer_get_current(ima);
+	
+	//ibuf = BKE_image_acquire_ibuf(ima, NULL, &lock);
+
+	ibuf = (ImBuf*)((ImageLayer*)layer->ibufs.first);
+	if (ibuf) {
+		if (ibuf->flags & IB_rectfloat) {
+			rect_float= (float*)ibuf->rect_float;
+		}
+		else {
+			rect= (unsigned char*)ibuf->rect;
+		}
+ 
+		BKE_image_buf_fill_color(rect, rect_float, ibuf->x, ibuf->y, color);
+	}
+ 
+	//BKE_image_release_ibuf(ima, lock);
+}
+
+ImageLayer *image_duplicate_current_image_layer(Image *ima)
+{
+	ImageLayer *layer = NULL, *im_l = NULL;
+	char dup_name[sizeof(layer->name)];
+	ImBuf *ibuf, *new_ibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return NULL;
+ 
+	layer = imalayer_get_current(ima);
+
+	if(!strstr(layer->name, "_copy")) {
+		BLI_snprintf(dup_name, sizeof(dup_name), "%s_copy", layer->name);
+	}
+	else {
+		BLI_snprintf(dup_name, sizeof(dup_name), "%s", layer->name);
+	}
+
+	im_l = layer_alloc(ima, dup_name);
+	if (im_l) {
+		ibuf= (ImBuf*)((ImageLayer*)layer->ibufs.first);
+		if (ibuf) {
+			new_ibuf = IMB_dupImBuf(ibuf);
+			BLI_addtail(&im_l->ibufs, new_ibuf);
+
+			im_l->next = im_l->prev = NULL;
+			if (layer) {
+				BLI_insertlinkbefore(&ima->imlayers, layer, im_l);
+			}
+			else {
+				BLI_addhead(&ima->imlayers, layer);
+			}
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+
+			im_l->background = layer->background;
+			im_l->color_space = layer->color_space;
+			copy_v4_v4(im_l->default_color, layer->default_color);
+			strcpy(im_l->file_path, layer->file_path);
+			im_l->lock = layer->lock;
+			im_l->mode = layer->mode;
+			im_l->opacity = layer->opacity;
+			im_l->type = IMA_LAYER_LAYER;
+			im_l->visible = layer->visible;
+		}
+		ima->Count_Layers += 1;
+	}
+	return im_l;
+}
+ 
+int image_remove_layer(Image *ima, const int action)
+{
+	ImageLayer *layer= NULL;
+	 
+	if (ima==NULL)
+		return FALSE;
+ 
+	if (action & IMA_LAYER_DEL_SELECTED) {
+		layer = imalayer_get_current(ima);
+
+		if (layer) {
+			BLI_remlink(&ima->imlayers, layer);
+			free_image_layer(layer);
+		}
+		/* Ensure the first element in list gets selected (if any) */
+		if (ima->imlayers.first) {
+			if (imalayer_get_current_act(ima) != 1)
+				imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+			else
+				imalayer_set_current_act(ima, imalayer_get_current_act(ima)-1);
+		}
+		ima->Count_Layers -= 1;
+	}
+	else {
+		for (layer=ima->imlayers.last; layer; layer=layer->prev){
+			if (!(layer->visible & IMA_LAYER_VISIBLE)) {
+				BLI_remlink(&ima->imlayers, layer);
+				free_image_layer(layer);
+				if (ima->imlayers.first) {
+					if (imalayer_get_current_act(ima) != 1)
+						imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+					else
+						imalayer_set_current_act(ima, imalayer_get_current_act(ima)-1);
+				}
+				ima->Count_Layers -= 1;
+			}
+		}
+	}
+	return TRUE;
+}
+
+static char blend_normal(const char B, const char L, float O)
+{	
+	return (char)(O * (L) + (1.0f - O) * B);
+}
+
+static char blend_lighten(const char B, const char L, float O)
+{	
+	return (char)(O * ((L > B) ? L : B) + (1.0f - O) * B);
+}
+
+static char blend_darken(const char B, const char L, float O)
+{	
+	return (char)(O * ((L > B) ? B : L) + (1.0f - O) * B);
+}
+
+static char blend_multiply(const char B, const char L, float O)
+{	
+	return (char)(O * ((B * L) / 255) + (1.0f - O) * B);
+}
+
+static char blend_average(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L) / 2) + (1.0f - O) * B);
+}
+
+static char blend_add(const char B, const char L, float O)
+{	
+	return (char)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static char blend_subtract(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static char blend_difference(const char B, const char L, float O)
+{	
+	return (char)(O * (abs(B - L)) + (1.0f - O) * B);
+}
+
+static char blend_negation(const char B, const char L, float O)
+{	
+	return (char)(O * (255 - abs(255 - B - L)) + (1.0f - O) * B);
+}
+
+static char blend_screen(const char B, const char L, float O)
+{	
+	return (char)(O * (255 - (((255 - B) * (255 - L)) >> 8)) + (1.0f - O) * B);
+}
+
+static char blend_exclusion(const char B, const char L, float O)
+{	
+	return (char)(O * (B + L - 2 * B * L / 255) + (1.0f - O) * B);
+}
+
+static char blend_overlay(const char B, const char L, float O)
+{	
+	return (char)(O * ((L < 128) ? (2 * B * L / 255) : (255 - 2 * (255 - B) * (255 - L) / 255)) + (1.0f - O) * B);
+}
+
+static char blend_soft_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((L < 128) ? (2 * ((B >> 1) + 64)) * ((float)L / 255) : (255 - (2 * (255 - ((B >> 1) + 64)) * (float)(255 - L) / 255))) + (1.0f - O) * B);
+}
+
+static char blend_hard_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((B < 128) ? (2 * L * B / 255) : (255 - 2 * (255 - L) * (255 - B) / 255)) + (1.0f - O) * B);
+}
+
+static char blend_color_dodge(const char B, const char L, float O)
+{	
+	return (char)(O * ((L == 255) ? L : MIN2(255, ((B << 8 ) / (255 - L)))) + (1.0f - O) * B);
+}
+
+static char blend_color_burn(const char B, const char L, float O)
+{	
+	return (char)(O * ((L == 0) ? L : MAX2(0, (255 - ((255 - B) << 8 ) / L))) + (1.0f - O) * B);
+}
+
+static char blend_linear_dodge(const char B, const char L, float O)
+{	
+	return (char)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static char blend_linear_burn(const char B, const char L, float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static char blend_linear_light(const char B, const char L, float O)
+{	
+	return (char)(O * ((2 * L) < 128) ? ((B + (2 * L) < 255) ? 0 : (B + (2 * L) - 255)) : (MIN2(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static char blend_vivid_light(const char B, const char L, float O)
+{	
+	return (char)(O * (L < 128) ? (((2 * L) == 0) ? (2 * L) : MAX2(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (MIN2(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static char blend_pin_light(const char B, const char L, float O)
+{	
+	return (char)(O * (L < 128) ? (((2 * L) > B) ? B : (2 * L)) : (((2 * (L - 128)) > B) ? (2 * (L - 128)) : B) + (1.0f - O) * B);
+}
+
+static char blend_hard_mix(const char B, const char L, float O)
+{	
+	return (char)(O * (((L < 128) ? (((2 * L) == 0) ? (2 * L) : MAX2(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (MIN2(255, (B + (2 * (L - 128))))) < 128) ? 0 : 255) + (1.0f - O) * B);
+}
+
+/*static float blend_normal_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L) + (1.0f - O) * B);
+}
+
+static float blend_lighten_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L > B) ? L : B) + (1.0f - O) * B);
+}
+
+static float blend_darken_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L > B) ? B : L) + (1.0f - O) * B);
+}
+
+static float blend_multiply_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B * L) / 255) + (1.0f - O) * B);
+}
+
+static float blend_average_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L) / 2) + (1.0f - O) * B);
+}
+
+static float blend_add_f(const float B, const float L, float O)
+{	
+	return (float)(O * (MIN2(255, (B + L))) + (1.0f - O) * B);
+}
+
+static float blend_subtract_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_difference_f(const float B, const float L, float O)
+{	
+	return (float)(O * (abs(B - L)) + (1.0f - O) * B);
+}
+
+static float blend_negation_f(const float B, const float L, float O)
+{	
+	return (float)(O * (255 - abs(255 - B - L)) + (1.0f - O) * B);
+}
+
+static float blend_screen_f(const float B, const float L, float O)
+{	
+	return (float)(O * (255 - (FTOCHAR((255 - B) * (255 - L)) >> 8)) + (1.0f - O) * B);
+}
+
+static float blend_exclusion_f(const float B, const float L, float O)
+{	
+	return (float)(O * (B + L - 2 * B * L / 255) + (1.0f - O) * B);
+}
+
+static float blend_overlay_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L < 128) ? (2 * B * L / 255) : (255 - 2 * (255 - B) * (255 - L) / 255)) + (1.0f - O) * B);
+}
+
+static float blend_soft_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L < 128) ? (2 * ((B >> 1) + 64)) * ((float)L / 255) : (255 - (2 * (255 - ((B >> 1) + 64)) * (float)(255 - L) / 255))) + (1.0f - O) * B);
+}
+
+static float blend_hard_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B < 128) ? (2 * L * B / 255) : (255 - 2 * (255 - L) * (255 - B) / 255)) + (1.0f - O) * B);
+}
+
+static float blend_color_dodge_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L == 255) ? L : minf(255, ((B << 8 ) / (255 - L)))) + (1.0f - O) * B);
+}
+
+static float blend_color_burn_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((L == 0) ? L : maxf(0, (255 - ((255 - B) << 8 ) / L))) + (1.0f - O) * B);
+}
+
+static float blend_linear_dodge_f(const float B, const float L, float O)
+{	
+	return (float)(O * (minf(255, (B + L))) + (1.0f - O) * B);
+}
+
+static float blend_linear_burn_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_linear_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * ((2 * L) < 128) ? ((B + (2 * L) < 255) ? 0 : (B + (2 * L) - 255)) : (minf(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static float blend_vivid_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L < 128) ? (((2 * L) == 0) ? (2 * L) : maxf(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (minf(255, (B + (2 * (L - 128))))) + (1.0f - O) * B);
+}
+
+static float blend_pin_light_f(const float B, const float L, float O)
+{	
+	return (float)(O * (L < 128) ? (((2 * L) > B) ? B : (2 * L)) : (((2 * (L - 128)) > B) ? (2 * (L - 128)) : B) + (1.0f - O) * B);
+}
+
+static float blend_hard_mix_f(const float B, const float L, float O)
+{	
+	return (float)(O * (((L < 128) ? (((2 * L) == 0) ? (2 * L) : maxf(0, (255 - ((255 - B) << 8 ) / (2 * L)))) : (minf(255, (B + (2 * (L - 128))))) < 128) ? 0 : 255) + (1.0f - O) * B);
+}*/
+
+/*static float blend_normal_f(const float B, const float L, const float O)
+{	
+	return (char)(O * (L) + (1.0f - O) * B);
+}
+
+static float blend_multiply_f(const float B, const float L, const float O)
+{	
+	return (float)(O * ((B * L) / 1.0f) + (1.0f - O) * B);
+}
+
+static float blend_subtract_f(const float B, const float L, const float O)
+{	
+	return (char)(O * ((B + L < 255) ? 0 : (B + L - 255)) + (1.0f - O) * B);
+}
+
+static float blend_difference_f(const float B, const float L, const float O)
+{	
+	return (float)(O * (fabs(B - L)) + (1.0f - O) * B);
+}
+
+static float blend_overlay_f(float B, float L, float O)
+{	
+	return (float)(O * ((L < 0.5f) ? (2 * B * L / 1.0f) : (1.0f - 2 * (1.0f - B) * (1.0f - L) / 1.0f)) + (1.0f - O) * B);
+}*/
+
+static char pixel_is_transparent(const char pix[4])
+{	
+	if ((pix[0] == 0) && (pix[1] == 0) && (pix[2] == 0) && (pix[3] == 0))
+		return 1;
+	return 0;
+}
+
+ImBuf *imalayer_blend(ImBuf *base, ImBuf *layer, float opacity, short mode)
+{
+	ImBuf *dest;
+	int i, y;
+	int bg_x, bg_y, diff_x;
+	//float (*blend_callback_f)(const float B, const float L, const float O) = NULL;	//Mode callback
+	char (*blend_callback)(const char B, const char L, const float O) = NULL;		//Mode callback
+	
+	if (!base)
+		return IMB_dupImBuf(layer);
+
+	dest = IMB_dupImBuf(base);
+
+	if (opacity == 0.0f)
+		return dest;
+
+	bg_x = base->x;
+	bg_y = base->y;
+	if (base->x > layer->x)
+		bg_x = layer->x;
+	if (base->y > layer->y)
+		bg_y = layer->y;
+	
+	diff_x = abs(base->x - layer->x);
+
+	switch(mode) {
+	case IMA_LAYER_NORMAL:
+		blend_callback = blend_normal;
+		break;
+
+	case IMA_LAYER_MULTIPLY:
+		blend_callback = blend_multiply;
+		break;
+
+	case IMA_LAYER_SCREEN:
+		blend_callback = blend_screen;
+		break;
+
+	case IMA_LAYER_OVERLAY:
+		blend_callback = blend_overlay;
+		break;
+
+	case IMA_LAYER_SOFT_LIGHT:
+		blend_callback = blend_soft_light;
+		break;
+
+	case IMA_LAYER_HARD_LIGHT:
+		blend_callback = blend_hard_light;
+		break;
+
+	case IMA_LAYER_COLOR_DODGE:
+		blend_callback = blend_color_dodge;
+		break;
+
+	case IMA_LAYER_LINEAR_DODGE:
+		blend_callback = blend_linear_dodge;
+		break;
+		
+	case IMA_LAYER_COLOR_BURN:
+		blend_callback = blend_color_burn;
+		break;
+
+	case IMA_LAYER_LINEAR_BURN:
+		blend_callback = blend_linear_burn;
+		break;
+
+	case IMA_LAYER_AVERAGE: 
+		blend_callback = blend_average;
+		break;       
+
+	case IMA_LAYER_ADD: 
+		blend_callback = blend_add;
+		break;
+
+	case IMA_LAYER_SUBTRACT: 
+		blend_callback = blend_subtract;
+		break;       
+
+	case IMA_LAYER_DIFFERENCE: 
+		blend_callback = blend_difference;
+		break;
+	
+	case IMA_LAYER_LIGHTEN: 
+		blend_callback = blend_lighten;
+		break;       
+
+	case IMA_LAYER_DARKEN: 
+		blend_callback = blend_darken;
+		break;
+	
+	case IMA_LAYER_NEGATION: 
+		blend_callback = blend_negation;
+		break;       
+
+	case IMA_LAYER_EXCLUSION: 
+		blend_callback = blend_exclusion;
+		break;
+	
+	case IMA_LAYER_LINEAR_LIGHT: 
+		blend_callback = blend_linear_light;
+		break;       
+
+	case IMA_LAYER_VIVID_LIGHT: 
+		blend_callback = blend_vivid_light;
+		break;
+	
+	case IMA_LAYER_PIN_LIGHT: 
+		blend_callback = blend_pin_light;
+		break;       
+
+	case IMA_LAYER_HARD_MIX: 
+		blend_callback = blend_hard_mix;
+		break;
+	}
+
+	if (base->rect_float) {
+		
+		float *fp_b = (float *) base->rect_float;
+		float *fp_l = (float *) layer->rect_float;
+		float *fp_d = (float *) dest->rect_float;
+		for( i = bg_x * bg_y; i > 0; i--, fp_b+=4, fp_l+=4, fp_d+=4 ) {
+			if (fp_l[3] != 0.0f) {
+				fp_d[0] = (float) blend_callback(FTOCHAR(fp_b[0]), FTOCHAR(fp_l[0]), opacity) / 255.0f;
+				fp_d[1] = (float) blend_callback(FTOCHAR(fp_b[1]), FTOCHAR(fp_l[1]), opacity) / 255.0f;
+				fp_d[2] = (float) blend_callback(FTOCHAR(fp_b[2]), FTOCHAR(fp_l[2]), opacity) / 255.0f;
+			}
+		}
+
+		if(base->rect) {
+			IMB_rect_from_float(base);
+		}
+	}
+	else if(base->rect) {
+		
+		char *cp_b = (char *) base->rect;
+		char *cp_l = (char *) layer->rect;
+		char *cp_d = (char *) dest->rect;
+		for( i = bg_x * bg_y; i > 0; i--) {
+			if ((!(pixel_is_transparent(cp_b))) && (!(pixel_is_transparent(cp_l)))) {
+				if ((cp_l[3] == 255) && (cp_b[3] == 255)) {
+					cp_d[0] = blend_callback(cp_b[0], cp_l[0], opacity);
+					cp_d[1] = blend_callback(cp_b[1], cp_l[1], opacity);
+					cp_d[2] = blend_callback(cp_b[2], cp_l[2], opacity);
+				}
+				else if ((cp_l[3] != 255) || (cp_b[3] != 255)) {
+					cp_d[0] = blend_callback(cp_b[0], cp_l[0], opacity);
+					cp_d[1] = blend_callback(cp_b[1], cp_l[1], opacity);
+					cp_d[2] = blend_callback(cp_b[2], cp_l[2], opacity);
+					/*if ((cp_b[3] != 0) && (cp_l[3] != 0))*/
+						cp_d[3] = blend_callback(cp_b[3], cp_l[3], opacity);
+				}
+				else if (cp_l[3] != 0) {
+					cp_d[0] = cp_l[0];
+					cp_d[1] = cp_l[1];
+					cp_d[2] = cp_l[2];
+					cp_d[3] = cp_l[3];
+				}
+				else {
+					cp_d[0] = cp_b[0];
+					cp_d[1] = cp_b[1];
+					cp_d[2] = cp_b[2];
+					cp_d[3] = cp_b[3];
+				}
+			}
+			if (((i % bg_x) == 0) && (i != (bg_x * bg_y))) {
+				if (base->x > layer->x) {
+					cp_b = cp_b + diff_x*4;
+					cp_d = cp_d + diff_x*4;
+				}
+				else
+					cp_l = cp_l + diff_x*4;
+			}
+			cp_b+=4;
+			cp_l+=4; 
+			cp_d+=4;
+		}
+	}
+
+	return dest;
+}
+
+struct ImageLayer *merge_layers(Image *ima, ImageLayer *iml, ImageLayer *iml_next)
+{
+	ImBuf *ibuf, *result_ibuf;
+	 /* merge layers */
+	result_ibuf = imalayer_blend((ImBuf*)((ImageLayer*)iml_next->ibufs.first), (ImBuf*)((ImageLayer*)iml->ibufs.first), iml->opacity, iml->mode);
+	
+	iml_next->background = IMA_LAYER_BG_RGB;
+	iml_next->file_path[0] = '\0';
+	iml_next->default_color[0] = -1;
+	iml_next->default_color[1] = -1;
+	iml_next->default_color[2] = -1;
+	iml_next->default_color[3] = -1;
+
+	/* Delete old ibuf*/
+	ibuf = (ImBuf *)iml_next->ibufs.first;
+	BLI_remlink(&iml_next->ibufs, ibuf);
+ 
+	if (ibuf->userdata) {
+		MEM_freeN(ibuf->userdata);
+		ibuf->userdata = NULL;
+	}
+ 	IMB_freeImBuf(ibuf);
+
+	/* add new ibuf */
+	BLI_addtail(&iml_next->ibufs, result_ibuf);
+
+	/* delete the layer merge */
+	BLI_remlink(&ima->imlayers, iml);
+	free_image_layer(iml);
+	
+	return iml_next;
+}
+
+static int imlayer_find_name_dupe(const char *name, ImageLayer *iml, Image *ima)
+{
+	ImageLayer *layer;
+
+	for (layer = ima->imlayers.last; layer; layer=layer->prev) {
+		if (iml!=layer) {
+			if (!strcmp(layer->name, name)) {
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int imlayer_unique_check(void *arg, const char *name)
+{
+	struct {Image *ima; void *iml;} *data= arg;
+	return imlayer_find_name_dupe(name, data->iml, data->ima);
+}
+
+void imalayer_unique_name(ImageLayer *iml, Image *ima)
+{
+	struct {Image *ima; void *iml;} data;
+	data.ima = ima;
+	data.iml = iml;
+
+	BLI_uniquename_cb(imlayer_unique_check, &data, "Layer", '.', iml->name, sizeof(iml->name));
+}
+
+ImageLayer *image_add_image_layer(Image *ima, const char *name, int depth, float color[4], int order)
+{
+	ImageLayer *layer, *layer_act, *im_l = NULL;
+	ImBuf *ibuf, *imaibuf;
+	void *lock;
+ 
+	if(ima==NULL)
+		return NULL;
+
+ 	layer_act = imalayer_get_current(ima);
+
+	/* Deselect other layers */
+	/*for(layer = ima->imlayers.first; layer; layer=layer->next)
+		layer->select = !IMA_LAYER_SEL_CURRENT;*/
+	layer_act->select = !IMA_LAYER_SEL_CURRENT;
+	
+	im_l = layer_alloc(ima, name);
+	if (im_l) {
+		ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 
+		imaibuf = (ImBuf*)ima->ibufs.first;
+		ibuf = add_ibuf_size(imaibuf->x, imaibuf->y, im_l->name, depth, ima->gen_flag, 0, color);
+		BLI_addtail(&im_l->ibufs, ibuf);
+		if (order == 2) { /*Head*/
+			BLI_addhead(&ima->imlayers, im_l);
+			ima->Act_Layers = 0;
+		}
+		else if (order == -1) { /*Before*/
+			/* Layer Act
+			 * --> Add Layer
+			 */
+			BLI_insertlinkafter(&ima->imlayers, layer_act , im_l);
+			ima->Act_Layers += 1;
+			imalayer_set_current_act(ima, ima->Act_Layers);
+		}
+		else { /*After*/
+			/* --> Add Layer
+			 * Layer Act
+			 */
+			BLI_insertlinkbefore(&ima->imlayers, layer_act , im_l);
+			//ima->Act_Layers -= 1;
+			imalayer_set_current_act(ima, ima->Act_Layers);
+		}
+		ima->Count_Layers += 1;
+
+		if (color[3] == 1.0f)
+			im_l->background = IMA_LAYER_BG_RGB;
+		copy_v4_v4(im_l->default_color, color);
+		BKE_image_release_ibuf(ima, lock);
+	}
+ 
+	return im_l;
+}
+ 
+/* TODO: (kwk) Base image layer needs proper locking... */
+void image_add_image_layer_base(Image *ima)
+{
+	ImageLayer *im_l = NULL;
+	ImBuf *ibuf;
+	void *lock;
+ 
+	if(ima) {
+		im_l = layer_alloc(ima, "Background");
+		if (im_l) {	
+			ibuf= BKE_image_acquire_ibuf(ima, NULL, &lock);
+ 			im_l->type = IMA_LAYER_BASE; /* BASE causes no free on deletion of layer */
+			ima->Act_Layers = 0;
+			ima->Count_Layers = 1;
+			/* Get ImBuf from ima */
+			ibuf = IMB_dupImBuf((ImBuf*)ima->ibufs.first);
+			BLI_addtail(&im_l->ibufs, ibuf);
+			BLI_addhead(&ima->imlayers, im_l);
+ 
+			BKE_image_release_ibuf(ima, lock);
+		}
+	}
+}
+
Index: source/blender/blenkernel/intern/library.c
===================================================================
--- source/blender/blenkernel/intern/library.c	(revisione 45704)
+++ source/blender/blenkernel/intern/library.c	(copia locale)
@@ -617,6 +617,9 @@
 		case ID_IM:
 			id= MEM_callocN(sizeof(Image), "image");
 			break;
+		/*case ID_IL:
+			id= MEM_callocN(sizeof(ImageLayer), "imagelayer");
+			break;*/
 		case ID_LT:
 			id= MEM_callocN(sizeof(Lattice), "latt");
 			break;
Index: source/blender/blenloader/intern/readfile.c
===================================================================
--- source/blender/blenloader/intern/readfile.c	(revisione 45704)
+++ source/blender/blenloader/intern/readfile.c	(copia locale)
@@ -3002,13 +3002,45 @@
 	lb->last= prev;
 }
 
+static void link_imalayers_list(FileData *fd, ListBase *lb)
+{
+	Link *ln, *prev;
+	ImageLayer *layer;
+	
+	if(lb->first==NULL) return;
+	
+	lb->first = newimaadr(fd, lb->first);
+	printf("1\n");
+	ln = lb->first;
+	printf("2\n");
+	layer = (ImageLayer*)ln;
+	printf("3\n");
+	if (layer->name)
+		printf("Name=%s\n", layer->name);
+	else{
+		printf("4\n");
+		printf("Opacity=%d\n", layer->opacity);
+	}
+	prev= NULL;
+	while(ln) {
+		ln->next = newimaadr(fd, ln->next);
+		ln->prev = prev;
+		prev = ln;
+		layer = (ImageLayer*)ln;
+		printf("Name=%s\n", layer->name);
+		link_ibuf_list(fd, &layer->ibufs);
+		ln = ln->next;
+	}
+	lb->last= prev;
+}
+
 static void direct_link_image(FileData *fd, Image *ima)
 {
 	/* for undo system, pointers could be restored */
 	if (fd->imamap)
 		link_ibuf_list(fd, &ima->ibufs);
 	else
-		ima->ibufs.first= ima->ibufs.last= NULL;
+		ima->ibufs.first = ima->ibufs.last = NULL;
 	
 	/* if not restored, we keep the binded opengl index */
 	if (ima->ibufs.first==NULL) {
@@ -3016,6 +3048,7 @@
 		ima->gputexture= NULL;
 	}
 	
+	
 	ima->anim= NULL;
 	ima->rr= NULL;
 	ima->repbind= NULL;
@@ -3035,6 +3068,10 @@
 	ima->packedfile = direct_link_packedfile(fd, ima->packedfile);
 	ima->preview = direct_link_preview_image(fd, ima->preview);
 	ima->ok= 1;
+	if (ima->imlayers.first)
+		link_imalayers_list(fd, &ima->imlayers);
+	else
+		ima->imlayers.first = ima->imlayers.last = NULL;
 }
 
 
Index: source/blender/blenloader/intern/writefile.c
===================================================================
--- source/blender/blenloader/intern/writefile.c	(revisione 45704)
+++ source/blender/blenloader/intern/writefile.c	(copia locale)
@@ -1887,8 +1887,8 @@
 {
 	Image *ima;
 	PackedFile * pf;
+	ImageLayer *iml;
 
-
 	ima= idbase->first;
 	while (ima) {
 		if (ima->id.us>0 || wd->current) {
@@ -1902,6 +1902,13 @@
 				writedata(wd, DATA, pf->size, pf->data);
 			}
 
+			if (ima->imlayers.first) {
+				iml = ima->imlayers.first;
+				while(iml) {
+					writestruct(wd, DATA, "ImageLayer", 1, iml);
+					iml= iml->next;
+				}
+			}
 			write_previews(wd, ima->preview);
 		}
 		ima= ima->id.next;
Index: source/blender/editors/include/BIF_glutil.h
===================================================================
--- source/blender/editors/include/BIF_glutil.h	(revisione 45704)
+++ source/blender/editors/include/BIF_glutil.h	(copia locale)
@@ -39,7 +39,7 @@
 void sdrawline(short x1, short y1, short x2, short y2);
 void sdrawtri(short x1, short y1, short x2, short y2);
 void sdrawtrifill(short x1, short y1, short x2, short y2);
-void sdrawbox(short x1, short y1, short x2, short y2);
+void sdrawbox(int x1, int y1, int x2, int y2);
 
 void sdrawXORline(int x0, int y0, int x1, int y1);
 void sdrawXORline4(int nr, int x0, int y0, int x1, int y1);
Index: source/blender/editors/include/ED_image.h
===================================================================
--- source/blender/editors/include/ED_image.h	(revisione 45704)
+++ source/blender/editors/include/ED_image.h	(copia locale)
@@ -68,7 +68,7 @@
 void ED_image_update_frame(const struct Main *mainp, int cfra);
 
 void ED_image_draw_info(struct ARegion *ar, int color_manage, int channels, int x, int y,
-                        const unsigned char cp[4], const float fp[4], int *zp, float *zpf);
+                        const unsigned char cp[4], const float fp[4], int *zp, float *zpf, const char type);
 
 #endif /* __ED_IMAGE_H__ */
 
Index: source/blender/editors/include/UI_interface.h
===================================================================
--- source/blender/editors/include/UI_interface.h	(revisione 45704)
+++ source/blender/editors/include/UI_interface.h	(copia locale)
@@ -752,6 +752,7 @@
 void uiTemplateVectorscope(uiLayout *layout, struct PointerRNA *ptr, const char *propname);
 void uiTemplateCurveMapping(uiLayout *layout, struct PointerRNA *ptr, const char *propname, int type, int levels, int brush);
 void uiTemplateColorWheel(uiLayout *layout, struct PointerRNA *ptr, const char *propname, int value_slider, int lock, int lock_luminosity, int cubic);
+void uiTemplateColor(uiLayout *layout, struct PointerRNA *ptr, const char *propname, int value_slider, int lock, int lock_luminosity, int cubic);
 void uiTemplateLayers(uiLayout *layout, struct PointerRNA *ptr, const char *propname,
                       PointerRNA *used_ptr, const char *used_propname, int active_layer);
 void uiTemplateImage(uiLayout *layout, struct bContext *C, struct PointerRNA *ptr, const char *propname, struct PointerRNA *userptr, int compact);
Index: source/blender/editors/include/UI_resources.h
===================================================================
--- source/blender/editors/include/UI_resources.h	(revisione 45704)
+++ source/blender/editors/include/UI_resources.h	(copia locale)
@@ -198,6 +198,10 @@
 	TH_STITCH_PREVIEW_UNSTITCHABLE,
 	TH_STITCH_PREVIEW_ACTIVE,
 
+	TH_SHOW_BOUNDARY_LAYER,
+	TH_COL1_BOUNDARY_LAYER,
+	TH_COL2_BOUNDARY_LAYER,
+
 	TH_MATCH,			/* highlight color for search matches */
 	TH_SELECT_HIGHLIGHT	/* highlight color for selected outliner item */
 };
Index: source/blender/editors/interface/interface_icons.c
===================================================================
--- source/blender/editors/interface/interface_icons.c	(revisione 45704)
+++ source/blender/editors/interface/interface_icons.c	(copia locale)
@@ -1130,6 +1130,9 @@
 			/* checks if not exists, or changed */
 			ui_id_icon_render(C, id, big);
 			break;
+		/*case ID_IL: 
+			iconid= BKE_icon_getid(id);
+			break;*/
 		default:
 			break;
 	}
Index: source/blender/editors/interface/interface_templates.c
===================================================================
--- source/blender/editors/interface/interface_templates.c	(revisione 45704)
+++ source/blender/editors/interface/interface_templates.c	(copia locale)
@@ -1919,7 +1919,13 @@
 /********************* ColorWheel Template ************************/
 
 #define WHEEL_SIZE  100
+#define PICKER_H	100 //150
+#define PICKER_W	100 //150
+#define PICKER_SPACE	6
+#define PICKER_BAR		14
 
+#define PICKER_TOTAL_W	(PICKER_W+PICKER_SPACE+PICKER_BAR)
+
 void uiTemplateColorWheel(uiLayout *layout, PointerRNA *ptr, const char *propname, int value_slider, int lock, int lock_luminosity, int cubic)
 {
 	PropertyRNA *prop = RNA_struct_find_property(ptr, propname);
@@ -1937,9 +1943,10 @@
 	
 	col = uiLayoutColumn(layout, 0);
 	row = uiLayoutRow(col, 1);
-	
-	but = uiDefButR_prop(block, HSVCIRCLE, 0, "",   0, 0, WHEEL_SIZE, WHEEL_SIZE, ptr, prop, -1, 0.0, 0.0, 0, 0, "");
+	but = uiDefButR_prop(block, HSVCIRCLE, 0, "", 0, 0, WHEEL_SIZE, WHEEL_SIZE, ptr, prop, -1, 0.0, 0.0, 0, 0, "");
 
+	but = uiDefButR_prop(block, HSVCIRCLE, 0, "", 0, 0, WHEEL_SIZE, WHEEL_SIZE, ptr, prop, -1, 0.0, 0.0, 0, 0, "");
+		
 	if (lock) {
 		but->flag |= UI_BUT_COLOR_LOCK;
 	}
@@ -1956,10 +1963,80 @@
 
 	uiItemS(row);
 	
-	if (value_slider)
+	if (value_slider) 
 		uiDefButR_prop(block, HSVCUBE, 0, "", WHEEL_SIZE + 6, 0, 14, WHEEL_SIZE, ptr, prop, -1, softmin, softmax, UI_GRAD_V_ALT, 0, "");
 }
 
+void uiTemplateColor(uiLayout *layout, PointerRNA *ptr, const char *propname, int value_slider, int lock, int lock_luminosity, int cubic)
+{
+	PropertyRNA *prop= RNA_struct_find_property(ptr, propname);
+	uiBlock *block= uiLayoutGetBlock(layout);
+	uiLayout *col, *row;
+	uiBut *but;
+	float softmin, softmax, step, precision;
+
+	if (!prop) {
+		RNA_warning("property not found: %s.%s", RNA_struct_identifier(ptr->type), propname);
+		return;
+	}
+
+	RNA_property_float_ui_range(ptr, prop, &softmin, &softmax, &step, &precision);
+	
+	col = uiLayoutColumn(layout, 0);
+	row= uiLayoutRow(col, 1);
+
+	switch (U.color_picker_type) {
+		case USER_CP_CIRCLE:
+			but = uiDefButR_prop(block, HSVCIRCLE, 0, "", 0, 0, WHEEL_SIZE, WHEEL_SIZE, ptr, prop, -1, 0.0, 0.0, 0, 0, "");
+			break;
+		case USER_CP_SQUARE_SV:
+			but= uiDefButR_prop(block, HSVCUBE, 0, "",	0, PICKER_BAR+PICKER_SPACE, PICKER_TOTAL_W, PICKER_H, ptr, prop, 0, 0.0, 0.0, UI_GRAD_SV, 0, "");
+			break;
+		case USER_CP_SQUARE_HS:
+			but= uiDefButR_prop(block, HSVCUBE, 0, "",	0, PICKER_BAR+PICKER_SPACE, PICKER_TOTAL_W, PICKER_H, ptr, prop, 0, 0.0, 0.0, UI_GRAD_HS, 0, "");
+			break;
+		case USER_CP_SQUARE_HV:
+			but= uiDefButR_prop(block, HSVCUBE, 0, "",	0, PICKER_BAR+PICKER_SPACE, PICKER_TOTAL_W, PICKER_H, ptr, prop, 0, 0.0, 0.0, UI_GRAD_HV, 0, "");
+			break;
+	}
+
+	
+	if (lock) {
+		but->flag |= UI_BUT_COLOR_LOCK;
+	}
+
+	if (lock_luminosity) {
+		float color[4]; /* in case of alpha */
+		but->flag |= UI_BUT_VEC_SIZE_LOCK;
+		RNA_property_float_get_array(ptr, prop, color);
+		but->a2= len_v3(color);
+	}
+
+	if (cubic)
+		but->flag |= UI_BUT_COLOR_CUBIC;
+		
+	if (value_slider) {
+		switch (U.color_picker_type) {
+			case USER_CP_CIRCLE:
+				uiItemS(row);
+				uiDefButR_prop(block, HSVCUBE, 0, "", WHEEL_SIZE+6, 0, 14, WHEEL_SIZE, ptr, prop, -1, softmin, softmax, UI_GRAD_V_ALT, 0, "");
+				break;
+			case USER_CP_SQUARE_SV:
+				uiItemS(col);
+				uiDefButR_prop(block, HSVCUBE, 0, "", 0, 0, PICKER_TOTAL_W, PICKER_BAR, ptr, prop, -1, 0, 0, UI_GRAD_SV + 3, 0, "");
+				break;
+			case USER_CP_SQUARE_HS:
+				uiItemS(col);
+				uiDefButR_prop(block, HSVCUBE, 0, "", 0, 0, PICKER_TOTAL_W, PICKER_BAR, ptr, prop, -1, 0, 0, UI_GRAD_HS + 3, 0, "");
+				break;
+			case USER_CP_SQUARE_HV:
+				uiItemS(col);
+				uiDefButR_prop(block, HSVCUBE, 0, "", 0, 0, PICKER_TOTAL_W, PICKER_BAR, ptr, prop, -1, 0, 0, UI_GRAD_HV + 3, 0, "");
+				break;
+		}
+	}
+}
+
 /********************* Layer Buttons Template ************************/
 
 static void handle_layer_buttons(bContext *C, void *arg1, void *arg2)
@@ -2076,6 +2153,10 @@
 	else if (RNA_struct_is_a(itemptr->type, &RNA_TextureSlot)) {
 		id = RNA_pointer_get(itemptr, "texture").data;
 	}
+	/*else if (RNA_struct_is_a(itemptr->type, &RNA_ImageLayer)) {
+		//id= RNA_pointer_get(itemptr, "imagelayer").data;
+
+	}*/
 	else if (RNA_struct_is_a(itemptr->type, &RNA_DynamicPaintSurface)) {
 		DynamicPaintSurface *surface = (DynamicPaintSurface *)itemptr->data;
 
@@ -2139,6 +2220,18 @@
 		uiBlockSetEmboss(block, UI_EMBOSS);
 		uiDefButR(block, OPTION, 0, "", 0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "use", 0, 0, 0, 0, 0,  NULL);
 	}
+	else if (RNA_struct_is_a(itemptr->type, &RNA_ImageLayer)) {
+		ImageLayer *layer = (ImageLayer*)itemptr->data;
+		uiItemL(sub, name, icon);
+		uiBlockSetEmboss(block, UI_EMBOSSN);
+		//uiDefButR(block, OPTION, 0, "", 0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "visible", 0, 0, 0, 0, 0,  NULL);
+		uiDefIconButR(block, OPTION, 0, (layer->lock & IMA_LAYER_LOCK) ? ICON_LOCKED : ICON_UNLOCKED,
+				0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "lock", 0, 0, 0, 0, 0, NULL);
+		uiDefIconButR(block, OPTION, 0, (layer->visible & IMA_LAYER_VISIBLE) ? ICON_RESTRICT_VIEW_OFF : ICON_RESTRICT_VIEW_ON,
+				0, 0, UI_UNIT_X, UI_UNIT_Y, itemptr, "visible", 0, 0, 0, 0, 0, NULL);
+		uiBlockSetEmboss(block, UI_EMBOSS);
+
+	}
 	else if (RNA_struct_is_a(itemptr->type, &RNA_MaterialSlot)) {
 		/* provision to draw active node name */
 		Material *ma, *manode;
Index: source/blender/editors/interface/resources.c
===================================================================
--- source/blender/editors/interface/resources.c	(revisione 45704)
+++ source/blender/editors/interface/resources.c	(copia locale)
@@ -441,6 +441,15 @@
 				case TH_STITCH_PREVIEW_ACTIVE:
 					cp = ts->preview_stitch_active;
 					break;
+				case TH_SHOW_BOUNDARY_LAYER:
+					cp = &ts->show_boundary_layer;
+					break;
+				case TH_COL1_BOUNDARY_LAYER:
+					cp = ts->col1_boundary_layer;
+					break;
+				case TH_COL2_BOUNDARY_LAYER:
+					cp = ts->col2_boundary_layer;
+					break;
 				case TH_MARKER_OUTLINE:
 					cp = ts->marker_outline; break;
 				case TH_MARKER:
@@ -790,6 +799,9 @@
 	rgba_char_args_set_fl(btheme->tima.preview_stitch_vert, 0.0, 0.0, 1.0, 0.2);
 	rgba_char_args_set_fl(btheme->tima.preview_stitch_stitchable, 0.0, 1.0, 0.0, 1.0);
 	rgba_char_args_set_fl(btheme->tima.preview_stitch_unstitchable, 1.0, 0.0, 0.0, 1.0);
+	btheme->tima.show_boundary_layer = TH_IMAGE_LAYER_BOUNDARY;
+	rgba_char_args_set(btheme->tima.col1_boundary_layer, 255, 255, 0, 255);
+	rgba_char_args_set(btheme->tima.col2_boundary_layer, 255, 0, 255, 255);
 
 	/* space text */
 	btheme->text = btheme->tv3d;
@@ -1752,6 +1764,7 @@
 		for (btheme = U.themes.first; btheme; btheme = btheme->next) {
 			if (btheme->tui.wcol_menu_item.item[3] == 255)
 				rgba_char_args_set(btheme->tui.wcol_menu_item.item, 172, 172, 172, 128);
+			
 		}
 	}
 
@@ -1773,6 +1786,9 @@
 			if (btheme->tseq.movieclip[0] == 0) {
 				rgba_char_args_set(btheme->tseq.movieclip,  32, 32, 143, 255);
 			}
+			btheme->tima.show_boundary_layer = TH_IMAGE_LAYER_BOUNDARY;
+			rgba_char_args_set_fl(btheme->tima.col1_boundary_layer, 1.0, 1.0, 0.0, 1.0);
+			rgba_char_args_set_fl(btheme->tima.col2_boundary_layer, 0.94, 0.34, 1.0, 1.0);
 		}
 	}
 
Index: source/blender/editors/screen/glutil.c
===================================================================
--- source/blender/editors/screen/glutil.c	(revisione 45704)
+++ source/blender/editors/screen/glutil.c	(copia locale)
@@ -261,22 +261,22 @@
 	glEnd();
 }
 
-void sdrawbox(short x1, short y1, short x2, short y2)
+void sdrawbox(int x1, int y1, int x2, int y2)
 {
-	short v[2];
+	int v[2];
 	
 	glBegin(GL_LINE_STRIP);
 	
 	v[0] = x1; v[1] = y1;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	v[0] = x1; v[1] = y2;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	v[0] = x2; v[1] = y2;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	v[0] = x2; v[1] = y1;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	v[0] = x1; v[1] = y1;
-	glVertex2sv(v);
+	glVertex2iv(v);
 	
 	glEnd();
 }
Index: source/blender/editors/sculpt_paint/paint_image.c
===================================================================
--- source/blender/editors/sculpt_paint/paint_image.c	(revisione 45704)
+++ source/blender/editors/sculpt_paint/paint_image.c	(copia locale)
@@ -33,9 +33,11 @@
  */
 
 
+#include <stddef.h>
 #include <float.h>
 #include <string.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <math.h>
 
 #include "MEM_guardedalloc.h"
@@ -64,15 +66,18 @@
 #include "DNA_node_types.h"
 #include "DNA_object_types.h"
 #include "DNA_scene_types.h"
+#include "DNA_screen_types.h"
 #include "DNA_texture_types.h"
 
 #include "BKE_camera.h"
+#include "BKE_colortools.h"
 #include "BKE_context.h"
 #include "BKE_depsgraph.h"
 #include "BKE_DerivedMesh.h"
 #include "BKE_idprop.h"
 #include "BKE_brush.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
 #include "BKE_mesh.h"
@@ -83,6 +88,7 @@
 #include "BKE_scene.h"
 #include "BKE_global.h"
 #include "BKE_deform.h"
+#include "BKE_screen.h"
 
 #include "BKE_tessmesh.h"
 
@@ -94,6 +100,7 @@
 #include "ED_image.h"
 #include "ED_screen.h"
 #include "ED_sculpt.h"
+#include "ED_space_api.h"
 #include "ED_uvedit.h"
 #include "ED_view3d.h"
 #include "ED_mesh.h"
@@ -4642,6 +4649,7 @@
 static int image_paint_poll(bContext *C)
 {
 	Object *obact = CTX_data_active_object(C);
+	wmWindow *win= CTX_wm_window(C);
 
 	if (!image_paint_brush(C))
 		return 0;
@@ -4655,9 +4663,13 @@
 		if (sima) {
 			ARegion *ar = CTX_wm_region(C);
 
-			if ((sima->flag & SI_DRAWTOOL) && ar->regiontype == RGN_TYPE_WINDOW)
+			if ((sima->flag & SI_DRAWTOOL) && (ar->regiontype==RGN_TYPE_WINDOW) && (!(imalayer_is_locked(sima->image) & IMA_LAYER_LOCK))) {
+				if ((!(win->modalcursor & BC_NSEW_SCROLLCURSOR)) || (!(win->modalcursor & BC_EYEDROPPER_CURSOR)))
+					WM_cursor_modal(win, BC_PAINTBRUSHCURSOR);
 				return 1;
+			}
 		}
+		WM_cursor_restore(CTX_wm_window(C));
 	}
 
 	return 0;
@@ -5407,24 +5419,166 @@
 
 /******************** sample color operator ********************/
 
+typedef struct SampleColorInfo {
+	ARegionType *art;
+	void *draw_handle;
+	int x, y;
+	int channels;
+
+	unsigned char col[4];
+	float colf[4];
+	int z;
+	float zf;
+
+	unsigned char *colp;
+	float *colfp;
+	int *zp;
+	float *zfp;
+
+	int draw;
+} SampleColorInfo;
+
+static void sample_color_draw(const bContext *UNUSED(C), ARegion *ar, void *arg_info)
+{
+	SampleColorInfo *info= arg_info;
+	if(info->draw) {
+		/* no color management needed for images (color_manage=0) */
+		ED_image_draw_info(ar, 0, info->channels, info->x, info->y, info->colp, info->colfp, info->zp, info->zfp, 2);
+	}
+}
+
 static int sample_color_exec(bContext *C, wmOperator *op)
 {
 	Scene *scene = CTX_data_scene(C);
+	SpaceImage *sima = CTX_wm_space_image(C);
 	Brush *brush = image_paint_brush(C);
 	ARegion *ar = CTX_wm_region(C);
+	//wmWindow *win= CTX_wm_window(C);
+	void *lock;
+	ImBuf *ibuf= ED_space_image_acquire_buffer(sima, &lock);
+	SampleColorInfo *info= op->customdata;
 	int location[2];
+	float fx, fy;
 
+	if(ibuf == NULL) {
+		ED_space_image_release_buffer(sima, lock);
+		return OPERATOR_CANCELLED;
+	}
+
+	//WM_cursor_modal(win, BC_EYEDROPPER_CURSOR);
 	RNA_int_get_array(op->ptr, "location", location);
 	paint_sample_color(scene, ar, location[0], location[1]);
 
+
+	UI_view2d_region_to_view(&ar->v2d, location[0], location[1], &fx, &fy);
+
+	if(fx>=0.0f && fy>=0.0f && fx<1.0f && fy<1.0f) {
+		float *fp;
+		unsigned char *cp;
+		int x= (int)(fx*ibuf->x), y= (int)(fy*ibuf->y);
+
+		CLAMP(x, 0, ibuf->x-1);
+		CLAMP(y, 0, ibuf->y-1);
+
+		info->x= x;
+		info->y= y;
+		info->draw= 1;
+		info->channels= ibuf->channels;
+
+		info->colp= NULL;
+		info->colfp= NULL;
+		info->zp= NULL;
+		info->zfp= NULL;
+		
+		if(ibuf->rect) {
+			cp= (unsigned char *)(ibuf->rect + y*ibuf->x + x);
+
+			info->col[0]= cp[0];
+			info->col[1]= cp[1];
+			info->col[2]= cp[2];
+			info->col[3]= cp[3];
+			info->colp= info->col;
+
+			info->colf[0]= (float)cp[0]/255.0f;
+			info->colf[1]= (float)cp[1]/255.0f;
+			info->colf[2]= (float)cp[2]/255.0f;
+			info->colf[3]= (float)cp[3]/255.0f;
+			info->colfp= info->colf;
+		}
+		if(ibuf->rect_float) {
+			fp= (ibuf->rect_float + (ibuf->channels)*(y*ibuf->x + x));
+
+			info->colf[0]= fp[0];
+			info->colf[1]= fp[1];
+			info->colf[2]= fp[2];
+			info->colf[3]= fp[3];
+			info->colfp= info->colf;
+		}
+
+		if(ibuf->zbuf) {
+			info->z= ibuf->zbuf[y*ibuf->x + x];
+			info->zp= &info->z;
+		}
+		if(ibuf->zbuf_float) {
+			info->zf= ibuf->zbuf_float[y*ibuf->x + x];
+			info->zfp= &info->zf;
+		}
+		
+		if(sima->cumap && ibuf->channels==4) {
+			/* we reuse this callback for set curves point operators */
+			if(RNA_struct_find_property(op->ptr, "point")) {
+				int point= RNA_enum_get(op->ptr, "point");
+
+				if(point == 1) {
+					curvemapping_set_black_white(sima->cumap, NULL, info->colfp);
+					if(ibuf->rect_float)
+						curvemapping_do_ibuf(sima->cumap, ibuf);
+				}
+				else if(point == 0) {
+					curvemapping_set_black_white(sima->cumap, info->colfp, NULL);
+					if(ibuf->rect_float)
+						curvemapping_do_ibuf(sima->cumap, ibuf);
+				}
+			}
+		}
+	}
+	else
+		info->draw= 0;
+
+	ED_space_image_release_buffer(sima, lock);
+	ED_area_tag_redraw(CTX_wm_area(C));
+
+
 	WM_event_add_notifier(C, NC_BRUSH | NA_EDITED, brush);
 	
 	return OPERATOR_FINISHED;
 }
 
+static void sample_color_exit(bContext *C, wmOperator *op)
+{
+	SampleColorInfo *info= op->customdata;
+
+	ED_region_draw_cb_exit(info->art, info->draw_handle);
+	ED_area_tag_redraw(CTX_wm_area(C));
+	MEM_freeN(info);
+}
+
 static int sample_color_invoke(bContext *C, wmOperator *op, wmEvent *event)
 {
+	SpaceImage *sima= CTX_wm_space_image(C);
+	ARegion *ar= CTX_wm_region(C);
+	SampleColorInfo *info;
+
+	if(!ED_space_image_has_buffer(sima))
+		return OPERATOR_CANCELLED;
+
+	info= MEM_callocN(sizeof(SampleColorInfo), "ImageSampleInfo");
+	info->art= ar->type;
+	info->draw_handle = ED_region_draw_cb_activate(ar->type, sample_color_draw, info, REGION_DRAW_POST_PIXEL);
+	op->customdata= info;
+
 	RNA_int_set_array(op->ptr, "location", event->mval);
+
 	sample_color_exec(C, op);
 
 	WM_event_add_modal_handler(C, op);
@@ -5437,6 +5591,7 @@
 	switch (event->type) {
 		case LEFTMOUSE:
 		case RIGHTMOUSE: // XXX hardcoded
+			sample_color_exit(C, op);
 			return OPERATOR_FINISHED;
 		case MOUSEMOVE:
 			RNA_int_set_array(op->ptr, "location", event->mval);
Index: source/blender/editors/space_image/image_draw.c
===================================================================
--- source/blender/editors/space_image/image_draw.c	(revisione 45704)
+++ source/blender/editors/space_image/image_draw.c	(copia locale)
@@ -54,6 +54,7 @@
 #include "BKE_context.h"
 #include "BKE_global.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_paint.h"
 
 #include "BIF_gl.h"
@@ -112,7 +113,7 @@
 
 /* used by node view too */
 void ED_image_draw_info(ARegion *ar, int color_manage, int channels, int x, int y,
-                        const unsigned char cp[4], const float fp[4], int *zp, float *zpf)
+                        const unsigned char cp[4], const float fp[4], int *zp, float *zpf, const char type)
 {
 	char str[256];
 	float dx = 6;
@@ -134,82 +135,89 @@
 	glEnable(GL_BLEND);
 
 	/* noisy, high contrast make impossible to read if lower alpha is used. */
-	glColor4ub(0, 0, 0, 190);
-	glRecti(0.0, 0.0, ar->winrct.xmax - ar->winrct.xmin + 1, 20);
+	if (type == 1) {
+		glColor4ub(0, 0, 0, 190);
+		glRecti(0.0, 0.0, ar->winrct.xmax - ar->winrct.xmin + 1, 20);
+	}
+	else {
+		glColor4ub(0, 0, 0, 150);
+		glRecti(0.0, 0.0, 70, 70);
+	}
 	glDisable(GL_BLEND);
 
-	BLF_size(blf_mono_font, 11, 72);
+	if (type == 1) {
+		BLF_size(blf_mono_font, 11, 72);
 
-	glColor3ub(255, 255, 255);
-	BLI_snprintf(str, sizeof(str), "X:%-4d  Y:%-4d |", x, y);
-	// UI_DrawString(6, 6, str); // works ok but fixed width is nicer.
-	BLF_position(blf_mono_font, dx, 6, 0);
-	BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-	dx += BLF_width(blf_mono_font, str);
+		glColor3ub(255, 255, 255);
+		BLI_snprintf(str, sizeof(str), "X:%-4d  Y:%-4d |", x, y);
 
-	if (zp) {
-		glColor3ub(255, 255, 255);
-		BLI_snprintf(str, sizeof(str), " Z:%-.4f |", 0.5f + 0.5f * (((float)*zp) / (float)0x7fffffff));
 		BLF_position(blf_mono_font, dx, 6, 0);
 		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
 		dx += BLF_width(blf_mono_font, str);
-	}
-	if (zpf) {
-		glColor3ub(255, 255, 255);
-		BLI_snprintf(str, sizeof(str), " Z:%-.3f |", *zpf);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
-	}
 
-	if (channels >= 3) {
-		glColor3ubv(red);
-		if (fp)
-			BLI_snprintf(str, sizeof(str), "  R:%-.4f", fp[0]);
-		else if (cp)
-			BLI_snprintf(str, sizeof(str), "  R:%-3d", cp[0]);
-		else
-			BLI_snprintf(str, sizeof(str), "  R:-");
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+		if (zp) {
+			glColor3ub(255, 255, 255);
+			BLI_snprintf(str, sizeof(str), " Z:%-.4f |", 0.5f + 0.5f * (((float)*zp) / (float)0x7fffffff));
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
+		}
+		if (zpf) {
+			glColor3ub(255, 255, 255);
+			BLI_snprintf(str, sizeof(str), " Z:%-.3f |", *zpf);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
+		}
+
+		if (channels >= 3) {
+			glColor3ubv(red);
+			if (fp)
+				BLI_snprintf(str, sizeof(str), "  R:%-.4f", fp[0]);
+			else if (cp)
+				BLI_snprintf(str, sizeof(str), "  R:%-3d", cp[0]);
+			else
+				BLI_snprintf(str, sizeof(str), "  R:-");
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 		
-		glColor3ubv(green);
-		if (fp)
-			BLI_snprintf(str, sizeof(str), "  G:%-.4f", fp[1]);
-		else if (cp)
-			BLI_snprintf(str, sizeof(str), "  G:%-3d", cp[1]);
-		else
-			BLI_snprintf(str, sizeof(str), "  G:-");
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			glColor3ubv(green);
+			if (fp)
+				BLI_snprintf(str, sizeof(str), "  G:%-.4f", fp[1]);
+			else if (cp)
+				BLI_snprintf(str, sizeof(str), "  G:%-3d", cp[1]);
+			else
+				BLI_snprintf(str, sizeof(str), "  G:-");
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 		
-		glColor3ubv(blue);
-		if (fp)
-			BLI_snprintf(str, sizeof(str), "  B:%-.4f", fp[2]);
-		else if (cp)
-			BLI_snprintf(str, sizeof(str), "  B:%-3d", cp[2]);
-		else
-			BLI_snprintf(str, sizeof(str), "  B:-");
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
-		
-		if (channels == 4) {
-			glColor3ub(255, 255, 255);
+			glColor3ubv(blue);
 			if (fp)
-				BLI_snprintf(str, sizeof(str), "  A:%-.4f", fp[3]);
+				BLI_snprintf(str, sizeof(str), "  B:%-.4f", fp[2]);
 			else if (cp)
-				BLI_snprintf(str, sizeof(str), "  A:%-3d", cp[3]);
+				BLI_snprintf(str, sizeof(str), "  B:%-3d", cp[2]);
 			else
-				BLI_snprintf(str, sizeof(str), "- ");
+				BLI_snprintf(str, sizeof(str), "  B:-");
 			BLF_position(blf_mono_font, dx, 6, 0);
 			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
 			dx += BLF_width(blf_mono_font, str);
+		
+			if(channels == 4) {
+				glColor3ub(255, 255, 255);
+				if (fp)
+					BLI_snprintf(str, sizeof(str), "  A:%-.4f", fp[3]);
+				else if (cp)
+					BLI_snprintf(str, sizeof(str), "  A:%-3d", cp[3]);
+				else
+					BLI_snprintf(str, sizeof(str), "- ");
+				BLF_position(blf_mono_font, dx, 6, 0);
+				BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+				dx += BLF_width(blf_mono_font, str);
+			}
 		}
 	}
-	
 	/* color rectangle */
 	if (channels == 1) {
 		if (fp) {
@@ -258,80 +266,99 @@
 	}
 	glDisable(GL_BLEND);
 	glColor3fv(finalcol);
-	dx += 5;
+	if (type == 1)
+		dx += 5;
+	else
+		dx = 5;
 	glBegin(GL_QUADS);
-	glVertex2f(dx, 3);
-	glVertex2f(dx, 17);
-	glVertex2f(dx + 30, 17);
-	glVertex2f(dx + 30, 3);
+	if (type == 1) {
+		glVertex2f(dx, 3);
+		glVertex2f(dx, 17);
+		glVertex2f(dx + 30, 17);
+		glVertex2f(dx + 30, 3);
+	}
+	else {
+		glVertex2f(5, 5);
+		glVertex2f(5, 65);
+		glVertex2f(65, 65);
+		glVertex2f(65, 5);
+	}
 	glEnd();
 
 	/* draw outline */
 	glColor3ub(128, 128, 128);
 	glBegin(GL_LINE_LOOP);
-	glVertex2f(dx, 3);
-	glVertex2f(dx, 17);
-	glVertex2f(dx + 30, 17);
-	glVertex2f(dx + 30, 3);
+	if (type == 1) {
+		glVertex2f(dx, 3);
+		glVertex2f(dx, 17);
+		glVertex2f(dx + 30, 17);
+		glVertex2f(dx + 30, 3);
+	}
+	else {
+		glVertex2f(5, 5);
+		glVertex2f(5, 65);
+		glVertex2f(65, 65);
+		glVertex2f(65, 5);
+	}
 	glEnd();
 
-	dx += 35;
+	if (type == 1) {
+		dx += 35;
 
-	glColor3ub(255, 255, 255);
-	if (channels == 1) {
-		if (fp) {
-			rgb_to_hsv(fp[0], fp[0], fp[0], &hue, &sat, &val);
-			rgb_to_yuv(fp[0], fp[0], fp[0], &lum, &u, &v);
-		}
-		else if (cp) {
-			rgb_to_hsv((float)cp[0] / 255.0f, (float)cp[0] / 255.0f, (float)cp[0] / 255.0f, &hue, &sat, &val);
-			rgb_to_yuv((float)cp[0] / 255.0f, (float)cp[0] / 255.0f, (float)cp[0] / 255.0f, &lum, &u, &v);
-		}
+		glColor3ub(255, 255, 255);
+		if (channels == 1) {
+			if (fp) {
+				rgb_to_hsv(fp[0], fp[0], fp[0], &hue, &sat, &val);
+				rgb_to_yuv(fp[0], fp[0], fp[0], &lum, &u, &v);
+			}
+			else if (cp) {
+				rgb_to_hsv((float)cp[0] / 255.0f, (float)cp[0] / 255.0f, (float)cp[0]/255.0f, &hue, &sat, &val);
+				rgb_to_yuv((float)cp[0] / 255.0f, (float)cp[0] / 255.0f, (float)cp[0]/255.0f, &lum, &u, &v);
+			}
 		
-		BLI_snprintf(str, sizeof(str), "V:%-.4f", val);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "V:%-.4f", val);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 
-		BLI_snprintf(str, sizeof(str), "   L:%-.4f", lum);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
-	}
-	else if (channels >= 3) {
-		if (fp) {
-			rgb_to_hsv(fp[0], fp[1], fp[2], &hue, &sat, &val);
-			rgb_to_yuv(fp[0], fp[1], fp[2], &lum, &u, &v);
+			BLI_snprintf(str, sizeof(str), "   L:%-.4f", lum);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 		}
-		else if (cp) {
-			rgb_to_hsv((float)cp[0] / 255.0f, (float)cp[1] / 255.0f, (float)cp[2] / 255.0f, &hue, &sat, &val);
-			rgb_to_yuv((float)cp[0] / 255.0f, (float)cp[1] / 255.0f, (float)cp[2] / 255.0f, &lum, &u, &v);
-		}
+		else if (channels >= 3) {
+			if (fp) {
+				rgb_to_hsv(fp[0], fp[1], fp[2], &hue, &sat, &val);
+				rgb_to_yuv(fp[0], fp[1], fp[2], &lum, &u, &v);
+			}
+			else if (cp) {
+				rgb_to_hsv((float)cp[0]/255.0f, (float)cp[1]/255.0f, (float)cp[2]/255.0f, &hue, &sat, &val);
+				rgb_to_yuv((float)cp[0]/255.0f, (float)cp[1]/255.0f, (float)cp[2]/255.0f, &lum, &u, &v);
+			}
 
-		BLI_snprintf(str, sizeof(str), "H:%-.4f", hue);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "H:%-.4f", hue);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 
-		BLI_snprintf(str, sizeof(str), "  S:%-.4f", sat);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "  S:%-.4f", sat);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 
-		BLI_snprintf(str, sizeof(str), "  V:%-.4f", val);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "  V:%-.4f", val);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
 
-		BLI_snprintf(str, sizeof(str), "   L:%-.4f", lum);
-		BLF_position(blf_mono_font, dx, 6, 0);
-		BLF_draw_ascii(blf_mono_font, str, sizeof(str));
-		dx += BLF_width(blf_mono_font, str);
+			BLI_snprintf(str, sizeof(str), "   L:%-.4f", lum);
+			BLF_position(blf_mono_font, dx, 6, 0);
+			BLF_draw_ascii(blf_mono_font, str, sizeof(str));
+			dx += BLF_width(blf_mono_font, str);
+		}
 	}
-
 	(void)dx;
 }
-
 /* image drawing */
 
 static void draw_image_grid(ARegion *ar, float zoomx, float zoomy)
@@ -476,6 +503,53 @@
 	MEM_freeN(rectf);
 }
 
+static void draw_layer_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
+{
+	int x, y;
+	int color_manage = scene->r.color_mgt_flag & R_COLOR_MANAGEMENT;
+
+	/* set zoom */
+	glPixelZoom(zoomx, zoomy);
+
+	/* find window pixel coordinates of origin */
+	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
+	
+	/* this part is generic image display */
+	if(sima->flag & SI_SHOW_ALPHA) {
+		if(ibuf->rect)
+			sima_draw_alpha_pixels(x, y, ibuf->x, ibuf->y, ibuf->rect);
+		else if(ibuf->rect_float && ibuf->channels==4)
+			sima_draw_alpha_pixelsf(x, y, ibuf->x, ibuf->y, ibuf->rect_float);
+	}
+	else if(sima->flag & SI_SHOW_ZBUF && (ibuf->zbuf || ibuf->zbuf_float || (ibuf->channels==1))) {
+		if(ibuf->zbuf)
+			sima_draw_zbuf_pixels(x, y, ibuf->x, ibuf->y, ibuf->zbuf);
+		else if(ibuf->zbuf_float)
+			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->zbuf_float);
+		else if(ibuf->channels==1)
+			sima_draw_zbuffloat_pixels(scene, x, y, ibuf->x, ibuf->y, ibuf->rect_float);
+	}
+	else {
+		
+		/* we don't draw floats buffers directly but
+		 * convert them, and optionally apply curves */
+		image_verify_buffer_float(ima, ibuf, color_manage);
+		
+		if(ibuf->rect)
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
+			glaDrawPixelsTexScaled(x, y, ibuf->x, ibuf->y, GL_RGBA, ibuf->rect, 1.0f, 1.0f);
+		//else
+			//glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_FLOAT, ibuf->rect_float);
+		
+		if(sima->flag & SI_USE_ALPHA)
+			glDisable(GL_BLEND);
+	}
+	
+	/* reset zoom */
+	glPixelZoom(1.0f, 1.0f);
+}
+
+
 static void draw_image_buffer(SpaceImage *sima, ARegion *ar, Scene *scene, Image *ima, ImBuf *ibuf, float fx, float fy, float zoomx, float zoomy)
 {
 	int x, y;
@@ -486,7 +560,7 @@
 
 	/* find window pixel coordinates of origin */
 	UI_view2d_to_region_no_clip(&ar->v2d, fx, fy, &x, &y);
-
+	
 	/* this part is generic image display */
 	if (sima->flag & SI_SHOW_ALPHA) {
 		if (ibuf->rect)
@@ -509,11 +583,11 @@
 			glEnable(GL_BLEND);
 			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 		}
-
+		
 		/* we don't draw floats buffers directly but
 		 * convert them, and optionally apply curves */
 		image_verify_buffer_float(ima, ibuf, color_manage);
-
+		
 		if (ibuf->rect)
 			glaDrawPixelsSafe(x, y, ibuf->x, ibuf->y, ibuf->x, GL_RGBA, GL_UNSIGNED_BYTE, ibuf->rect);
 #if 0
@@ -524,7 +598,7 @@
 		if (sima->flag & SI_USE_ALPHA)
 			glDisable(GL_BLEND);
 	}
-
+	
 	/* reset zoom */
 	glPixelZoom(1.0f, 1.0f);
 }
@@ -741,15 +815,40 @@
 	}
 }
 
+static void layer_draw_boundary(int xmin, int ymin, int xsize, int ysize, float zoomx, float zoomy) 
+{
+	unsigned char col1[4], col2[4];
+	UI_GetThemeColor3ubv(TH_COL1_BOUNDARY_LAYER, col1);
+	UI_GetThemeColor3ubv(TH_COL2_BOUNDARY_LAYER, col2);
+
+	glEnable(GL_LINE_STIPPLE);
+	glColor3ub(col1[0], col1[1], col1[2]);//col1
+	glLineStipple(2, 0x0F0F);
+	sdrawbox(xmin, ymin, xmin+zoomx*xsize, ymin+zoomy*ysize);
+	glDisable(GL_LINE_STIPPLE);
+
+	glEnable(GL_LINE_STIPPLE);
+	glColor3ub(col2[0], col2[1], col2[2]);//col2
+	glLineStipple(2, 0xF0F0);
+	sdrawbox(xmin, ymin, xmin+zoomx*xsize, ymin+zoomy*ysize);
+	glDisable(GL_LINE_STIPPLE);
+}
+
+
 /* draw main image area */
 
 void draw_image_main(SpaceImage *sima, ARegion *ar, Scene *scene)
 {
 	Image *ima;
+	ImageLayer *layer;
 	ImBuf *ibuf;
-	float zoomx, zoomy;
+	ImBuf *next_ibuf, *result_ibuf;
+	float zoomx, zoomy, sp_x, sp_y;
 	int show_viewer, show_render;
+	int first = 0;
+	int x, y, b_x, b_y, bg_x, bg_y;
 	void *lock;
+	char background=0;
 
 	/* XXX can we do this in refresh? */
 #if 0
@@ -778,7 +877,7 @@
 
 	show_viewer = (ima && ima->source == IMA_SRC_VIEWER);
 	show_render = (show_viewer && ima->type == IMA_TYPE_R_RESULT);
-
+	
 	/* draw the image or grid */
 	if (ibuf == NULL)
 		draw_image_grid(ar, zoomx, zoomy);
@@ -786,8 +885,89 @@
 		draw_image_buffer_repeated(sima, ar, scene, ima, ibuf, zoomx, zoomy);
 	else if (ima && (ima->tpageflag & IMA_TILES))
 		draw_image_buffer_tiled(sima, ar, scene, ima, ibuf, 0.0f, 0.0, zoomx, zoomy);
-	else
+	else if (ima && !show_render && (sima->flag & SI_DRAWTOOL)) {
+		next_ibuf = NULL;
+		ibuf = BKE_image_acquire_ibuf(ima, NULL, &lock);
+		layer = ima->imlayers.last;
+		
+		bg_x = ((ImBuf*)((ImageLayer*)layer->ibufs.first))->x;
+		bg_y = ((ImBuf*)((ImageLayer*)layer->ibufs.first))->y;
+		
+		if (layer->background & IMA_LAYER_BG_ALPHA) //Alpha
+			background = 1;
+
+		for(layer=ima->imlayers.last; layer; layer=layer->prev) {
+			if (!first) {
+				if ((layer->opacity!=1.0f) || (ibuf->channels==4) || (background==1)) {
+					UI_view2d_to_region_no_clip(&ar->v2d, 0.0f, 0.0f, &x, &y);
+					fdrawcheckerboard(x, y, x + ibuf->x * zoomx, y + ibuf->y * zoomy);
+					first = 1;
+				}
+			}
+
+			if (layer->visible & IMA_LAYER_VISIBLE) {
+				ibuf = (ImBuf*)((ImageLayer*)layer->ibufs.first);
+				
+				if (ibuf) {
+					result_ibuf = imalayer_blend(next_ibuf, ibuf, layer->opacity, layer->mode);
+					if (next_ibuf)
+						IMB_freeImBuf(next_ibuf);
+					
+					next_ibuf = IMB_dupImBuf(result_ibuf);
+
+					if (layer->background & IMA_LAYER_BG_IMAGE) {
+						/*sp_x = 1 / ((float)(bg_x - ibuf->x) / 2);
+						sp_y = 1 / ((float)(bg_y - ibuf->y) / 2);
+						*/
+						sp_x = 0.0f;
+						sp_y = 0.0f;
+					}
+					else {
+						sp_x = 0.0f;
+						sp_y = 0.0f;
+					}
+					
+					glEnable(GL_BLEND);
+					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+					glColor4f(1.0f, 1.0f, 1.0f, layer->opacity);
+					draw_layer_buffer(sima, ar, scene, ima, result_ibuf, sp_x, sp_y, zoomx, zoomy);
+					glDisable(GL_BLEND);
+
+					if (result_ibuf)
+						IMB_freeImBuf(result_ibuf);
+				}
+			}
+
+			if (UI_GetThemeValue(TH_SHOW_BOUNDARY_LAYER)) {
+				if (layer->select & IMA_LAYER_SEL_CURRENT) {
+					b_x = ibuf->x;
+					b_y = ibuf->y;
+				}
+			}
+		}
+
+		glDisable(GL_BLEND);
+		if (UI_GetThemeValue(TH_SHOW_BOUNDARY_LAYER))
+			layer_draw_boundary(x, y, b_x, b_y, zoomx, zoomy);
+
+		if (next_ibuf)
+			IMB_freeImBuf(next_ibuf);
+		BKE_image_release_ibuf(ima, lock);
+	}
+	else {
+		layer = ima->imlayers.last;
+		if (layer->background & IMA_LAYER_BG_ALPHA) {
+			int x, y;
+			UI_view2d_to_region_no_clip(&ar->v2d, 0.0f, 0.0f, &x, &y);
+			fdrawcheckerboard(x, y, x + ibuf->x * zoomx, y + ibuf->y * zoomy);
+		}
+
 		draw_image_buffer(sima, ar, scene, ima, ibuf, 0.0f, 0.0f, zoomx, zoomy);
+		
+		if (layer->background & IMA_LAYER_BG_ALPHA)
+			glDisable(GL_BLEND);
+	}
 
 	/* paint helpers */
 	if (sima->flag & SI_DRAWTOOL)
Index: source/blender/editors/space_image/image_intern.h
===================================================================
--- source/blender/editors/space_image/image_intern.h	(revisione 45704)
+++ source/blender/editors/space_image/image_intern.h	(copia locale)
@@ -93,5 +93,17 @@
 void IMAGE_OT_properties(struct wmOperatorType *ot);
 void IMAGE_OT_scopes(struct wmOperatorType *ot);
 
+/* image layers */
+void IMAGE_OT_image_layer_move(struct wmOperatorType *ot);
+//void IMAGE_OT_image_layer_fill_color(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_remove(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add_below(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_add_above(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_duplicate(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_select(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_clean(struct wmOperatorType *ot);
+void IMAGE_OT_image_layer_merge(struct wmOperatorType *ot);
+
+
 #endif /* __IMAGE_INTERN_H__ */
-
Index: source/blender/editors/space_image/image_ops.c
===================================================================
--- source/blender/editors/space_image/image_ops.c	(revisione 45704)
+++ source/blender/editors/space_image/image_ops.c	(copia locale)
@@ -47,6 +47,7 @@
 #include "BKE_colortools.h"
 #include "BKE_context.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 #include "BKE_global.h"
 #include "BKE_library.h"
 #include "BKE_main.h"
@@ -818,61 +819,87 @@
 	PointerRNA idptr;
 	Image *ima = NULL;
 	char str[FILE_MAX];
+	int action = RNA_enum_get(op->ptr, "action");
 
 	RNA_string_get(op->ptr, "filepath", str);
 	/* default to frame 1 if there's no scene in context */
+	if ((sima->image == NULL) || (action & IMA_LAYER_OPEN_IMAGE)) {
+		errno = 0;
 
-	errno = 0;
+		ima = BKE_add_image_file(str);
+		if (!ima) {
+			if (op->customdata) MEM_freeN(op->customdata);
+			BKE_reportf(op->reports, RPT_ERROR, "Can't read: \"%s\", %s", str, errno ? strerror(errno) : "Unsupported image format");
+			return OPERATOR_CANCELLED;
+		}
 
-	ima = BKE_add_image_file(str);
+		if (!op->customdata)
+			image_open_init(C, op);
 
-	if (!ima) {
-		if (op->customdata) MEM_freeN(op->customdata);
-		BKE_reportf(op->reports, RPT_ERROR, "Can't read: \"%s\", %s", str, errno ? strerror(errno) : "Unsupported image format");
-		return OPERATOR_CANCELLED;
-	}
+		/* hook into UI */
+		pprop = op->customdata;
+
+		if (pprop->prop) {
+			/* when creating new ID blocks, use is already 1, but RNA
+			 * pointer se also increases user, so this compensates it */
+			ima->id.us--;
+
+			RNA_id_pointer_create(&ima->id, &idptr);
+			RNA_property_pointer_set(&pprop->ptr, pprop->prop, idptr);
+			RNA_property_update(C, &pprop->ptr, pprop->prop);
+		}
+		else if (sima) {
+			ED_space_image_set(sima, scene, obedit, ima);
+			iuser = &sima->iuser;
+		}
+		else {
+			Tex *tex = CTX_data_pointer_get_type(C, "texture", &RNA_Texture).data;
+			if (tex && tex->type == TEX_IMAGE)
+				iuser = &tex->iuser;
+		
+		}
+		
+		/* initialize because of new image */
+		if (iuser) {
+			iuser->sfra = 1;
+			iuser->offset = 0;
+			iuser->fie_ima = 2;
+		}
+
+		/* XXX unpackImage frees image buffers */
+		ED_preview_kill_jobs(C);
 	
-	if (!op->customdata)
-		image_open_init(C, op);
+		BKE_image_signal(ima, iuser, IMA_SIGNAL_RELOAD);
+		WM_event_add_notifier(C, NC_IMAGE | NA_EDITED | ND_DRAW, ima);
 
-	/* hook into UI */
-	pprop = op->customdata;
+		MEM_freeN(op->customdata);
+	} else if ((action & IMA_LAYER_OPEN_LAYER)) {
+		if (sima) {
+			ima = sima->image;
+		}
 
-	if (pprop->prop) {
-		/* when creating new ID blocks, use is already 1, but RNA
-		 * pointer se also increases user, so this compensates it */
-		ima->id.us--;
+		if (ima) {
+			ImageLayer *iml;
+			struct ImBuf *ibuf;
+			int flag;
 
-		RNA_id_pointer_create(&ima->id, &idptr);
-		RNA_property_pointer_set(&pprop->ptr, pprop->prop, idptr);
-		RNA_property_update(C, &pprop->ptr, pprop->prop);
-	}
-	else if (sima) {
-		ED_space_image_set(sima, scene, obedit, ima);
-		iuser = &sima->iuser;
-	}
-	else {
-		Tex *tex = CTX_data_pointer_get_type(C, "texture", &RNA_Texture).data;
-		if (tex && tex->type == TEX_IMAGE)
-			iuser = &tex->iuser;
+			iml = BKE_add_image_file_as_layer(ima, str);
+			iml->background = IMA_LAYER_BG_IMAGE;
+			strcpy(iml->file_path, str);
+			flag= IB_rect|IB_multilayer|IB_metadata;
+			if (ima->flag & IMA_DO_PREMUL)
+				flag |= IB_premul;
 		
+			/* read ibuf */
+			ibuf = IMB_loadiffname(str, flag);
+			BLI_addtail(&iml->ibufs, ibuf);
+			if(!iml)
+				return OPERATOR_CANCELLED;
+
+			WM_event_add_notifier(C, NC_IMAGE | ND_DRAW, ima);
+			MEM_freeN(op->customdata);
+		}
 	}
-	
-	/* initialize because of new image */
-	if (iuser) {
-		iuser->sfra = 1;
-		iuser->offset = 0;
-		iuser->fie_ima = 2;
-	}
-
-	/* XXX unpackImage frees image buffers */
-	ED_preview_kill_jobs(C);
-	
-	BKE_image_signal(ima, iuser, IMA_SIGNAL_RELOAD);
-	WM_event_add_notifier(C, NC_IMAGE | NA_EDITED, ima);
-	
-	MEM_freeN(op->customdata);
-
 	return OPERATOR_FINISHED;
 }
 
@@ -908,6 +935,13 @@
 /* called by other space types too */
 void IMAGE_OT_open(wmOperatorType *ot)
 {
+	PropertyRNA *prop;
+	static EnumPropertyItem open_actions[] = {
+			{IMA_LAYER_OPEN_IMAGE, "IMAGE", 0, "Image", "Open Image"},
+			{IMA_LAYER_OPEN_LAYER, "LAYER", 0, "Layer", "Open image as layer"},
+			{0, NULL, 0, NULL, NULL}
+	};
+
 	/* identifiers */
 	ot->name = "Open Image";
 	ot->description = "Open image";
@@ -921,6 +955,8 @@
 	/* flags */
 	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
 
+	prop = RNA_def_enum(ot->srna, "action", open_actions, IMA_LAYER_DEL_SELECTED, "Action", "Selection action to execute");
+	RNA_def_property_flag(prop, PROP_HIDDEN);
 	/* properties */
 	WM_operator_properties_filesel(ot, FOLDERFILE | IMAGEFILE | MOVIEFILE, FILE_SPECIAL, FILE_OPENFILE, WM_FILESEL_FILEPATH | WM_FILESEL_RELPATH, FILE_DEFAULTDISPLAY);
 }
@@ -1504,6 +1540,7 @@
 	char name[MAX_ID_NAME - 2];
 	float color[4];
 	int width, height, floatbuf, uvtestgrid, alpha;
+	short background;
 
 	/* retrieve state */
 	sima = CTX_wm_space_image(C);
@@ -1517,7 +1554,21 @@
 	uvtestgrid = RNA_boolean_get(op->ptr, "uv_test_grid");
 	RNA_float_get_array(op->ptr, "color", color);
 	alpha = RNA_boolean_get(op->ptr, "alpha");
-	
+	background = RNA_enum_get(op->ptr, "background");
+
+	if (background & IMA_LAYER_BG_WHITE) {
+		color[0] = 1.0f;
+		color[1] = 1.0f;
+		color[2] = 1.0f;
+		color[3] = 1.0f;
+	}
+	else if (background & IMA_LAYER_BG_ALPHA) {
+		color[0] = 0.0f;
+		color[1] = 0.0f;
+		color[2] = 0.0f;
+		color[3] = 0.0f;
+	}
+
 	if (!floatbuf && scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
 		linearrgb_to_srgb_v3_v3(color, color);
 
@@ -1525,7 +1576,8 @@
 		color[3] = 1.0f;
 
 	ima = BKE_add_image_size(width, height, name, alpha ? 32 : 24, floatbuf, uvtestgrid, color);
-
+	((ImageLayer *)ima->imlayers.last)->background = background;
+	copy_v4_v4(((ImageLayer *)ima->imlayers.first)->default_color, color);
 	if (!ima)
 		return OPERATOR_CANCELLED;
 
@@ -1560,8 +1612,17 @@
 void IMAGE_OT_new(wmOperatorType *ot)
 {
 	PropertyRNA *prop;
-	static float default_color[4] = {0.0f, 0.0f, 0.0f, 1.0f};
+	short background;
 	
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 1.0f};
+
+	static EnumPropertyItem prop_background_items[] = {
+		{IMA_LAYER_BG_RGB, "RGB", 0, "RGB", ""},
+		{IMA_LAYER_BG_WHITE, "WHITE", 0, "White", ""},
+		{IMA_LAYER_BG_ALPHA, "ALPHA", 0, "Transparent", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	
 	/* identifiers */
 	ot->name = "New Image";
 	ot->description = "Create a new image";
@@ -1570,7 +1631,7 @@
 	/* api callbacks */
 	ot->exec = image_new_exec;
 	ot->invoke = image_new_invoke;
-	
+		
 	/* flags */
 	ot->flag = OPTYPE_UNDO;
 
@@ -1578,11 +1639,14 @@
 	RNA_def_string(ot->srna, "name", "untitled", MAX_ID_NAME - 2, "Name", "Image datablock name");
 	RNA_def_int(ot->srna, "width", 1024, 1, INT_MAX, "Width", "Image width", 1, 16384);
 	RNA_def_int(ot->srna, "height", 1024, 1, INT_MAX, "Height", "Image height", 1, 16384);
-	prop = RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Color", "Default fill color", 0.0f, 1.0f);
+	RNA_def_enum(ot->srna, "background", prop_background_items, 0, "Background", "");
+
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Color", "Default fill color", 0.0f, 1.0f);
 	RNA_def_property_float_array_default(prop, default_color);
 	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel");
+	RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth");
 	RNA_def_boolean(ot->srna, "uv_test_grid", 0, "UV Test Grid", "Fill the image with a grid for UV map testing");
-	RNA_def_boolean(ot->srna, "float", 0, "32 bit Float", "Create image with 32 bit floating point bit depth");
+	
 }
 
 /********************* invert operators *********************/
@@ -1670,6 +1734,613 @@
 	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
 }
 
+/********************** new image layer operators *********************/
+
+int image_layer_poll(bContext *C)
+{	
+	SpaceImage *sima= CTX_wm_space_image(C);
+	return ED_space_image_show_paint(sima);
+}
+ 
+static int image_layer_add_exec(bContext *C, wmOperator *op)
+{	
+	char name[22];
+	float color[4];
+	int alpha, order;
+	Scene *scene;
+	Image *ima = CTX_data_edit_image(C);
+	ImageLayer *iml;
+	
+	scene= (Scene*)CTX_data_scene(C);
+
+	RNA_string_get(op->ptr, "name", name);
+	RNA_float_get_array(op->ptr, "color", color);
+	alpha = RNA_boolean_get(op->ptr, "alpha");
+
+	order = 2;
+	if (strcmp(op->idname, "IMAGE_OT_image_layer_add_above") == 0)
+		order = 1;
+	else if (strcmp(op->idname, "IMAGE_OT_image_layer_add_below") == 0)
+		order = -1;
+
+	if (scene->r.color_mgt_flag & R_COLOR_MANAGEMENT)
+		linearrgb_to_srgb_v3_v3(color, color);
+
+	if(!alpha) 
+		color[3] = 1.0f;
+	
+	iml = image_add_image_layer(ima, name, alpha ? 32 : 24, color, order);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_add(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "New Layer";
+	ot->idname= "IMAGE_OT_image_layer_add";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec = image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke = image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+void IMAGE_OT_image_layer_add_above(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "Above active layer";
+	ot->idname= "IMAGE_OT_image_layer_add_above";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke= image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+void IMAGE_OT_image_layer_add_below(wmOperatorType *ot)
+{
+	PropertyRNA *prop;
+	static float default_color[4]= {0.0f, 0.0f, 0.0f, 0.0f};
+
+	/* identifiers */
+	ot->name= "Below active layer";
+	ot->idname= "IMAGE_OT_image_layer_add_below";
+	ot->description="Add a new image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_add_exec;
+	ot->poll = image_layer_poll;
+	ot->invoke= image_new_invoke;
+	
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_string(ot->srna, "name", "Layer", 21, "Name", "Layer name.");
+	prop= RNA_def_float_color(ot->srna, "color", 4, NULL, 0.0f, FLT_MAX, "Fill Color", "Color used to fill the layer.", 0.0f, 1.0f);
+	RNA_def_property_float_array_default(prop, default_color);
+	RNA_def_boolean(ot->srna, "alpha", 1, "Alpha", "Create an image with an alpha channel.");
+}
+
+static int image_layer_duplicate_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *iml;
+
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	iml = image_duplicate_current_image_layer(ima);
+	if(!iml)
+		return OPERATOR_CANCELLED;
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_duplicate(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->name= "Duplicate Layer";
+	ot->idname= "IMAGE_OT_image_layer_duplicate";
+	ot->description="Duplicate the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_duplicate_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
+
+
+static int image_layer_remove_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	int action = RNA_enum_get(op->ptr, "action");
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	image_remove_layer(ima, action);
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_remove(wmOperatorType *ot)
+{
+	static EnumPropertyItem select_all_actions[] = {
+			{IMA_LAYER_DEL_SELECTED, "SELECTED", 0, "Selected", "Remove the selected layer"},
+			{IMA_LAYER_DEL_HIDDEN, "HIDDEN", 0, "Hidden", "Removes the hidden layers"},
+			{0, NULL, 0, NULL, NULL}
+	};
+
+	/* identifiers */
+	ot->name= "Remove Layer";
+	ot->idname= "IMAGE_OT_image_layer_remove";
+	ot->description="Remove the selected image layer";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_remove_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+
+	/* properties */
+	RNA_def_enum(ot->srna, "action", select_all_actions, IMA_LAYER_DEL_SELECTED, "Action", "Selection action to execute");
+}
+
+static int image_layer_move_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer, *tmp;
+	int type, layerID;
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+ 
+	layer = imalayer_get_current(ima);
+ 
+	if (!layer)
+		return OPERATOR_CANCELLED;
+ 
+	type = RNA_enum_get(op->ptr, "type");
+	layerID = imalayer_get_current_act(ima);
+	
+	if (!(layer->type & IMA_LAYER_BASE)) {
+		if (type == -1) { /* Move direction: Up */
+			if (layerID > 0) {
+				tmp = layer->prev;
+				BLI_remlink(&ima->imlayers, layer);
+				layer->next = layer->prev = NULL;
+				if (tmp) {
+					BLI_insertlinkbefore(&ima->imlayers, tmp, layer);
+				}
+				else {
+					BLI_addhead(&ima->imlayers, layer);
+				}
+				imalayer_set_current_act(ima, layerID-1);
+			}
+		}
+		else if (type == 1){ /* Move direction: Down */
+			if (layerID < (ima->Count_Layers - 1)) {
+				tmp = layer->next;
+				if (!(tmp->type & IMA_LAYER_BASE)) {
+					BLI_remlink(&ima->imlayers, layer);
+					layer->next = layer->prev = NULL;
+					if (tmp) {
+						BLI_insertlinkafter(&ima->imlayers, tmp, layer);
+					}
+					else {
+						BLI_addtail(&ima->imlayers, layer);
+					}	
+					imalayer_set_current_act(ima, layerID+1);
+				}
+			}
+		}
+		else if (type == -2) {  /* Move direction: Top */
+			BLI_remlink(&ima->imlayers, layer);
+			layer->next = layer->prev = NULL;
+			BLI_addhead(&ima->imlayers, layer);
+			ima->Act_Layers = 0;
+		}
+		else if (type == 2) {  /* Move direction: Bottom */
+			BLI_remlink(&ima->imlayers, layer);
+			layer->next = layer->prev = NULL;
+			if (((ImageLayer *)ima->imlayers.last)->type & IMA_LAYER_BASE) {
+				BLI_insertlink(&ima->imlayers,((ImageLayer *)ima->imlayers.last)->prev, layer);
+				ima->Act_Layers = ima->Count_Layers - 2;
+			}
+			else {
+				BLI_addtail(&ima->imlayers, layer);
+				ima->Act_Layers = ima->Count_Layers - 1;
+			}
+		}
+		else if (type == 3) {  /* Move direction: Invert */
+			int i = 0, lim;
+			ImageLayer *tmp1, *tmp2, *next, *prev, *tmp_up, *tmp_down;
+			if (ima->Count_Layers > 2) {
+				if (ima->Count_Layers % 2 == 0)
+					lim = (ima->Count_Layers / 2);
+				else
+					lim = (ima->Count_Layers / 2) + 1;
+
+				tmp_up = (ImageLayer *)ima->imlayers.first;
+				tmp_down = ((ImageLayer *)ima->imlayers.last)->prev;
+				while ((i<lim) && (tmp_up != tmp_down)) {
+					tmp1 = tmp_down;
+					tmp2 = tmp_up;
+
+					next = tmp_down->next;
+					prev = tmp_down->prev;
+					
+					tmp_down->next = tmp2->next;
+					tmp_down->prev = tmp2->prev;
+					if (tmp2->prev)
+						tmp2->prev->next = tmp_down;
+					else
+						ima->imlayers.first = tmp_down;
+					tmp2->next->prev = tmp_down;
+
+					tmp_up->next = next;
+					tmp_up->prev = prev;
+					if (prev)
+						prev->next = tmp_up;
+					next->prev = tmp_up;
+
+					prev = tmp_up->prev;
+					tmp_up = tmp_down->next;
+					tmp_down = prev;
+					i++;
+				}
+			}
+		}
+	}
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+ 
+	return OPERATOR_FINISHED;
+}
+ 
+void IMAGE_OT_image_layer_move(wmOperatorType *ot)
+{
+	static EnumPropertyItem slot_move[] = {
+		{-2, "TOP", 0, "Top", ""},
+		{-1, "UP", 0, "Up", ""},
+		{1, "DOWN", 0, "Down", ""},
+		{2, "BOTTOM", 0, "Bottom", ""},
+		{3, "INVERT", 0, "Invert", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Move Layer";
+	ot->idname= "IMAGE_OT_image_layer_move";
+	ot->description="Move image layers up and down";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_move_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "type", slot_move, 0, "Type", "");
+}
+
+static int image_layer_select_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer;
+	int action = RNA_enum_get(op->ptr, "action");
+
+	layer = imalayer_get_current(ima);
+	
+	switch (action) {
+		case IMA_LAYER_SEL_PREVIOUS:
+			if (ima->Act_Layers >= 1) {
+				layer->select = !IMA_LAYER_SEL_CURRENT;
+				layer->prev->select = IMA_LAYER_SEL_CURRENT;
+				ima->Act_Layers--;
+			}
+			//else
+			//	layer->select = IMA_LAYER_SEL_CURRENT;
+			break;
+		case IMA_LAYER_SEL_NEXT:
+			if (ima->Act_Layers < (ima->Count_Layers-1)) {
+				layer->select = !IMA_LAYER_SEL_CURRENT;
+				layer->next->select = IMA_LAYER_SEL_CURRENT;
+				ima->Act_Layers++;
+			}
+			//else
+			//	layer->select = IMA_LAYER_SEL_CURRENT;
+			break;
+		case IMA_LAYER_SEL_TOP:
+			((ImageLayer *)ima->imlayers.first)->select = IMA_LAYER_SEL_CURRENT;
+			ima->Act_Layers = 0;
+			break;
+		case IMA_LAYER_SEL_BOTTOM:
+			((ImageLayer *)ima->imlayers.last)->select = IMA_LAYER_SEL_CURRENT;
+			ima->Act_Layers = ima->Count_Layers - 1;
+			break;
+	}
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_select(wmOperatorType *ot)
+{
+	static EnumPropertyItem select_all_actions[] = {
+			{IMA_LAYER_SEL_PREVIOUS, "PREVIOUS", 0, "Previous", "Select the previous layer"},
+			{IMA_LAYER_SEL_NEXT, "NEXT", 0, "Next", "Select the next layer"},
+			{IMA_LAYER_SEL_TOP, "TOP", 0, "Top", "Select the top layer"},
+			{IMA_LAYER_SEL_BOTTOM, "BOTTOM", 0, "Select the bottom layer"},
+			{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Select Layers";
+	ot->idname= "IMAGE_OT_image_layer_select";
+	ot->description="Select layers";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_select_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "action", select_all_actions, IMA_LAYER_SEL_NEXT, "Action", "Selection action to execute");
+}
+
+static int image_layer_merge_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer;
+	int type;
+ 
+	if(!ima)
+		return OPERATOR_CANCELLED;
+  
+	type = RNA_enum_get(op->ptr, "type");
+	
+	if (type == 1) { /* Merge Layers */
+		layer = imalayer_get_current(ima);
+		if (!layer)
+				return OPERATOR_CANCELLED;
+		
+		if (!(layer->type & IMA_LAYER_BASE)) {
+			ImageLayer *next;
+			
+			next = layer->next;
+			if ((next->visible & IMA_LAYER_VISIBLE) && (!(next->lock & IMA_LAYER_LOCK))) {
+				merge_layers(ima, layer, next);
+
+				imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+				ima->Count_Layers--;
+			}
+			else
+				if (!(next->visible & IMA_LAYER_VISIBLE))
+					BKE_report(op->reports, RPT_INFO, "It can not merge the layers, because the next layer is hidden");
+				else
+					BKE_report(op->reports, RPT_INFO, "It can not merge the layers, because the next layer is locked");
+		}
+	}
+	else if (type == 2) { /* Merge Visible */
+		int i=0;
+		ImageLayer *next;
+		for (layer = (ImageLayer *)ima->imlayers.first; layer; layer = layer->next) {
+			if (layer->visible & IMA_LAYER_VISIBLE) {
+				i = 1;
+				break;
+			}
+		}
+		if (i == 1) {
+			next = layer;
+			while ((next != NULL) && (layer->type != IMA_LAYER_BASE)) {
+				next = layer->next;
+				while ((next != NULL) && (!(next->visible & IMA_LAYER_VISIBLE)))
+					next = next->next;
+
+				if (next) {
+					layer = merge_layers(ima, layer, next);
+					ima->Count_Layers--;
+				}
+			}
+			imalayer_set_current_act(ima,imalayer_get_current_act(ima));
+		}
+		else
+			BKE_report(op->reports, RPT_INFO, "It can not merge the layers, because the layers are hidden");
+	}
+	else if (type == 3) {  /* Merge One */
+		ImageLayer *next, *app;
+		for (layer = (ImageLayer *)ima->imlayers.first; layer; layer = layer->next) {
+			if (layer->visible & IMA_LAYER_VISIBLE) {
+				break;
+			}
+			else {
+				BLI_remlink(&ima->imlayers, layer);
+				free_image_layer(layer);
+				ima->Count_Layers--;
+			}
+		}
+		if (ima->imlayers.first) {
+			next = layer;
+			while ((next != NULL) && (layer->type != IMA_LAYER_BASE)) {
+				next = layer->next;
+				while ((next != NULL) && (!(next->visible & IMA_LAYER_VISIBLE))) {
+					app = next;
+					next = next->next;
+
+					BLI_remlink(&ima->imlayers, app);
+					free_image_layer(app);
+					ima->Count_Layers--;
+				}
+				if (next) {
+					layer = merge_layers(ima, layer, next);
+					ima->Count_Layers--;
+				}
+			}
+			//imalayer_set_current_act(ima, 1);
+			imalayer_set_current_act(ima, imalayer_get_current_act(ima));
+			layer = (ImageLayer *)ima->imlayers.last;
+			if (!(layer->type & IMA_LAYER_BASE)) {
+				ImBuf *base;
+				int i;
+				
+				base = (ImBuf *)layer->ibufs.first;
+				if (base->rect_float) {
+					float *fp_b = (float *) base->rect_float;
+					for( i = base->x * base->y; i > 0; i--, fp_b+=4) {
+						if (fp_b[3] != 1.0f) {
+							if (fp_b[3] == 0.0f) {
+								fp_b[0] = 1.0f;
+								fp_b[1] = 1.0f;
+								fp_b[2] = 1.0f;
+							}
+							fp_b[3] = 1.0f;
+						}
+					}
+				} else if(base->rect) {
+					char *cp_b = (char *) base->rect;
+					for( i = base->x * base->y; i > 0; i--, cp_b+=4) {
+						if (cp_b[3] != 255) {
+							if (cp_b[3] == 0) {
+								cp_b[0] = 255;
+								cp_b[1] = 255;
+								cp_b[2] = 255;
+							}
+							cp_b[3] = 255;
+						}
+					}
+				}
+			}
+		}
+		else {
+			static float white_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};
+			image_add_image_layer_base(ima);
+			imalayer_fill_color(ima, white_color);
+		}
+	}
+	
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, NULL);
+ 
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_merge(wmOperatorType *ot)
+{
+	static EnumPropertyItem slot_merge[] = {
+		{1, "DOWN", 0, "Down", ""},
+		{2, "VISIBLE", 0, "Visible", ""},
+		{3, "ONE", 0, "One", ""},
+		{0, NULL, 0, NULL, NULL}
+	};
+ 
+	/* identifiers */
+	ot->name= "Merge Layer";
+	ot->idname= "IMAGE_OT_image_layer_merge";
+	ot->description="Layers merge into one";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_merge_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+ 
+	/* properties */
+	RNA_def_enum(ot->srna, "type", slot_merge, 0, "Type", "");
+}
+
+static int image_layer_clean_exec(bContext *C, wmOperator *op)
+{
+	Image *ima= CTX_data_edit_image(C);
+	ImageLayer *layer;
+	static float alpha_color[4] = {0.0f, 0.0f, 0.0f, 0.0f};
+	static float white_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};
+
+	layer = imalayer_get_current(ima);
+
+	if (layer->background & IMA_LAYER_BG_IMAGE) {
+		int flag;
+		struct ImBuf *ibuf;
+
+		ibuf = layer->ibufs.first;
+		BLI_remlink(&layer->ibufs, ibuf);
+		IMB_freeImBuf(ibuf);
+
+		flag= IB_rect|IB_multilayer|IB_metadata;
+		if (ima->flag & IMA_DO_PREMUL)
+			flag |= IB_premul;
+
+		ibuf = IMB_loadiffname(layer->file_path, flag);
+		
+		BLI_addtail(&layer->ibufs, ibuf);
+	}
+	else if (layer->background & IMA_LAYER_BG_WHITE)
+		imalayer_fill_color(ima, white_color);
+	else if (layer->background & IMA_LAYER_BG_ALPHA)
+		imalayer_fill_color(ima, alpha_color);
+	else {
+		if (layer->default_color[0] != -1)
+			imalayer_fill_color(ima, layer->default_color);
+	}
+
+	WM_event_add_notifier(C, NC_IMAGE|ND_DRAW, ima);
+	return OPERATOR_FINISHED;
+}
+
+void IMAGE_OT_image_layer_clean(wmOperatorType *ot)
+{
+ 
+	/* identifiers */
+	ot->name= "Clean Layer";
+	ot->idname= "IMAGE_OT_image_layer_clean";
+	ot->description="Clean image layers";
+ 
+	/* api callbacks */
+	ot->exec= image_layer_clean_exec;
+	ot->poll = image_layer_poll;
+ 
+	/* flags */
+	ot->flag= OPTYPE_REGISTER|OPTYPE_UNDO;
+}
 /********************* pack operator *********************/
 
 static int image_pack_test(bContext *C, wmOperator *op)
@@ -1860,7 +2531,7 @@
 	ImageSampleInfo *info = arg_info;
 	if (info->draw) {
 		/* no color management needed for images (color_manage=0) */
-		ED_image_draw_info(ar, 0, info->channels, info->x, info->y, info->colp, info->colfp, info->zp, info->zfp);
+		ED_image_draw_info(ar, 0, info->channels, info->x, info->y, info->colp, info->colfp, info->zp, info->zfp, 1);
 	}
 }
 
@@ -1872,12 +2543,14 @@
 	ImBuf *ibuf = ED_space_image_acquire_buffer(sima, &lock);
 	ImageSampleInfo *info = op->customdata;
 	float fx, fy;
+	//wmWindow *win= CTX_wm_window(C);
 	
 	if (ibuf == NULL) {
 		ED_space_image_release_buffer(sima, lock);
 		return;
 	}
 
+	//WM_cursor_modal(win, BC_EYEDROPPER_CURSOR);
 	UI_view2d_region_to_view(&ar->v2d, event->mval[0], event->mval[1], &fx, &fy);
 
 	if (fx >= 0.0f && fy >= 0.0f && fx < 1.0f && fy < 1.0f) {
@@ -1991,7 +2664,7 @@
 
 	if (!ED_space_image_has_buffer(sima))
 		return OPERATOR_CANCELLED;
-	
+
 	info = MEM_callocN(sizeof(ImageSampleInfo), "ImageSampleInfo");
 	info->art = ar->type;
 	info->draw_handle = ED_region_draw_cb_activate(ar->type, image_sample_draw, info, REGION_DRAW_POST_PIXEL);
@@ -2005,7 +2678,7 @@
 }
 
 static int image_sample_modal(bContext *C, wmOperator *op, wmEvent *event)
-{
+{	
 	switch (event->type) {
 		case LEFTMOUSE:
 		case RIGHTMOUSE: // XXX hardcoded
Index: source/blender/editors/space_image/space_image.c
===================================================================
--- source/blender/editors/space_image/space_image.c	(revisione 45704)
+++ source/blender/editors/space_image/space_image.c	(copia locale)
@@ -420,7 +420,7 @@
 	
 	BLI_addtail(&simage->regionbase, ar);
 	ar->regiontype = RGN_TYPE_WINDOW;
-	
+
 	return (SpaceLink *)simage;
 }
 
@@ -491,6 +491,17 @@
 
 	WM_operatortype_append(IMAGE_OT_properties);
 	WM_operatortype_append(IMAGE_OT_scopes);
+
+	WM_operatortype_append(IMAGE_OT_image_layer_move);
+	//WM_operatortype_append(IMAGE_OT_image_layer_fill_color);
+	WM_operatortype_append(IMAGE_OT_image_layer_remove);
+	WM_operatortype_append(IMAGE_OT_image_layer_add);
+	WM_operatortype_append(IMAGE_OT_image_layer_add_below);
+	WM_operatortype_append(IMAGE_OT_image_layer_add_above);
+	WM_operatortype_append(IMAGE_OT_image_layer_duplicate);
+	WM_operatortype_append(IMAGE_OT_image_layer_select);
+	WM_operatortype_append(IMAGE_OT_image_layer_clean);
+	WM_operatortype_append(IMAGE_OT_image_layer_merge);
 }
 
 static void image_keymap(struct wmKeyConfig *keyconf)
@@ -500,13 +511,32 @@
 	int i;
 	
 	WM_keymap_add_item(keymap, "IMAGE_OT_new", NKEY, KM_PRESS, KM_ALT, 0);
-	WM_keymap_add_item(keymap, "IMAGE_OT_open", OKEY, KM_PRESS, KM_ALT, 0);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_open", OKEY, KM_PRESS, KM_ALT, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_OPEN_IMAGE);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_open", OKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_OPEN_LAYER);
 	WM_keymap_add_item(keymap, "IMAGE_OT_reload", RKEY, KM_PRESS, KM_ALT, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_save", SKEY, KM_PRESS, KM_ALT, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_save_as", F3KEY, KM_PRESS, 0, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_properties", NKEY, KM_PRESS, 0, 0);
 	WM_keymap_add_item(keymap, "IMAGE_OT_scopes", TKEY, KM_PRESS, 0, 0);
 
+	/*Layers*/
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add", NKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add_above", UPARROWKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_add_below", DOWNARROWKEY, KM_PRESS, KM_SHIFT|KM_ALT, 0);
+
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_select", PAGEUPKEY, KM_PRESS, 0, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_SEL_PREVIOUS);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_select", PAGEDOWNKEY, KM_PRESS, 0, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_SEL_NEXT);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_select", HOMEKEY, KM_PRESS, 0, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_SEL_TOP);
+	kmi = WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_select", ENDKEY, KM_PRESS, 0, 0);
+	RNA_enum_set(kmi->ptr, "action", IMA_LAYER_SEL_BOTTOM);
+
+	WM_keymap_add_item(keymap, "IMAGE_OT_image_layer_clean", DELKEY, KM_PRESS, 0, 0);
+
 	WM_keymap_add_item(keymap, "IMAGE_OT_cycle_render_slot", JKEY, KM_PRESS, 0, 0);
 	RNA_boolean_set(WM_keymap_add_item(keymap, "IMAGE_OT_cycle_render_slot", JKEY, KM_PRESS, KM_ALT, 0)->ptr, "reverse", TRUE);
 	
@@ -850,6 +880,7 @@
 	}
 }
 
+
 /* *********************** buttons region ************************ */
 
 /* add handlers, stuff you only do once or on area/region changes */
Index: source/blender/editors/space_node/node_edit.c
===================================================================
--- source/blender/editors/space_node/node_edit.c	(revisione 45704)
+++ source/blender/editors/space_node/node_edit.c	(copia locale)
@@ -1348,8 +1348,8 @@
 
 	ED_image_draw_info(ar, (scene->r.color_mgt_flag & R_COLOR_MANAGEMENT), info->channels,
 	                   info->x, info->y, info->col, info->colf,
-	                   NULL, NULL /* zbuf - unused for nodes */
-	                   );
+	                   NULL, NULL, /* zbuf - unused for nodes */
+	                   1);
 }
 
 static void sample_apply(bContext *C, wmOperator *op, wmEvent *event)
Index: source/blender/makesdna/DNA_ID.h
===================================================================
--- source/blender/makesdna/DNA_ID.h	(revisione 45704)
+++ source/blender/makesdna/DNA_ID.h	(copia locale)
@@ -184,6 +184,7 @@
 #define ID_MA		MAKE_ID2('M', 'A') /* Material */
 #define ID_TE		MAKE_ID2('T', 'E') /* Texture */
 #define ID_IM		MAKE_ID2('I', 'M') /* Image */
+//#define ID_IL		MAKE_ID2('I', 'L') /* ImageLayer */
 #define ID_LT		MAKE_ID2('L', 'T') /* Lattice */
 #define ID_LA		MAKE_ID2('L', 'A') /* Lamp */
 #define ID_CA		MAKE_ID2('C', 'A') /* Camera */
Index: source/blender/makesdna/DNA_image_types.h
===================================================================
--- source/blender/makesdna/DNA_image_types.h	(revisione 45704)
+++ source/blender/makesdna/DNA_image_types.h	(copia locale)
@@ -34,6 +34,10 @@
 
 #include "DNA_ID.h"
 
+#ifndef MAX_LIMA
+#define MAX_LIMA	18
+#endif
+
 struct PackedFile;
 struct Scene;
 struct anim;
@@ -66,6 +70,211 @@
 #define IMA_ANIM_REFRESHED	2
 /* #define IMA_DO_PREMUL	4 */
 
+
+typedef struct ImageLayer {
+	struct ImageLayer *next, *prev;
+	//ID id;
+	//struct PreviewImage * preview;
+	char name[64];
+	char file_path[1024];
+	short background;
+	short color_space;
+	float opacity;
+	short mode;
+	short type;
+	short visible;
+	short select;
+	short lock;
+	short pad1;
+	int pad2;
+	//int icon_id;
+	float default_color[4];
+	ListBase ibufs;
+}ImageLayer;
+
+/* **************** IMAGE LAYER********************* */
+#define IMA_LAYER_MAX_LEN	64
+
+/* ImageLayer.background */
+#define IMA_LAYER_BG_RGB		(1<<0)
+#define IMA_LAYER_BG_WHITE		(1<<1)
+#define IMA_LAYER_BG_ALPHA		(1<<2)
+#define IMA_LAYER_BG_IMAGE		(1<<3)
+
+/* ImageLayer.color_space */
+#define IMA_LAYER_COL_RGB		(1<<0)
+#define IMA_LAYER_COL_GRAY		(1<<1)
+
+/* ImageLayer.mode */
+typedef enum ImageLayerMode {
+	IMA_LAYER_NORMAL = 0,
+
+	IMA_LAYER_MULTIPLY = 1,
+	IMA_LAYER_SCREEN = 2,
+	IMA_LAYER_OVERLAY = 3,
+	IMA_LAYER_SOFT_LIGHT = 4,
+	IMA_LAYER_HARD_LIGHT = 5,
+
+	IMA_LAYER_COLOR_DODGE = 6,
+	IMA_LAYER_LINEAR_DODGE = 7,
+	IMA_LAYER_COLOR_BURN = 8,
+	IMA_LAYER_LINEAR_BURN = 9,
+
+	IMA_LAYER_AVERAGE = 10,
+	IMA_LAYER_ADD = 11,
+	IMA_LAYER_SUBTRACT = 12,
+	IMA_LAYER_DIFFERENCE = 13,
+	IMA_LAYER_LIGHTEN = 14,
+	IMA_LAYER_DARKEN = 15,
+
+	IMA_LAYER_NEGATION = 16,
+	IMA_LAYER_EXCLUSION = 17,
+	
+	IMA_LAYER_LINEAR_LIGHT = 18,
+	IMA_LAYER_VIVID_LIGHT = 19,
+	IMA_LAYER_PIN_LIGHT = 20,
+	IMA_LAYER_HARD_MIX = 21
+}ImageLayerMode;
+
+/*#define ChannelBlend_Reflect(A,B)    ((uint8)((B == 255) ? B:min(255, (A * A / (255 - B)))))
+#define ChannelBlend_Glow(A,B)       (ChannelBlend_Reflect(B,A))
+#define ChannelBlend_Phoenix(A,B)    ((uint8)(min(A,B) - max(A,B) + 255))
+#define ChannelBlend_Alpha(A,B,O)    ((uint8)(O * A + (1 - O) * B))
+#define ChannelBlend_AlphaF(A,B,F,O) (ChannelBlend_Alpha(F(A,B),A,O))
+
+#define ColorBlend_Hue(T,A,B)            ColorBlend_Hls(T,A,B,HueB,LuminationA,SaturationA)
+#define ColorBlend_Saturation(T,A,B)     ColorBlend_Hls(T,A,B,HueA,LuminationA,SaturationB)
+#define ColorBlend_Color(T,A,B)          ColorBlend_Hls(T,A,B,HueB,LuminationA,SaturationB)
+#define ColorBlend_Luminosity(T,A,B)     ColorBlend_Hls(T,A,B,HueA,LuminationB,SaturationA)
+
+#define ColorBlend_Hls(T,A,B,O1,O2,O3) {
+    float64 HueA, LuminationA, SaturationA;
+    float64 HueB, LuminationB, SaturationL;
+    Color_RgbToHls((A)[2],(A)[1],(A)[0], &HueA, &LuminationA, &SaturationA);
+    Color_RgbToHls((B)[2],(B)[1],(B)[0], &HueB, &LuminationB, &SaturationB);
+    Color_HlsToRgb(O1,O2,O3,&(T)[2],&(T)[1],&(T)[0]);
+    }
+
+int32 Color_HueToRgb(float64 M1, float64 M2, float64 Hue, float64 *Channel)
+{
+    if (Hue < 0.0)
+        Hue += 1.0;
+    else if (Hue > 1.0)
+        Hue -= 1.0;
+
+    if ((6.0 * Hue) < 1.0)
+        *Channel = (M1 + (M2 - M1) * Hue * 6.0);
+    else if ((2.0 * Hue) < 1.0)
+        *Channel = (M2);
+    else if ((3.0 * Hue) < 2.0)
+        *Channel = (M1 + (M2 - M1) * ((2.0F / 3.0F) - Hue) * 6.0);
+    else
+        *Channel = (M1);
+
+    return TRUE;
+}
+
+int32 Color_RgbToHls(uint8 Red, uint8 Green, uint8 Blue, float64 *Hue, float64 *Lumination, float64 *Saturation)
+{
+    float64 Delta;
+    float64 Max, Min;
+    float64 Redf, Greenf, Bluef;
+
+    Redf    = ((float64)Red   / 255.0F);
+    Greenf  = ((float64)Green / 255.0F);
+    Bluef   = ((float64)Blue  / 255.0F); 
+
+    Max     = max(max(Redf, Greenf), Bluef);
+    Min     = min(min(Redf, Greenf), Bluef);
+
+    *Hue        = 0;
+    *Lumination = (Max + Min) / 2.0F;
+    *Saturation = 0;
+
+    if (Max == Min)
+        return TRUE;
+
+    Delta = (Max - Min);
+
+    if (*Lumination < 0.5)
+        *Saturation = Delta / (Max + Min);
+    else
+        *Saturation = Delta / (2.0 - Max - Min);
+
+    if (Redf == Max)
+        *Hue = (Greenf - Bluef) / Delta;
+    else if (Greenf == Max)
+        *Hue = 2.0 + (Bluef - Redf) / Delta;
+    else
+        *Hue = 4.0 + (Redf - Greenf) / Delta;
+
+    *Hue /= 6.0; 
+
+    if (*Hue < 0.0)
+        *Hue += 1.0;       
+
+    return TRUE;
+}
+
+int32 Color_HlsToRgb(float64 Hue, float64 Lumination, float64 Saturation, uint8 *Red, uint8 *Green, uint8 *Blue)
+{
+    float64 M1, M2;
+    float64 Redf, Greenf, Bluef;
+
+    if (Saturation == 0)
+        {
+        Redf    = Lumination;
+        Greenf  = Lumination;
+        Bluef   = Lumination;
+        }
+    else
+        {
+        if (Lumination <= 0.5)
+            M2 = Lumination * (1.0 + Saturation);
+        else
+            M2 = Lumination + Saturation - Lumination * Saturation;
+
+        M1 = (2.0 * Lumination - M2);
+
+        Color_HueToRgb(M1, M2, Hue + (1.0F / 3.0F), &Redf);
+        Color_HueToRgb(M1, M2, Hue, &Greenf);
+        Color_HueToRgb(M1, M2, Hue - (1.0F / 3.0F), &Bluef);
+        }
+
+    *Red    = (uint8)(Redf * 255);
+    *Blue   = (uint8)(Bluef * 255);
+    *Green  = (uint8)(Greenf * 255);
+
+    return TRUE;
+}
+
+*/
+
+/* ImageLayer.type */
+#define IMA_LAYER_BASE		(1<<0)
+#define IMA_LAYER_LAYER		(1<<1)
+
+/* ImageLayer.visible */
+#define IMA_LAYER_VISIBLE	(1<<0)
+
+/* ImageLayer.select */
+#define IMA_LAYER_SEL_CURRENT	(1<<0)
+#define	IMA_LAYER_SEL_PREVIOUS	(1<<1)
+#define	IMA_LAYER_SEL_NEXT		(1<<2)
+#define IMA_LAYER_SEL_TOP		(1<<3)
+#define IMA_LAYER_SEL_BOTTOM	(1<<4)
+
+/* ImageLayer.lock */
+#define IMA_LAYER_LOCK		(1<<0)
+
+/* Option for delete the layer*/
+#define IMA_LAYER_DEL_SELECTED	(1<<0)
+#define IMA_LAYER_DEL_HIDDEN	(1<<1)
+
+/* Option for open a image*/
+#define IMA_LAYER_OPEN_IMAGE	(1<<0)
+#define IMA_LAYER_OPEN_LAYER	(1<<1)
+
 typedef struct Image {
 	ID id;
 	
@@ -106,6 +315,9 @@
 	
 	/* display aspect - for UV editing images resized for faster openGL display */
 	float aspx, aspy;
+	int Act_Layers;
+	int Count_Layers;
+	ListBase imlayers;
 } Image;
 
 
Index: source/blender/makesdna/DNA_userdef_types.h
===================================================================
--- source/blender/makesdna/DNA_userdef_types.h	(revisione 45704)
+++ source/blender/makesdna/DNA_userdef_types.h	(copia locale)
@@ -258,9 +258,16 @@
 	char preview_stitch_stitchable[4];
 	char preview_stitch_unstitchable[4];
 	char preview_stitch_active[4];
+
+	char b_pad[3];
+	char show_boundary_layer;
+	char col1_boundary_layer[4];
+	char col2_boundary_layer[4];
 	
+
 	char match[4];				/* outliner - filter match */
 	char selected_highlight[4];	/* outliner - selected item */
+	char pad1[4];
 } ThemeSpace;
 
 
@@ -611,6 +618,9 @@
 #define TH_OLDSKOOL 	3
 #define TH_SHADED   	4
 
+/* Active boundarie_layer */
+#define TH_IMAGE_LAYER_BOUNDARY (1<<0)
+
 /* ndof_flag (3D mouse options) */
 #define NDOF_SHOW_GUIDE     (1 << 0)
 #define NDOF_FLY_HELICOPTER (1 << 1)
Index: source/blender/makesrna/intern/rna_image.c
===================================================================
--- source/blender/makesrna/intern/rna_image.c	(revisione 45704)
+++ source/blender/makesrna/intern/rna_image.c	(copia locale)
@@ -38,6 +38,7 @@
 #include "BKE_context.h"
 #include "BKE_depsgraph.h"
 #include "BKE_image.h"
+#include "BKE_layer.h"
 
 #include "WM_types.h"
 #include "WM_api.h"
@@ -50,6 +51,31 @@
 	{IMA_SRC_VIEWER, "VIEWER", 0, "Viewer", "Compositing node viewer"},
 	{0, NULL, 0, NULL, NULL}};
 
+EnumPropertyItem image_layer_mode_items[] = {
+	{IMA_LAYER_NORMAL, "NORMAL", 0, "Normal", ""},
+	{IMA_LAYER_MULTIPLY, "MULTIPLY", 0, "Multiply", ""},
+	{IMA_LAYER_SCREEN, "SCREEN", 0, "Screen", ""},
+	{IMA_LAYER_OVERLAY, "OVERLAY", 0, "Overlay", ""},
+	{IMA_LAYER_SOFT_LIGHT, "SOFT_LIGHT", 0, "Soft Light", ""},
+	{IMA_LAYER_HARD_LIGHT, "HARD_LIGHT", 0, "Hard Light", ""},
+	{IMA_LAYER_COLOR_DODGE, "COLOR_DODGE", 0, "Color Dodge", ""},
+	{IMA_LAYER_LINEAR_DODGE, "LINEAR_DODGE", 0, "Linear Dodge", ""},
+	{IMA_LAYER_COLOR_BURN, "COLOR_BURN", 0, "Color Burn", ""},
+	{IMA_LAYER_LINEAR_BURN, "LINEAR_BURN", 0, "Linear Burn", ""},
+	{IMA_LAYER_AVERAGE, "AVERAGE", 0, "Average", ""},
+	{IMA_LAYER_ADD, "ADD", 0, "Add", ""},
+	{IMA_LAYER_SUBTRACT, "SUBTRACT", 0, "Subtract", ""},
+	{IMA_LAYER_DIFFERENCE, "DIFFERENCE", 0, "Difference", ""},
+	{IMA_LAYER_LIGHTEN, "LIGHTEN", 0, "Lighten", ""}, 
+	{IMA_LAYER_DARKEN, "DARKEN", 0, "Darken", ""}, 
+	{IMA_LAYER_NEGATION, "NEGATION", 0, "Negation", ""},
+	{IMA_LAYER_EXCLUSION, "EXCLUSION", 0, "Exclusion", ""},
+	{IMA_LAYER_LINEAR_LIGHT, "LINEAR_LIGHT", 0, "Linear Light", ""},
+	{IMA_LAYER_VIVID_LIGHT, "VIVID_LIGHT", 0, "Vivid Light", ""},
+	{IMA_LAYER_PIN_LIGHT, "PIN_LIGHT", 0, "Pin Light", ""}, 
+	{IMA_LAYER_HARD_MIX, "HARD_MIX", 0, "Hard Mix", ""},
+	{0, NULL, 0, NULL, NULL}};
+
 #ifdef RNA_RUNTIME
 
 #include "IMB_imbuf_types.h"
@@ -286,6 +312,62 @@
 	return planes;
 }
 
+static PointerRNA rna_Image_active_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= imalayer_get_current(ima);
+ 
+	return rna_pointer_inherit_refine(ptr, &RNA_ImageLayer, layer);
+}
+
+static void rna_Image_active_image_layer_set(PointerRNA *ptr, PointerRNA value)
+{
+	Image *ima= (Image*)ptr->data;
+	ImageLayer *layer= (ImageLayer*)value.data;
+	const int index= BLI_findindex(&ima->imlayers, layer);
+	if (index != -1) ima->Act_Layers= index;
+}
+
+static void rna_Image_layers_begin(CollectionPropertyIterator *iter, PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	rna_iterator_listbase_begin(iter, &ima->imlayers, NULL);
+}
+
+static int rna_Image_count_image_layer_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_count(ima);
+}
+
+static int rna_Image_active_image_layer_index_get(PointerRNA *ptr)
+{
+	Image *ima= (Image*)ptr->data;
+	return imalayer_get_current_act(ima);
+}
+ 
+static void rna_Image_active_image_layer_index_set(PointerRNA *ptr, int value)
+{
+	Image *ima= (Image*)ptr->data;
+	imalayer_set_current_act(ima, value);
+}
+ 
+static void rna_Image_active_image_layer_index_range(PointerRNA *ptr, int *min, int *max)
+{
+	Image *im= (Image*)ptr->data;
+	void *lock;
+	ImBuf *ibuf= BKE_image_acquire_ibuf(im, NULL, &lock);
+
+	/**min= 0;
+	*max= BLI_countlist(&im->imlayers)-1;
+	*max= MAX2(0, *max);*/
+	*min= BLI_countlist(&im->imlayers)-1;
+	*max= 0;
+	*min= MAX2(0, *min);
+
+	BKE_image_release_ibuf(im, lock);
+}
+
 static int rna_Image_pixels_get_length(PointerRNA *ptr, int length[RNA_MAX_ARRAY_DIMENSION])
 {
 	Image *ima = ptr->id.data;
@@ -413,6 +495,111 @@
 	RNA_def_property_ui_text(prop, "Pass", "Pass in multilayer image");
 }
 
+static void rna_def_image_layer_common(StructRNA *srna)
+{
+	PropertyRNA *prop;
+
+	static EnumPropertyItem prop_type_items[] = {
+		{IMA_LAYER_BASE, "BASE", 0, "Base", ""},
+		{IMA_LAYER_LAYER, "LAYER", 0, "Layer", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	static EnumPropertyItem prop_background_items[] = {
+		{IMA_LAYER_BG_RGB, "RGB", 0, "RGB", ""},
+		{IMA_LAYER_BG_WHITE, "WHITE", 0, "White", ""},
+		{IMA_LAYER_BG_ALPHA, "ALPHA", 0, "Transparent", ""},
+		{0, NULL, 0, NULL, NULL}};
+
+	prop= RNA_def_property(srna, "name", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_default(prop, "ImageLayer");
+	RNA_def_property_string_maxlength(prop, IMA_LAYER_MAX_LEN);
+	RNA_def_property_update(prop, NC_OBJECT|ND_MODIFIER|NA_RENAME, NULL);
+	RNA_def_property_ui_text(prop, "Name", "The name of the image layer.");
+	RNA_def_struct_name_property(srna, prop);
+
+ 	prop= RNA_def_property(srna, "visible", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_ui_text(prop, "", "Hides the layer in the UV/Image Editor");
+	RNA_def_property_boolean_sdna(prop, NULL, "visible", IMA_LAYER_VISIBLE);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "lock", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_ui_text(prop, "", "Blocks the layer in the UV/Image Editor");
+	RNA_def_property_boolean_sdna(prop, NULL, "lock", IMA_LAYER_LOCK);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "opacity", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "opacity");
+	RNA_def_property_range(prop, 0.0, 1.0);
+	RNA_def_property_ui_range(prop, 0, 1.0, 1, 3);
+	RNA_def_property_ui_text(prop, "Opacity", "The opacity of the image layer when blended.");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "blend_type", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "mode");
+	RNA_def_property_enum_items(prop, image_layer_mode_items);
+	RNA_def_property_ui_text(prop, "Blend Modes", "Determine how two Layers are blended into each other.");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "background", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_sdna(prop, NULL, "background");
+	RNA_def_property_enum_items(prop, prop_background_items);
+	RNA_def_property_ui_text(prop, "Type Background", "");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "type", PROP_ENUM, PROP_NONE);
+	//RNA_def_property_ui_text(prop, "", "Defines the type of layer");
+	//RNA_def_property_boolean_sdna(prop, NULL, "type", IMA_LAYER_BASE);
+	RNA_def_property_enum_sdna(prop, NULL, "type");
+	RNA_def_property_enum_items(prop, prop_type_items);
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
+static void rna_def_image_layer(BlenderRNA *brna)
+{
+	StructRNA *srna;
+		
+	srna= RNA_def_struct(brna, "ImageLayer", NULL);
+	RNA_def_struct_ui_text(srna, "Image Layer", "Image layer");
+	RNA_def_struct_ui_icon(srna, ICON_TEXTURE_DATA);
+
+	rna_def_image_layer_common(srna);
+}
+
+static void rna_def_image_layers(BlenderRNA *brna, PropertyRNA *cprop)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	FunctionRNA *func;
+	PropertyRNA *parm;
+
+	RNA_def_property_srna(cprop, "ImageLayers");
+	srna= RNA_def_struct(brna, "ImageLayers", NULL);
+	RNA_def_struct_sdna(srna, "Image");
+	RNA_def_struct_ui_text(srna, "Image Layers", "Image layer");
+
+	prop= RNA_def_property(srna, "active_image_layer", PROP_POINTER, PROP_NONE);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_pointer_funcs(prop, "rna_Image_active_image_layer_get", 
+								   "rna_Image_active_image_layer_set", NULL, NULL);
+	RNA_def_property_flag(prop, PROP_EDITABLE|PROP_NEVER_NULL);
+	RNA_def_property_ui_text(prop, "Active Image Layer", "Active image layer");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+ 
+	prop= RNA_def_property(srna, "active_image_layer_index", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Act_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_active_image_layer_index_get", "rna_Image_active_image_layer_index_set", 
+							   "rna_Image_active_image_layer_index_range");
+	RNA_def_property_ui_text(prop, "Active Image Layer Index", "Index of active image layer slot");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+
+	prop= RNA_def_property(srna, "count_image_layers", PROP_INT, PROP_UNSIGNED);
+	RNA_def_property_int_sdna(prop, NULL, "Count_Layers");
+	RNA_def_property_int_funcs(prop, "rna_Image_count_image_layer_get", NULL, NULL);
+	RNA_def_property_ui_text(prop, "Total number of layers", "");
+	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
+}
+
 static void rna_def_image(BlenderRNA *brna)
 {
 	StructRNA *srna;
@@ -479,6 +666,14 @@
 	RNA_def_property_ui_text(prop, "Field Order", "Order of video fields (select which lines are displayed first)");
 	RNA_def_property_update(prop, NC_IMAGE|ND_DISPLAY, NULL);
 	
+	/* Image Layers */
+ 	prop= RNA_def_property(srna, "image_layers", PROP_COLLECTION, PROP_NONE);
+	RNA_def_property_collection_sdna(prop, NULL, "imlayers", NULL);
+	RNA_def_property_struct_type(prop, "ImageLayer");
+	RNA_def_property_collection_funcs(prop, "rna_Image_layers_begin", "rna_iterator_listbase_next", "rna_iterator_listbase_end", "rna_iterator_listbase_get", 0, 0, 0, 0);
+	RNA_def_property_ui_text(prop, "Image Layers", "");
+	rna_def_image_layers(brna, prop);
+
 	/* booleans */
 	prop = RNA_def_property(srna, "use_fields", PROP_BOOLEAN, PROP_NONE);
 	RNA_def_property_boolean_sdna(prop, NULL, "flag", IMA_FIELDS);
@@ -636,6 +831,7 @@
 
 void RNA_def_image(BlenderRNA *brna)
 {
+	rna_def_image_layer(brna);
 	rna_def_image(brna);
 	rna_def_imageuser(brna);
 }
Index: source/blender/makesrna/intern/rna_ui_api.c
===================================================================
--- source/blender/makesrna/intern/rna_ui_api.c	(revisione 45704)
+++ source/blender/makesrna/intern/rna_ui_api.c	(copia locale)
@@ -388,6 +388,14 @@
 	RNA_def_boolean(func, "lock_luminosity", 0, "", "Keep the color at its original vector length");
 	RNA_def_boolean(func, "cubic", 1, "", "Cubic saturation for picking values close to white");
 
+	func = RNA_def_function(srna, "template_color", "uiTemplateColor");
+	RNA_def_function_ui_description(func, "Item. A color widget to pick colors");
+	api_ui_item_rna_common(func);
+	RNA_def_boolean(func, "value_slider", 0, "", "Display the value slider to the bottom of the color wheel");
+	RNA_def_boolean(func, "lock", 0, "", "Lock the color wheel display to value 1.0 regardless of actual color");
+	RNA_def_boolean(func, "lock_luminosity", 0, "", "Keep the color at its original vector length");
+	RNA_def_boolean(func, "cubic", 1, "", "Cubic saturation for picking values close to white");
+
 	func = RNA_def_function(srna, "template_image_layers", "uiTemplateImageLayers");
 	RNA_def_function_flag(func, FUNC_USE_CONTEXT);
 	parm = RNA_def_pointer(func, "image", "Image", "", "");
Index: source/blender/makesrna/intern/rna_userdef.c
===================================================================
--- source/blender/makesrna/intern/rna_userdef.c	(revisione 45704)
+++ source/blender/makesrna/intern/rna_userdef.c	(copia locale)
@@ -1705,6 +1705,24 @@
 	RNA_def_property_array(prop, 4);
 	RNA_def_property_ui_text(prop, "Stitch preview active island", "");
 	RNA_def_property_update(prop, 0, "rna_userdef_update");
+
+	prop= RNA_def_property(srna, "show_boundary_layer", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "show_boundary_layer", TH_IMAGE_LAYER_BOUNDARY);
+	RNA_def_property_ui_text(prop, "Show Layer Boundary", "When enabled, the layer boundary is visible by default");
+	RNA_def_property_update(prop, 0, "rna_userdef_update");
+
+	prop = RNA_def_property(srna, "col1_boundary_layer", PROP_FLOAT, PROP_COLOR_GAMMA);
+	RNA_def_property_float_sdna(prop, NULL, "col1_boundary_layer");
+	RNA_def_property_array(prop, 4);
+	RNA_def_property_ui_text(prop, "Color 1 Boundary Layer", "");
+	RNA_def_property_update(prop, 0, "rna_userdef_update");
+
+	prop = RNA_def_property(srna, "col2_boundary_layer", PROP_FLOAT, PROP_COLOR_GAMMA);
+	RNA_def_property_float_sdna(prop, NULL, "col2_boundary_layer");
+	RNA_def_property_array(prop, 4);
+	RNA_def_property_ui_text(prop, "Color 2 Boundary Layer", "");
+	RNA_def_property_update(prop, 0, "rna_userdef_update");
+
 }
 
 static void rna_def_userdef_theme_space_seq(BlenderRNA *brna)
Index: source/blender/makesrna/RNA_access.h
===================================================================
--- source/blender/makesrna/RNA_access.h	(revisione 45704)
+++ source/blender/makesrna/RNA_access.h	(copia locale)
@@ -257,6 +257,7 @@
 extern StructRNA RNA_ID;
 extern StructRNA RNA_IKParam;
 extern StructRNA RNA_Image;
+extern StructRNA RNA_ImageLayer;
 extern StructRNA RNA_ImageFormatSettings;
 extern StructRNA RNA_ImagePaint;
 extern StructRNA RNA_ImageSequence;
Index: source/blenderplayer/bad_level_call_stubs/stubs.c
===================================================================
--- source/blenderplayer/bad_level_call_stubs/stubs.c	(revisione 45704)
+++ source/blenderplayer/bad_level_call_stubs/stubs.c	(copia locale)
@@ -414,6 +414,7 @@
 void uiTemplateImage(struct uiLayout *layout, struct bContext *C, struct PointerRNA *ptr, char *propname, struct PointerRNA *userptr, int compact){}
 void uiTemplateDopeSheetFilter(struct uiLayout *layout, struct bContext *C, struct PointerRNA *ptr){}
 void uiTemplateColorWheel(struct uiLayout *layout, struct PointerRNA *ptr, char *propname, int value_slider){}
+void uiTemplateColor(struct uiLayout *layout, struct PointerRNA *ptr, char *propname, int value_slider){}
 void uiTemplateHistogram(struct uiLayout *layout, struct PointerRNA *ptr, char *propname, int expand){}
 void uiTemplateReportsBanner(struct uiLayout *layout, struct bContext *C, struct wmOperator *op){}
 void uiTemplateWaveform(struct uiLayout *layout, struct PointerRNA *ptr, char *propname, int expand){}
Phase 1:
    Stage    : Management
    Target   : Management and operations common to organize Layer.
    Deadline : 15/04/2012
    Amount   : 500€
    Info     : 
        1) Operations management layer.
            Menu Layer
                |-> Add
                    |-> New Layer
                    |-> ------------------
                    |-> Above active layer
                    |-> Below active layer
                |-> Duplicate Layer
                |-> Clear Layer
                |-> Remove Layer
                    |-> Layer
                    |-> Hidden Layers
                |-> Merge
                    |-> Merge Layers
                    |-> Merge Visible
                    |-> Unique layers
                |-> ------------------
                |-> Select
                    |-> Select the previous layer
                    |-> Select the next layer
                    |-> Select the top layer
                    |-> Select the bottom layer
                |-> Order
                    |-> Layer to Top
                    |-> Raise Layer
                    |-> Lower Layer
                    |-> Layer to Bottom
                    |-> ------------------
                    |-> Reverse Layer Order
        2) Insert image as a layer.
        3) Undo & Redo Layer.
        4) Lock Layer.
        5) Reading and saving in files. Blend.
        6) Dashed Border Layer.
        7) Improving and adding some other Blend Mode.


Phase 2:
    Stage    : Transform
    Target   : Simple operation to change the selected layer.
    Deadline : Defined after phase 1
    Amount   : 800€
    Info     : 
        1) Operations for manipulating layers.
            Menu Layer
                |-> Order ...
                |-> Transform
                    |-> Flip Horizontally
                    |-> Flip Vertically
                    |-> ------------------
                    |-> Rotate 90° clockwise
                    |-> Rotate 90° counter-clockwise
                    |-> Rotate 180°
                    |-> Arbitrary Rotation
                    |-> ------------------
                    |-> Offset
                |-> Scale
                    |-> Layer Boundary Size
                    |-> Layer to Image Size
                    |-> Scale Layer
        2) Begin integration layer with Blender.


Phase 3:
    Stage    : Color
    Target   : Operation for the color management.
    Deadline : Defined after phase 2
    Amount   : 1200€
    Info     : 
        1) Exposure, Saturation, Hue, Contrast, Color Temperature and Tint, Sharpness.
        2) Add GrayScale for the Color Space.
        3) Integration layer with Blender.


Phase 4:
    Stage    : Import & Export
    Target   : Import and export in the formats most commonly used layer.
    Deadline : Defined after phase 3
    Amount   : 2000€
    Info     : Import and Export in ora, xcf, ...


Phase 5: 
    Stage    : Tools
    Target   : Paint Tools, Selection Tools, Generic Tools
    Deadline : Defined after phase 4
    Amount   : 2500€
    Info     : 
        1) Paint Tools: Color Picker, Text Tool, Bucket Fill, Shapes.
        2) Selection Tools: Rectangle, Ellipse, Free, Polygonal.
        3) Generic Tools: Griglia, Hand Tool, ...


Phase 6: 
    Stage    : Brush
    Target   : Improvement Brush 
    Deadline : Defined after phase 5
    Amount   : 3000€
    Info     :
        1) Import the improvements made by Jason Wilkins in GSOC 2011.
        2) Add Blend Mode for Brushes.
        3) To be defined yet!
